{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Ares-SC2 Documentation","text":"<p>Please Note: The documentation is an ongoing project.  Please feel free to contribute or raise an issue for anything that is missing or broke.</p>"},{"location":"index.html#get-started-quickly-with-ares-sc2","title":"Get Started Quickly with <code>ares-sc2</code>","text":"<p>We recommend all users to take a read of the gotcha's tutorial once they begin developing their <code>ares</code> bot.</p>"},{"location":"index.html#new-bot-author","title":"New bot author","text":"<p>For authors eager to establish a local bot development environment right away, we  recommend using the ares-sc2-bot-template and follow the instructions in that repo. </p> <p>If you're new to python-sc2, we suggest familiarizing yourself with it first. Take a look at some examples and documentation on that repository. You can still write <code>python-sc2</code> code as usual within the blank starter bot, making it a good option for learning the basics.</p>"},{"location":"index.html#existing-python-sc2-users","title":"Existing <code>python-sc2</code> users","text":"<p>Migrating your existing bot made with python-sc2 to <code>ares-sc2</code>, is a fairly straight forward process in most instances. Check out the migration tutorial.</p> <p>In any case glancing through the tutorials and the api docs should give you an idea of what <code>ares-sc2</code> can offer.</p>"},{"location":"index.html#about","title":"About","text":"<p><code>Ares-sc2</code> is a library that extends the capabilities of the python-sc2 framework. The fundamental principle driving the evolution of  <code>ares-sc2</code> is to empower users with full command over strategic decisions. Consequently, the library is designed to offer supportive functionalities for bot developers,  avoiding preconceived choices out of the box. In fact when initiating a project with <code>ares-sc2</code>, it closely  resembles starting with a blank <code>python-sc2</code> bot! You can write standard <code>python-sc2</code> logic and call upon <code>ares</code> functionality as required.</p>"},{"location":"index.html#bots-made-with-ares-sc2","title":"Bots made with <code>ares-sc2</code>","text":"<p>Feel free to add your own bot here</p> <ul> <li>AresRandomExample (R)</li> <li>Aristaeus (P)</li> <li>Nani-Z (Z) micro ladder bot</li> <li>oops (R) micro ladder bot</li> <li>QueenBot (Z)</li> <li>12PoolBot (Z)</li> </ul>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Highly customizable and extendable behavior system. Curate custom combat maneuvers and macro plans.</li> <li><code>ManagerMediator</code> to facilitate communication and retrieve information from managers in <code>ares</code>,  see docs here</li> <li>Manage production by declaring army compositions, less repetitive boilerplate code in your bot. See tutorial here</li> <li>Memory units tracking by default. Track units that have recently entered fog of war.</li> <li>Pre-calculated building formation for all maps and bases (Terran and Protoss only).</li> <li>MapAnalyzer library available  via <code>self.mediator.get_map_data_object</code></li> <li>Pathfinding with populated influence grids available as needed.</li> <li>Opt in Build runner system, easily curate new builds via a config file.</li> <li>Data management, set multiple builds via the build runner system and <code>ares</code> will cycle through them on defeat.</li> <li>Cython alternatives available via the cython-extensions-sc2 library.</li> <li>Unit Role management system, a must-have for managing different groups of units.</li> <li>Debug unit spawning at camera location.</li> </ul>"},{"location":"index.html#getting-started","title":"Getting started","text":"<p>New to bot development? We've got you covered! Begin with the ares-sc2-bot-template to set up your environment.  The tutorial provides a blank bot to help you get started.  If you're ready to explore features in <code>ares-sc2</code>, checking out the tutorials section would be a good next step.</p> <p>Familiar to bot development and <code>python-sc2</code>? Converting your existing bot to <code>ares-sc2</code> should be seamless in most instances, check out the migration guide.</p>"},{"location":"dev-guide.html","title":"Required reading only if planning to contribute to Ares or understand inner workings","text":"<p>TODO</p>"},{"location":"api_reference/index.html","title":"API Reference","text":"<p>Explore the menu to access the available features, organized into two main sections:</p> <ul> <li>Behaviors: Learn how to create custom combat strategies or macro plans. Each behavior can be run  independently, allowing you to adapt them to your specific needs.</li> <li>Manager Mediator: This tool coordinates multiple managers in the background and is the preferred  method for accessing the data and functions within these managers.</li> </ul> <p>Convenient methods globally available: </p>"},{"location":"api_reference/index.html#ares.main.AresBot","title":"<code>AresBot</code>","text":"<p>               Bases: <code>CustomBotAI</code></p> <p>Final setup of CustomBotAI for usage.</p> <p>Most bot logic should go in Hub.</p> Source code in <code>src/ares/main.py</code> <pre><code>class AresBot(CustomBotAI):\n    \"\"\"Final setup of CustomBotAI for usage.\n\n    Most bot logic should go in Hub.\n    \"\"\"\n\n    behavior_executioner: BehaviorExecutioner  # executes behaviors on each step\n    build_order_runner: BuildOrderRunner  # execute exact build order from config\n    cost_dict: Dict[UnitID, Cost]  #: UnitTypeId to cost for faster lookup later\n    manager_hub: Hub  #: Hub in charge of handling the Managers\n    NYDUSES: set[UnitID] = {UnitID.NYDUSCANAL, UnitID.NYDUSNETWORK}\n    UNIT_TYPES_NOT_IN_SLIM: set[UnitID] = {\n        UnitID.EGG,\n        UnitID.LARVA,\n        UnitID.CHANGELINGMARINE,\n        UnitID.CHANGELINGMARINESHIELD,\n        UnitID.CHANGELINGZEALOT,\n        UnitID.CHANGELINGZERGLING,\n        UnitID.CHANGELINGZERGLINGWINGS,\n        UnitID.CREEPTUMOR,\n        UnitID.CREEPTUMORQUEEN,\n    }\n\n    def __init__(self, game_step_override: Optional[int] = None):  # pragma: no cover\n        \"\"\"Load config and set up necessary attributes.\n\n        Parameters\n        ----------\n        game_step_override :\n            If provided, set the game_step to this value regardless of how it was\n            specified elsewhere\n        \"\"\"\n        super().__init__()\n        # otherwise we use the config.yml file\n        __ares_config_location__: str = path.realpath(\n            path.join(getcwd(), path.dirname(__file__))\n        )\n        # If running from exe we need path to exe file\n        if getattr(sys, \"frozen\", False):\n            # Running as PyInstaller exe\n            # sys.executable = \"C:/Users/name/Desktop/mybot.exe\"\n            # path.dirname() gives \"C:/Users/name/Desktop\"\n            self.__user_config_location__ = path.dirname(sys.executable)\n        # Running from source code\n        else:\n            # path.abspath(\".\") gives current directory\n            self.__user_config_location__ = path.abspath(\".\")\n\n        config_parser: ConfigParser = ConfigParser(\n            __ares_config_location__, self.__user_config_location__, CONFIG_FILE\n        )\n\n        self.config = config_parser.parse()\n\n        self.game_step_override: Optional[int] = game_step_override\n        self.unit_tag_dict: dict[int, Unit] = {}\n        self.chat_debug = None\n        self.forcefield_to_bile_dict: dict[Point2, int] = {}\n        self.last_game_loop: int = -1\n\n        # track adept shades as we only add them towards shade completion (160 frames)\n        # Key: tag of shade Value: frame shade commenced (+32 if no adept owner found)\n        self.adept_shades: DefaultDict[int, Dict] = defaultdict(dict)\n        self.adept_tags_with_shades_assigned: Set[int] = set()\n        # we skip python-sc2 iterations in realtime, so we keep track of our own one\n        self.actual_iteration: int = 0\n        self.WORKER_TYPES = WORKER_TYPES | {UnitID.DRONEBURROWED}\n        self.supply_type: UnitID = UnitID.OVERLORD\n        self.num_larva_left: int = 0\n\n        self._same_order_actions: list[\n            tuple[AbilityId, set[int], Optional[Union[Unit, Point2]]]\n        ] = []\n        self._drop_unload_actions: list[tuple[int, int]] = []\n        self._archon_morph_actions: list[list] = []\n        self._requested_zerg_placements: list[tuple] = []\n        self.transfused_tags: set[int] = set()\n\n        self.arcade_mode: bool = False\n\n    def give_same_action(\n        self,\n        order: AbilityId,\n        unit_tags: Union[List[int], set[int]],\n        target: Optional[Union[Point2, int]] = None,\n    ) -&gt; None:\n        self._same_order_actions.append((order, unit_tags, target))\n\n    def do_unload_container(self, container_tag: int, index: int = 0) -&gt; None:\n        self._drop_unload_actions.append((container_tag, index))\n\n    def request_archon_morph(self, templar: list[Unit]) -&gt; None:\n        self._archon_morph_actions.append(templar)\n\n    def request_zerg_placement(\n        self, base_location: Point2, structure_type: UnitID\n    ) -&gt; None:\n        self._requested_zerg_placements.append((base_location, structure_type))\n\n    async def _prepare_step(self, state, proto_game_info) -&gt; None:\n        \"\"\"\n        If playing in realtime, we set the game step to 1 (in on_start) and then\n        manually skip frames. This gives Ares a time limit of 4 frames (45ms per frame)\n        to finish an iteration. Playing every 4th frame seems to be the generally\n        accepted solution to prevent weird things going on. And from Ares' point of\n        view, they have a better chance of running smoothly on older PC's.\n        \"\"\"\n        self.state = state\n        loop: int = state.game_loop\n        if self.realtime and self.last_game_loop + 4 &gt; loop and loop != 0:\n            return\n\n        self.last_game_loop = loop\n        return await super()._prepare_step(state, proto_game_info)\n\n    # noinspection PyFinal\n    def _prepare_units(self):  # pragma: no cover\n        \"\"\"Tweak of _prepare_units to include memory units in cached distances and some\n        other tracking.\n\n        Returns\n        -------\n\n        \"\"\"\n        update_managers: bool = hasattr(self, \"manager_hub\")\n        self._reset_variables()\n        # there's going to be a lot of appending, so form Units at the end\n        batteries_list: List[Unit] = []\n        cannons_list: List[Unit] = []\n        enemy_vs_ground_static_defense_list = []\n        self._clear_adept_shades()\n\n        if update_managers:\n            self._reset_managers()\n\n        index: int = 0\n        for unit in self.state.observation_raw.units:\n            alliance: int = unit.alliance\n\n            unit_type: int = unit.unit_type\n\n            # Convert these units to effects:\n            # reaper grenade, parasitic bomb dummy, forcefield\n            if unit_type in FakeEffectID:\n                fake_unit = EffectData(unit, fake=True)\n                self.state.effects.add(fake_unit)\n                # our parasitic bomb that isn't attached to an enemy\n                if unit_type == UnitID.PARASITICBOMBDUMMY.value:\n                    if unit.alliance == 1:\n                        self.friendly_parasitic_bomb_positions.append(\n                            list(fake_unit.positions)[0]\n                        )\n                    else:\n                        self.enemy_parasitic_bomb_positions.append(\n                            list(fake_unit.positions)[0]\n                        )\n                continue\n\n            unit_obj = Unit(\n                unit,\n                self,\n                distance_calculation_index=index,\n                base_build=self.base_build,\n            )\n            tag: int = unit_obj.tag\n\n            if unit_obj.type_id in ALL_GAS:\n                self.all_gas_buildings.append(unit_obj)\n\n            if tag not in self._used_tumors:\n                index += 1\n                self.all_units.append(unit_obj)\n                self.unit_tag_dict[tag] = unit_obj\n\n            if unit.display_type == IS_PLACEHOLDER:\n                self.placeholders.append(unit_obj)\n                continue\n\n            # Alliance.Neutral.value = 3\n            if alliance == 3:\n                self._add_neutral_unit(unit_obj, unit_type)\n\n            # Alliance.Self.value = 1\n            elif alliance == 1:\n                self._add_own_unit(unit_obj, update_managers, UnitID(unit_type), tag)\n\n            # Alliance.Enemy.value = 4\n            elif alliance == 4:\n                if not self._should_add_unit(unit):\n                    continue\n                (\n                    batteries_list,\n                    cannons_list,\n                    enemy_vs_ground_static_defense_list,\n                ) = self._add_enemy_unit(\n                    batteries_list,\n                    cannons_list,\n                    enemy_vs_ground_static_defense_list,\n                    unit_obj,\n                    update_managers,\n                    UnitID(unit_type),\n                )\n\n        self.batteries = Units(batteries_list, self)\n        self.cannons = Units(cannons_list, self)\n        self.enemy_vs_ground_static_defense = Units(\n            enemy_vs_ground_static_defense_list, self\n        )\n        self.num_larva_left = len(self.larva)\n\n        if update_managers:\n            self._update_memory_units(index)\n\n        _ = self._cdist\n\n    async def on_before_start(self) -&gt; None:  # pragma: no cover\n        \"\"\"Train a drone and split workers before managers are set up\n\n        Called before bot properly initializes\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # optional build order config from a user, add to the existing config dictionary\n        __user_build_orders_location__: str = path.join(\n            self.__user_config_location__, f\"{self.race.name.lower()}_builds.yml\"\n        )\n        if path.isfile(__user_build_orders_location__):\n            with open(__user_build_orders_location__, \"r\") as config_file:\n                build_order_config: dict = yaml.safe_load(config_file)\n                self.config.update(build_order_config)\n\n        self.gas_type = race_gas[self.race]\n        self.worker_type = race_worker[self.race]\n        self.supply_type = RACE_SUPPLY[self.race]\n        if self.race != Race.Zerg:\n            self.base_townhall_type = (\n                UnitID.COMMANDCENTER if self.race == Race.Terran else UnitID.NEXUS\n            )\n        else:\n            self.base_townhall_type = UnitID.HATCHERY\n\n    async def on_start(self) -&gt; None:  # pragma: no cover\n        \"\"\"Set up game step, managers, and information that requires game data\n\n        Called just before the first step, all game info is available\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # manually skip the frames in realtime\n        if self.realtime:\n            self.client.game_step = 1\n        elif self.game_step_override:\n            self.client.game_step = self.game_step_override\n        else:\n            # set the game step from config\n            self.client.game_step = (\n                self.config[GAME_STEP]\n                if not self.config[DEBUG]\n                else self.config[DEBUG_GAME_STEP]\n            )\n\n        if not self.enemy_start_locations or not self.townhalls:\n            self.arcade_mode = True\n\n        self.register_managers()\n\n        self.build_order_runner: BuildOrderRunner = BuildOrderRunner(\n            self,\n            self.manager_hub.data_manager.chosen_opening,\n            self.config,\n            self.manager_hub.manager_mediator,\n        )\n        self.behavior_executioner: BehaviorExecutioner = BehaviorExecutioner(\n            self, self.config, self.manager_hub.manager_mediator\n        )\n\n        if self.config[DEBUG] and self.config[DEBUG_OPTIONS][CHAT_DEBUG]:\n            from ares.chat_debug import ChatDebug\n\n            self.chat_debug = ChatDebug(self)\n\n        self.cost_dict: Dict[UnitID, Cost] = COST_DICT\n\n    def register_managers(self) -&gt; None:\n        \"\"\"Register standard and custom managers.\n\n        Override in your bot class if you wish to use custom managers.\n\n        Examples\n        --------\n        custom_production_manager = CustomProductionManager(\n            self, self.config, manager_mediator\n        )\n        new_manager = NewManager(self, self.config, manager_mediator)\n\n        self.manager_hub = Hub(\n            self,\n            self.config,\n            manager_mediator,\n            production_manager=custom_production_manager,\n            additional_managers=[new_manager],\n        )\n\n        Returns\n        -------\n        None\n        \"\"\"\n        manager_mediator: ManagerMediator = ManagerMediator()\n        self.manager_hub = Hub(self, self.config, manager_mediator)\n        self.manager_hub.init_managers()\n\n    async def on_step(self, iteration: int) -&gt; None:  # pragma: no cover\n        \"\"\"Play the game\n\n        Called on every game step\n\n        Parameters\n        ----------\n        iteration : int\n            The current game iteration\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        await self.manager_hub.update_managers(self.actual_iteration)\n        if not self.build_order_runner.build_completed:\n            await self.build_order_runner.run_build()\n\n        # detect scouts used by the build runner that are finished\n        if self.time &lt; 390.0:\n            if scouts := [\n                w\n                for w in self.mediator.get_units_from_role(\n                    role=UnitRole.BUILD_RUNNER_SCOUT, unit_type=WORKER_TYPES\n                )\n                if w.is_idle\n            ]:\n                for scout in scouts:\n                    self.mediator.assign_role(tag=scout.tag, role=UnitRole.GATHERING)\n\n        self.actual_iteration += 1\n        if self.chat_debug:\n            # trunk-ignore(mypy/unreachable)\n            await self.chat_debug.parse_commands()\n\n    async def _after_step(self) -&gt; int:\n        self.behavior_executioner.execute()\n        for drop_action in self._drop_unload_actions:\n            await self.unload_container(drop_action[0], drop_action[1])\n        for same_order in self._same_order_actions:\n            await self._give_units_same_order(\n                same_order[0], same_order[1], same_order[2]\n            )\n        for archon_morph_action in self._archon_morph_actions:\n            await self._do_archon_morph(archon_morph_action)\n        for requested_zerg_placement in self._requested_zerg_placements:\n            await self._do_zerg_build_placement(requested_zerg_placement)\n        self.manager_hub.grid_manager.reset_grids(self.actual_iteration)\n        await self.manager_hub.warp_in_manager.do_warp_ins()\n        return await super(AresBot, self)._after_step()\n\n    def register_behavior(self, behavior: Behavior) -&gt; None:\n        \"\"\"Register behavior.\n\n        Shortcut to `self.behavior_executioner.register_behavior`\n\n        Parameters\n        ----------\n        behavior : Behavior\n            Class that follows the Behavior interface.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.behavior_executioner.register_behavior(behavior)\n\n    @property\n    def mediator(self) -&gt; ManagerMediator:\n        \"\"\"Register behavior.\n\n        Shortcut to `self.manager_hub.manager_mediator`\n\n\n        Returns\n        -------\n        ManagerMediator\n\n        \"\"\"\n        return self.manager_hub.manager_mediator\n\n    async def on_end(self, game_result: Result) -&gt; None:\n        \"\"\"Output game info to the log and save data (if enabled)\n\n        Called on game end\n\n\n        Parameters\n        ----------\n        game_result : Result\n            The game result\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # TODO: Put this in a method somewhere\n        logger.info(\"END GAME REPORT\")\n        logger.info(f\"Idle worker time: {self.state.score.idle_worker_time}\")\n        logger.info(f\"Killed value units: {self.state.score.killed_value_units}\")\n        logger.info(\n            f\"Killed value structures: {self.state.score.killed_value_structures}\"\n        )\n        logger.info(f\"Collected minerals: {self.state.score.collected_minerals}\")\n        logger.info(f\"Collected vespene: {self.state.score.collected_vespene}\")\n        if self.config[USE_DATA]:\n            self.manager_hub.on_game_end(game_result)\n\n    async def on_building_construction_complete(self, unit: Unit) -&gt; None:\n        \"\"\"On structure completion event (own units)\n\n        Parameters\n        ----------\n        unit :\n            The Unit that just finished building\n\n        Returns\n        -------\n        None\n        \"\"\"\n        await self.manager_hub.on_structure_complete(unit)\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        \"\"\"On unit created event (own units)\n\n        Parameters\n        ----------\n        unit :\n            The Unit that was just created\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if (\n            not self.build_order_runner.build_completed\n            and UpgradeId.WARPGATERESEARCH in self.state.upgrades\n            and unit.type_id in GATEWAY_UNITS\n        ):\n            self.build_order_runner.set_step_started(True, unit.type_id)\n        if (\n            not self.build_order_runner.build_completed\n            and unit.type_id == UnitID.ARCHON\n        ):\n            self.build_order_runner.set_step_complete(UnitID.ARCHON)\n        await self.manager_hub.on_unit_created(unit)\n\n    async def on_unit_destroyed(self, unit_tag: int) -&gt; None:\n        \"\"\"On unit or structure destroyed event\n\n        Parameters\n        ----------\n        unit_tag :\n            The tag of the unit that was just destroyed\n\n        Returns\n        -------\n        None\n        \"\"\"\n        await self.manager_hub.on_unit_destroyed(unit_tag)\n\n    async def on_unit_took_damage(self, unit: Unit, amount_damage_taken: float) -&gt; None:\n        \"\"\"On unit or structure taking damage\n\n        Parameters\n        ----------\n        unit :\n            The Unit that took damage\n        amount_damage_taken :\n            The amount of damage the Unit took\n\n        Returns\n        -------\n        None\n        \"\"\"\n        await self.manager_hub.on_unit_took_damage(unit)\n\n    async def on_building_construction_started(self, unit: Unit) -&gt; None:\n        \"\"\"On structure starting\n\n        Parameters\n        ----------\n        unit :\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.manager_hub.on_building_started(unit)\n        self.build_order_runner.set_step_complete(unit.type_id)\n\n    def _add_enemy_unit(\n        self,\n        batteries_list: List[Unit],\n        cannons_list: List[Unit],\n        enemy_vs_ground_static_defense_list: List[Unit],\n        unit_obj: Unit,\n        update_managers: bool,\n        unit_id: UnitID,\n    ) -&gt; Tuple[List, List, List]:\n        \"\"\"Add a given enemy unit to the appropriate objects\n\n        Parameters\n        ----------\n        batteries_list :\n            Current list of enemy Shield Batteries\n        cannons_list :\n            Current list of enemy Photon Cannons\n        enemy_vs_ground_static_defense_list :\n            Current list of enemy static defense that can target ground units\n        unit_obj :\n            The Unit in question\n        update_managers :\n            Whether the Managers have been prepared\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n\n        self.all_enemy_units.append(unit_obj)\n        if unit_id in DETECTOR_RANGES:\n            self.enemy_detectors.append(unit_obj)\n        if unit_id in ALL_STRUCTURES:\n            self.enemy_structures.append(unit_obj)\n            if unit_id == UnitID.SHIELDBATTERY:\n                batteries_list.append(unit_obj)\n                if unit_obj.has_buff(BuffId.BATTERYOVERCHARGE):\n                    self.overcharged_battery = unit_obj\n            elif unit_id == UnitID.PHOTONCANNON:\n                cannons_list.append(unit_obj)\n            if unit_id in ENEMY_VS_GROUND_STATIC_DEFENSE_TYPES:\n                enemy_vs_ground_static_defense_list.append(unit_obj)\n            if update_managers:\n                self.manager_hub.grid_manager.add_structure_influence(unit_obj)\n        else:\n            self.enemy_units.append(unit_obj)\n            if BuffId.PARASITICBOMB in unit_obj.buffs:\n                self.friendly_parasitic_bomb_positions.append(unit_obj.position)\n            if unit_id in self.WORKER_TYPES:\n                self.enemy_workers.append(unit_obj)\n            if update_managers:\n                self.manager_hub.unit_cache_manager.store_enemy_unit(unit_obj)\n                self.manager_hub.unit_memory_manager.store_unit(unit_obj)\n\n        return batteries_list, cannons_list, enemy_vs_ground_static_defense_list\n\n    def _add_neutral_unit(self, unit_obj: Unit, unit_type: int):\n        \"\"\"Add a given neutral unit to the appropriate objects\n\n        Parameters\n        ----------\n        unit_obj :\n            The Unit in question\n        unit_type :\n            Integer corresponding to a value in the UnitTypeId enum\n        \"\"\"\n        # XELNAGATOWER = 149\n        if unit_type == 149:\n            self.watchtowers.append(unit_obj)\n        # mineral field enums\n        elif unit_type in mineral_ids:\n            self.mineral_field.append(unit_obj)\n            self.resources.append(unit_obj)\n        # geyser enums\n        elif unit_type in geyser_ids:\n            self.vespene_geyser.append(unit_obj)\n            self.resources.append(unit_obj)\n        # all destructable rocks\n        else:\n            if unit_type not in IGNORE_DESTRUCTABLES:\n                self.destructables.append(unit_obj)\n\n    def _add_own_unit(\n        self, unit_obj: Unit, update_managers: bool, unit_id: UnitID, tag: int\n    ):\n        \"\"\"Add a given friendly unit to the appropriate objects\n\n        Parameters\n        ----------\n        unit_obj :\n            The Unit in question\n        update_managers :\n            Whether the Managers have been prepared\n        \"\"\"\n        if tag in self._used_tumors:\n            return\n        if update_managers:\n            self.manager_hub.unit_role_manager.catch_unit(unit_obj, unit_id, tag)\n            self.manager_hub.ability_tracker_manager.catch_unit(unit_obj, unit_id, tag)\n\n        self.all_own_units.append(unit_obj)\n        # if unit_id not in self.UNIT_TYPES_NOT_IN_SLIM:\n        #     self.all_own_units_slim.append(unit_obj)\n\n        if unit_id in ALL_STRUCTURES:\n            if unit_id == UnitID.WARPGATE:\n                self.own_units_slim.append(unit_obj)\n            elif unit_id not in self.UNIT_TYPES_NOT_IN_SLIM:\n                self.own_structures_slim.append(unit_obj)\n            if unit_id == UnitTypeId.CREEPTUMORBURROWED:\n                if not unit_obj.is_idle and isinstance(unit_obj.order_target, Point2):\n                    self._used_tumors.add(tag)\n                    return\n            if update_managers:\n                self.manager_hub.unit_cache_manager.store_own_structure(unit_obj)\n            self.structures.append(unit_obj)\n            if unit_id in ADD_ONS:\n                if unit_id in TECHLAB_TYPES:\n                    self.techlab_tags.add(tag)\n                else:\n                    self.reactor_tags.add(tag)\n            elif unit_id in race_townhalls[self.race]:\n                self.townhalls.append(unit_obj)\n                if unit_obj.is_ready:\n                    self.ready_townhalls.append(unit_obj)\n            elif unit_obj.vespene_contents &gt; 0 and (\n                unit_id in ALL_GAS or unit_obj.vespene_contents\n            ):\n                # TODO: remove \"or unit_obj.vespene_contents\" when a Linux client newer\n                # than version 4.10.0 is released\n                self.gas_buildings.append(unit_obj)\n            elif unit_id in self.NYDUSES:\n                self.nyduses.append(unit_obj)\n        else:\n            if unit_id not in self.UNIT_TYPES_NOT_IN_SLIM:\n                self.own_units_slim.append(unit_obj)\n            if update_managers:\n                self.manager_hub.unit_cache_manager.store_own_unit(unit_obj, unit_id)\n\n            self.units.append(unit_obj)\n            if unit_id in self.WORKER_TYPES:\n                self.workers.append(unit_obj)\n            elif unit_id == UnitID.LARVA:\n                self.larva.append(unit_obj)\n            elif unit_id == UnitID.EGG:\n                self.eggs.append(unit_obj)\n            if BuffId.PARASITICBOMB in unit_obj.buffs:\n                self.enemy_parasitic_bomb_positions.append(unit_obj.position)\n\n    def _clear_adept_shades(self) -&gt; None:\n        \"\"\"Remove Adept shades if they've completed or otherwise vanished\n\n        Returns\n        -------\n        None\n        \"\"\"\n        current_frame: int = self.state.game_loop\n        shade_owner_tags_to_remove: List[int] = []\n        keys_to_remove: List[int] = []\n        for shade_tag, item in self.adept_shades.items():\n            frame_shade_started: int = item[SHADE_COMMENCED]\n            adept_owner: int = item[SHADE_OWNER]\n            if current_frame - frame_shade_started &gt; SHADE_DURATION:\n                keys_to_remove.append(shade_tag)\n                shade_owner_tags_to_remove.append(adept_owner)\n\n        for key in keys_to_remove:\n            if key in self.adept_shades:\n                self.adept_shades.pop(key)\n\n        for owner_tag in shade_owner_tags_to_remove:\n            if owner_tag in self.adept_tags_with_shades_assigned:\n                self.adept_tags_with_shades_assigned.remove(owner_tag)\n\n    def _record_shade(self, shade: RawUnit) -&gt; None:\n        \"\"\"Add an Adept Shade to the tracking dictionary\n\n        Parameters\n        ----------\n        shade :\n            The Adept Shade to be recorded\n\n        Returns\n        -------\n        None\n        \"\"\"\n        current_frame: int = self.state.game_loop\n        shade_tag: int = shade.tag\n        shade_position: Point2 = Point2((shade.pos.x, shade.pos.y))\n        if shade_tag not in self.adept_shades:\n            close_adepts: Units = self.manager_hub.unit_memory_manager.units_in_range(\n                [shade_position],\n                40,\n                UnitTreeQueryType.EnemyGround,\n                return_as_dict=False,\n            )[0].filter(\n                lambda u: u.tag not in self.adept_tags_with_shades_assigned\n                and u.type_id == UnitID.ADEPT\n            )\n            if close_adepts:\n                self.adept_shades[shade_tag][SHADE_OWNER] = close_adepts.closest_to(\n                    shade_position\n                ).tag\n                self.adept_shades[shade_tag][SHADE_COMMENCED] = current_frame\n                self.adept_tags_with_shades_assigned.add(close_adepts.first.tag)\n            else:\n                # we can't find an owner, assume 20% complete\n                self.adept_shades[shade_tag][SHADE_OWNER] = 0\n                self.adept_shades[shade_tag][SHADE_COMMENCED] = current_frame - 32\n\n    def _reset_managers(self) -&gt; None:\n        \"\"\"Reset managers to prepare for a new game loop.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.manager_hub.unit_cache_manager.clear_store_dicts()\n        self.manager_hub.unit_memory_manager.clear_settings()\n        self.manager_hub.unit_role_manager.get_assigned_units()\n\n    def _reset_variables(self) -&gt; None:\n        \"\"\"Reset all variables that need to be populated this loop.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # Set of enemy units detected by own sensor tower,\n        # as blips have less unit information than normal visible units\n        self.all_units: Units = Units([], self)\n        self.units: Units = Units([], self)\n        self.workers: Units = Units([], self)\n        self.larva: Units = Units([], self)\n        self.structures: Units = Units([], self)\n        self.townhalls: Units = Units([], self)\n        self.ready_townhalls: Units = Units([], self)\n        self.gas_buildings: Units = Units([], self)\n        self.all_own_units: Units = Units([], self)\n        # don't include tumors\n        self.all_own_units_slim: Units = Units([], self)\n        self.own_units_slim: Units = Units([], self)\n        self.own_structures_slim: Units = Units([], self)\n        self.enemy_units: Units = Units([], self)\n        self.enemy_structures: Units = Units([], self)\n        self.enemy_workers: Units = Units([], self)\n        self.all_enemy_units: Units = Units([], self)\n        self.resources: Units = Units([], self)\n        self.destructables: Units = Units([], self)\n        self.watchtowers: Units = Units([], self)\n        self.mineral_field: Units = Units([], self)\n        self.vespene_geyser: Units = Units([], self)\n        self.placeholders: Units = Units([], self)\n\n        # some custom stuff\n        self.all_gas_buildings = Units([], self)\n        self.eggs: Units = Units([], self)\n        self.unit_tag_dict = {}\n        self.overcharged_battery: Optional[Unit] = None\n        self.nyduses = Units([], self)\n        self.enemy_detectors: List[Unit] = []\n        self.enemy_vs_ground_static_defense: Units = Units([], self)\n        self.friendly_parasitic_bomb_positions: List[Point2] = []\n        self.enemy_parasitic_bomb_positions: List[Point2] = []\n\n        self._drop_unload_actions = []\n        self._same_order_actions = []\n        self._archon_morph_actions = []\n        self._requested_zerg_placements = []\n        self.transfused_tags = set()\n\n    def _should_add_unit(self, unit: RawUnit) -&gt; bool:\n        \"\"\"Whether the given unit should be tracked.\n\n        This will always return True unless the unit is an Adept Shade, in which\n        case whether it's added is based on frame counts.\n\n        Parameters\n        ----------\n        unit :\n            The unit in question\n\n        Returns\n        -------\n        bool :\n            True if the unit should be recorded, False otherwise\n        \"\"\"\n        if unit.unit_type == UnitID.ADEPTPHASESHIFT.value:\n            if unit.tag not in self.adept_shades:\n                self._record_shade(unit)\n\n            frame_shade_commenced: int = self.adept_shades[unit.tag][SHADE_COMMENCED]\n            frame_difference: int = self.state.game_loop - frame_shade_commenced\n\n            return frame_difference &gt;= ADD_SHADES_ON_FRAME\n\n        return True\n\n    def _update_memory_units(self, index: int):\n        \"\"\"Go through memory units and add them to all_units.\n\n        Parameters\n        ----------\n        index :\n            Current distance calculation index\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.manager_hub.unit_cache_manager.update_enemy_army()\n\n        for unit in self.manager_hub.unit_memory_manager.ghost_units.tags_not_in(\n            self.all_units.tags\n        ):\n            unit.distance_calculation_index = index\n            self.all_units.append(unit)\n            self.unit_tag_dict[unit.tag] = unit\n            index += 1\n\n    def get_build_structures(\n        self,\n        structure_unit_types: set[UnitID],\n        unit_type: UnitID,\n        build_dict=None,\n        ignored_build_from_tags=None,\n    ) -&gt; list[Unit]:\n        \"\"\"Get all structures (or units) where we can spawn unit_type.\n        Takes into account techlabs and reactors. And Gateway / warp gate\n\n\n        Parameters\n        ----------\n        structure_unit_types :\n            The valid build structures we can spawn this unit_type from.\n        unit_type :\n            The target unit we are trying to spawn.\n        build_dict : dict[Unit, UnitID] (optional)\n            Use to prevent selecting idle build structures that\n            have already got a pending order this frame.\n            Key: Unit that should get order, value: what UnitID to build\n        ignored_build_from_tags : Set[int]\n            Pass in if you don't want certain build structures selected.\n\n        Returns\n        -------\n        list[Unit] :\n            List of structures / units where this unit could possibly be spawned from.\n        \"\"\"\n        if ignored_build_from_tags is None:\n            ignored_build_from_tags = {}\n        if build_dict is None:\n            build_dict = {}\n\n        structures_dict: dict[UnitID:Units] = self.mediator.get_own_structures_dict\n        own_army_dict: dict[UnitID:Units] = self.mediator.get_own_army_dict\n        build_from_dict: dict[UnitID:Units] = structures_dict\n        if self.race != Race.Terran:\n            build_from_dict: dict[UnitID:Units] = {\n                **structures_dict,\n                **own_army_dict,\n            }\n        build_from_tags: list[int] = []\n        using_larva: bool = False\n        for structure_type in structure_unit_types:\n            if structure_type not in build_from_dict:\n                continue\n\n            if structure_type == UnitID.LARVA:\n                using_larva = True\n\n            build_from: Union[Units, list[Unit]] = build_from_dict[structure_type]\n            # only add if warpgate is off cooldown\n            if structure_type == UnitID.WARPGATE:\n                build_from = [\n                    b\n                    for b in build_from\n                    if AbilityId.WARPGATETRAIN_ZEALOT in b.abilities\n                ]\n\n            requires_techlab: bool = self.race == Race.Terran and TRAIN_INFO[\n                structure_type\n            ][unit_type].get(\"requires_techlab\", False)\n            if not requires_techlab:\n                build_from_tags.extend(\n                    [\n                        u.tag\n                        for u in build_from\n                        if u.is_ready and u.is_idle and u not in build_dict\n                    ]\n                )\n                if self.race == Race.Terran:\n                    build_from_tags.extend(\n                        u.tag\n                        for u in build_from\n                        if u.is_ready\n                        and u.has_reactor\n                        and len(u.orders) &lt; 2\n                        and u not in build_dict\n                    )\n            else:\n                build_from_tags.extend(\n                    [\n                        u.tag\n                        for u in build_from\n                        if u.is_ready\n                        and u.is_idle\n                        and u.has_add_on\n                        and self.unit_tag_dict[u.add_on_tag].is_ready\n                        and u.add_on_tag in self.techlab_tags\n                        and u not in build_dict\n                    ]\n                )\n\n        build_structures: list[Unit] = [self.unit_tag_dict[u] for u in build_from_tags]\n        # sort build structures with reactors first\n        if self.race == Race.Terran:\n\n            def structure_priority(structure):\n                if structure.add_on_tag in self.reactor_tags:\n                    return -1\n                elif structure.add_on_tag in self.techlab_tags:\n                    return 1\n                return 0\n\n            def is_reactor_ready(structure):\n                return any(\n                    ability in structure.abilities\n                    for ability in REACTOR_TRAIN_ABILITIES\n                )\n\n            # Sort by add-on type\n            build_structures.sort(key=structure_priority)\n\n            # Filter out reactors that aren't ready\n            build_structures = [\n                bs\n                for bs in build_structures\n                if bs.add_on_tag not in self.reactor_tags or is_reactor_ready(bs)\n            ]\n        # limit build structures to number of larva left\n        if self.race == Race.Zerg and using_larva:\n            build_structures = build_structures[: self.num_larva_left]\n        # limit to powered structures\n        if self.race == Race.Protoss:\n            build_structures = [\n                s\n                for s in build_structures\n                if s.is_powered\n                or s.type_id in {UnitID.NEXUS, UnitID.DARKTEMPLAR, UnitID.HIGHTEMPLAR}\n            ]\n\n        return build_structures\n\n    def structure_present_or_pending(self, structure_type: UnitID) -&gt; bool:\n        \"\"\"\n        Checks presence of a structure, or if worker is on route to\n        build structure.\n\n        Parameters\n        ----------\n        structure_type\n\n        Returns\n        -------\n        bool\n\n        \"\"\"\n        return (\n            len(self.mediator.get_own_structures_dict[structure_type]) &gt; 0\n            or self.mediator.get_building_counter[structure_type] &gt; 0\n        )\n\n    def unit_pending(self, unit_type: UnitID) -&gt; int:\n        \"\"\"\n        Checks pending units.\n        Alternative and faster version of `self.already_pending`\n\n        Parameters\n        ----------\n        unit_type\n\n        Returns\n        -------\n        int\n\n        \"\"\"\n        return cy_unit_pending(self, unit_type)\n\n    def structure_pending(self, structure_type: UnitID) -&gt; int:\n        \"\"\"\n        Checks pending structures, includes workers on route.\n        Alternative and faster version of `self.already_pending`\n\n        Parameters\n        ----------\n        structure_type\n\n        Returns\n        -------\n        int\n\n        \"\"\"\n        num_pending: int = 0\n        building_tracker: dict = self.mediator.get_building_tracker_dict\n        for tag, info in building_tracker.items():\n            structure_id: UnitID = building_tracker[tag][ID]\n            if structure_id != structure_type:\n                continue\n\n            num_pending += 1\n\n        if self.race != Race.Terran or structure_type in ADD_ONS:\n            num_pending += len(\n                [\n                    s\n                    for s in self.mediator.get_own_structures_dict[structure_type]\n                    if s.build_progress &lt; 1.0\n                ]\n            )\n\n        return num_pending\n\n    async def _do_zerg_build_placement(\n        self, requested_zerg_placement: tuple[Point2, UnitID]\n    ) -&gt; None:\n        base_location: Point2 = requested_zerg_placement[0]\n        unit_type: UnitID = requested_zerg_placement[1]\n\n        if pos := await self.find_placement(\n            unit_type,\n            base_location.towards(self.game_info.map_center, 8.0),\n            30,\n        ):\n            if worker := self.mediator.select_worker(\n                target_position=pos,\n                force_close=True,\n            ):\n                self.mediator.build_with_specific_worker(\n                    worker=worker,\n                    structure_type=unit_type,\n                    pos=pos,\n                )\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.mediator","title":"<code>mediator</code>  <code>property</code>","text":"<p>Register behavior.</p> <p>Shortcut to <code>self.manager_hub.manager_mediator</code></p>"},{"location":"api_reference/index.html#ares.main.AresBot.mediator--returns","title":"Returns","text":"<p>ManagerMediator</p>"},{"location":"api_reference/index.html#ares.main.AresBot.__init__","title":"<code>__init__(game_step_override=None)</code>","text":"<p>Load config and set up necessary attributes.</p>"},{"location":"api_reference/index.html#ares.main.AresBot.__init__--parameters","title":"Parameters","text":"<p>game_step_override :     If provided, set the game_step to this value regardless of how it was     specified elsewhere</p> Source code in <code>src/ares/main.py</code> <pre><code>def __init__(self, game_step_override: Optional[int] = None):  # pragma: no cover\n    \"\"\"Load config and set up necessary attributes.\n\n    Parameters\n    ----------\n    game_step_override :\n        If provided, set the game_step to this value regardless of how it was\n        specified elsewhere\n    \"\"\"\n    super().__init__()\n    # otherwise we use the config.yml file\n    __ares_config_location__: str = path.realpath(\n        path.join(getcwd(), path.dirname(__file__))\n    )\n    # If running from exe we need path to exe file\n    if getattr(sys, \"frozen\", False):\n        # Running as PyInstaller exe\n        # sys.executable = \"C:/Users/name/Desktop/mybot.exe\"\n        # path.dirname() gives \"C:/Users/name/Desktop\"\n        self.__user_config_location__ = path.dirname(sys.executable)\n    # Running from source code\n    else:\n        # path.abspath(\".\") gives current directory\n        self.__user_config_location__ = path.abspath(\".\")\n\n    config_parser: ConfigParser = ConfigParser(\n        __ares_config_location__, self.__user_config_location__, CONFIG_FILE\n    )\n\n    self.config = config_parser.parse()\n\n    self.game_step_override: Optional[int] = game_step_override\n    self.unit_tag_dict: dict[int, Unit] = {}\n    self.chat_debug = None\n    self.forcefield_to_bile_dict: dict[Point2, int] = {}\n    self.last_game_loop: int = -1\n\n    # track adept shades as we only add them towards shade completion (160 frames)\n    # Key: tag of shade Value: frame shade commenced (+32 if no adept owner found)\n    self.adept_shades: DefaultDict[int, Dict] = defaultdict(dict)\n    self.adept_tags_with_shades_assigned: Set[int] = set()\n    # we skip python-sc2 iterations in realtime, so we keep track of our own one\n    self.actual_iteration: int = 0\n    self.WORKER_TYPES = WORKER_TYPES | {UnitID.DRONEBURROWED}\n    self.supply_type: UnitID = UnitID.OVERLORD\n    self.num_larva_left: int = 0\n\n    self._same_order_actions: list[\n        tuple[AbilityId, set[int], Optional[Union[Unit, Point2]]]\n    ] = []\n    self._drop_unload_actions: list[tuple[int, int]] = []\n    self._archon_morph_actions: list[list] = []\n    self._requested_zerg_placements: list[tuple] = []\n    self.transfused_tags: set[int] = set()\n\n    self.arcade_mode: bool = False\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.get_build_structures","title":"<code>get_build_structures(structure_unit_types, unit_type, build_dict=None, ignored_build_from_tags=None)</code>","text":"<p>Get all structures (or units) where we can spawn unit_type. Takes into account techlabs and reactors. And Gateway / warp gate</p>"},{"location":"api_reference/index.html#ares.main.AresBot.get_build_structures--parameters","title":"Parameters","text":"<p>structure_unit_types :     The valid build structures we can spawn this unit_type from. unit_type :     The target unit we are trying to spawn. build_dict : dict[Unit, UnitID] (optional)     Use to prevent selecting idle build structures that     have already got a pending order this frame.     Key: Unit that should get order, value: what UnitID to build ignored_build_from_tags : Set[int]     Pass in if you don't want certain build structures selected.</p>"},{"location":"api_reference/index.html#ares.main.AresBot.get_build_structures--returns","title":"Returns","text":"<p>list[Unit] :     List of structures / units where this unit could possibly be spawned from.</p> Source code in <code>src/ares/main.py</code> <pre><code>def get_build_structures(\n    self,\n    structure_unit_types: set[UnitID],\n    unit_type: UnitID,\n    build_dict=None,\n    ignored_build_from_tags=None,\n) -&gt; list[Unit]:\n    \"\"\"Get all structures (or units) where we can spawn unit_type.\n    Takes into account techlabs and reactors. And Gateway / warp gate\n\n\n    Parameters\n    ----------\n    structure_unit_types :\n        The valid build structures we can spawn this unit_type from.\n    unit_type :\n        The target unit we are trying to spawn.\n    build_dict : dict[Unit, UnitID] (optional)\n        Use to prevent selecting idle build structures that\n        have already got a pending order this frame.\n        Key: Unit that should get order, value: what UnitID to build\n    ignored_build_from_tags : Set[int]\n        Pass in if you don't want certain build structures selected.\n\n    Returns\n    -------\n    list[Unit] :\n        List of structures / units where this unit could possibly be spawned from.\n    \"\"\"\n    if ignored_build_from_tags is None:\n        ignored_build_from_tags = {}\n    if build_dict is None:\n        build_dict = {}\n\n    structures_dict: dict[UnitID:Units] = self.mediator.get_own_structures_dict\n    own_army_dict: dict[UnitID:Units] = self.mediator.get_own_army_dict\n    build_from_dict: dict[UnitID:Units] = structures_dict\n    if self.race != Race.Terran:\n        build_from_dict: dict[UnitID:Units] = {\n            **structures_dict,\n            **own_army_dict,\n        }\n    build_from_tags: list[int] = []\n    using_larva: bool = False\n    for structure_type in structure_unit_types:\n        if structure_type not in build_from_dict:\n            continue\n\n        if structure_type == UnitID.LARVA:\n            using_larva = True\n\n        build_from: Union[Units, list[Unit]] = build_from_dict[structure_type]\n        # only add if warpgate is off cooldown\n        if structure_type == UnitID.WARPGATE:\n            build_from = [\n                b\n                for b in build_from\n                if AbilityId.WARPGATETRAIN_ZEALOT in b.abilities\n            ]\n\n        requires_techlab: bool = self.race == Race.Terran and TRAIN_INFO[\n            structure_type\n        ][unit_type].get(\"requires_techlab\", False)\n        if not requires_techlab:\n            build_from_tags.extend(\n                [\n                    u.tag\n                    for u in build_from\n                    if u.is_ready and u.is_idle and u not in build_dict\n                ]\n            )\n            if self.race == Race.Terran:\n                build_from_tags.extend(\n                    u.tag\n                    for u in build_from\n                    if u.is_ready\n                    and u.has_reactor\n                    and len(u.orders) &lt; 2\n                    and u not in build_dict\n                )\n        else:\n            build_from_tags.extend(\n                [\n                    u.tag\n                    for u in build_from\n                    if u.is_ready\n                    and u.is_idle\n                    and u.has_add_on\n                    and self.unit_tag_dict[u.add_on_tag].is_ready\n                    and u.add_on_tag in self.techlab_tags\n                    and u not in build_dict\n                ]\n            )\n\n    build_structures: list[Unit] = [self.unit_tag_dict[u] for u in build_from_tags]\n    # sort build structures with reactors first\n    if self.race == Race.Terran:\n\n        def structure_priority(structure):\n            if structure.add_on_tag in self.reactor_tags:\n                return -1\n            elif structure.add_on_tag in self.techlab_tags:\n                return 1\n            return 0\n\n        def is_reactor_ready(structure):\n            return any(\n                ability in structure.abilities\n                for ability in REACTOR_TRAIN_ABILITIES\n            )\n\n        # Sort by add-on type\n        build_structures.sort(key=structure_priority)\n\n        # Filter out reactors that aren't ready\n        build_structures = [\n            bs\n            for bs in build_structures\n            if bs.add_on_tag not in self.reactor_tags or is_reactor_ready(bs)\n        ]\n    # limit build structures to number of larva left\n    if self.race == Race.Zerg and using_larva:\n        build_structures = build_structures[: self.num_larva_left]\n    # limit to powered structures\n    if self.race == Race.Protoss:\n        build_structures = [\n            s\n            for s in build_structures\n            if s.is_powered\n            or s.type_id in {UnitID.NEXUS, UnitID.DARKTEMPLAR, UnitID.HIGHTEMPLAR}\n        ]\n\n    return build_structures\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_before_start","title":"<code>on_before_start()</code>  <code>async</code>","text":"<p>Train a drone and split workers before managers are set up</p> <p>Called before bot properly initializes</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_before_start--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_before_start(self) -&gt; None:  # pragma: no cover\n    \"\"\"Train a drone and split workers before managers are set up\n\n    Called before bot properly initializes\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # optional build order config from a user, add to the existing config dictionary\n    __user_build_orders_location__: str = path.join(\n        self.__user_config_location__, f\"{self.race.name.lower()}_builds.yml\"\n    )\n    if path.isfile(__user_build_orders_location__):\n        with open(__user_build_orders_location__, \"r\") as config_file:\n            build_order_config: dict = yaml.safe_load(config_file)\n            self.config.update(build_order_config)\n\n    self.gas_type = race_gas[self.race]\n    self.worker_type = race_worker[self.race]\n    self.supply_type = RACE_SUPPLY[self.race]\n    if self.race != Race.Zerg:\n        self.base_townhall_type = (\n            UnitID.COMMANDCENTER if self.race == Race.Terran else UnitID.NEXUS\n        )\n    else:\n        self.base_townhall_type = UnitID.HATCHERY\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_building_construction_complete","title":"<code>on_building_construction_complete(unit)</code>  <code>async</code>","text":"<p>On structure completion event (own units)</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_building_construction_complete--parameters","title":"Parameters","text":"<p>unit :     The Unit that just finished building</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_building_construction_complete--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_building_construction_complete(self, unit: Unit) -&gt; None:\n    \"\"\"On structure completion event (own units)\n\n    Parameters\n    ----------\n    unit :\n        The Unit that just finished building\n\n    Returns\n    -------\n    None\n    \"\"\"\n    await self.manager_hub.on_structure_complete(unit)\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_building_construction_started","title":"<code>on_building_construction_started(unit)</code>  <code>async</code>","text":"<p>On structure starting</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_building_construction_started--parameters","title":"Parameters","text":"<p>unit :</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_building_construction_started--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_building_construction_started(self, unit: Unit) -&gt; None:\n    \"\"\"On structure starting\n\n    Parameters\n    ----------\n    unit :\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.manager_hub.on_building_started(unit)\n    self.build_order_runner.set_step_complete(unit.type_id)\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_end","title":"<code>on_end(game_result)</code>  <code>async</code>","text":"<p>Output game info to the log and save data (if enabled)</p> <p>Called on game end</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_end--parameters","title":"Parameters","text":"<p>game_result : Result     The game result</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_end--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_end(self, game_result: Result) -&gt; None:\n    \"\"\"Output game info to the log and save data (if enabled)\n\n    Called on game end\n\n\n    Parameters\n    ----------\n    game_result : Result\n        The game result\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # TODO: Put this in a method somewhere\n    logger.info(\"END GAME REPORT\")\n    logger.info(f\"Idle worker time: {self.state.score.idle_worker_time}\")\n    logger.info(f\"Killed value units: {self.state.score.killed_value_units}\")\n    logger.info(\n        f\"Killed value structures: {self.state.score.killed_value_structures}\"\n    )\n    logger.info(f\"Collected minerals: {self.state.score.collected_minerals}\")\n    logger.info(f\"Collected vespene: {self.state.score.collected_vespene}\")\n    if self.config[USE_DATA]:\n        self.manager_hub.on_game_end(game_result)\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_start","title":"<code>on_start()</code>  <code>async</code>","text":"<p>Set up game step, managers, and information that requires game data</p> <p>Called just before the first step, all game info is available</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_start--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_start(self) -&gt; None:  # pragma: no cover\n    \"\"\"Set up game step, managers, and information that requires game data\n\n    Called just before the first step, all game info is available\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # manually skip the frames in realtime\n    if self.realtime:\n        self.client.game_step = 1\n    elif self.game_step_override:\n        self.client.game_step = self.game_step_override\n    else:\n        # set the game step from config\n        self.client.game_step = (\n            self.config[GAME_STEP]\n            if not self.config[DEBUG]\n            else self.config[DEBUG_GAME_STEP]\n        )\n\n    if not self.enemy_start_locations or not self.townhalls:\n        self.arcade_mode = True\n\n    self.register_managers()\n\n    self.build_order_runner: BuildOrderRunner = BuildOrderRunner(\n        self,\n        self.manager_hub.data_manager.chosen_opening,\n        self.config,\n        self.manager_hub.manager_mediator,\n    )\n    self.behavior_executioner: BehaviorExecutioner = BehaviorExecutioner(\n        self, self.config, self.manager_hub.manager_mediator\n    )\n\n    if self.config[DEBUG] and self.config[DEBUG_OPTIONS][CHAT_DEBUG]:\n        from ares.chat_debug import ChatDebug\n\n        self.chat_debug = ChatDebug(self)\n\n    self.cost_dict: Dict[UnitID, Cost] = COST_DICT\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_step","title":"<code>on_step(iteration)</code>  <code>async</code>","text":"<p>Play the game</p> <p>Called on every game step</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_step--parameters","title":"Parameters","text":"<p>iteration : int     The current game iteration</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_step--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_step(self, iteration: int) -&gt; None:  # pragma: no cover\n    \"\"\"Play the game\n\n    Called on every game step\n\n    Parameters\n    ----------\n    iteration : int\n        The current game iteration\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    await self.manager_hub.update_managers(self.actual_iteration)\n    if not self.build_order_runner.build_completed:\n        await self.build_order_runner.run_build()\n\n    # detect scouts used by the build runner that are finished\n    if self.time &lt; 390.0:\n        if scouts := [\n            w\n            for w in self.mediator.get_units_from_role(\n                role=UnitRole.BUILD_RUNNER_SCOUT, unit_type=WORKER_TYPES\n            )\n            if w.is_idle\n        ]:\n            for scout in scouts:\n                self.mediator.assign_role(tag=scout.tag, role=UnitRole.GATHERING)\n\n    self.actual_iteration += 1\n    if self.chat_debug:\n        # trunk-ignore(mypy/unreachable)\n        await self.chat_debug.parse_commands()\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_created","title":"<code>on_unit_created(unit)</code>  <code>async</code>","text":"<p>On unit created event (own units)</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_created--parameters","title":"Parameters","text":"<p>unit :     The Unit that was just created</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_created--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_unit_created(self, unit: Unit) -&gt; None:\n    \"\"\"On unit created event (own units)\n\n    Parameters\n    ----------\n    unit :\n        The Unit that was just created\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if (\n        not self.build_order_runner.build_completed\n        and UpgradeId.WARPGATERESEARCH in self.state.upgrades\n        and unit.type_id in GATEWAY_UNITS\n    ):\n        self.build_order_runner.set_step_started(True, unit.type_id)\n    if (\n        not self.build_order_runner.build_completed\n        and unit.type_id == UnitID.ARCHON\n    ):\n        self.build_order_runner.set_step_complete(UnitID.ARCHON)\n    await self.manager_hub.on_unit_created(unit)\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_destroyed","title":"<code>on_unit_destroyed(unit_tag)</code>  <code>async</code>","text":"<p>On unit or structure destroyed event</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_destroyed--parameters","title":"Parameters","text":"<p>unit_tag :     The tag of the unit that was just destroyed</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_destroyed--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_unit_destroyed(self, unit_tag: int) -&gt; None:\n    \"\"\"On unit or structure destroyed event\n\n    Parameters\n    ----------\n    unit_tag :\n        The tag of the unit that was just destroyed\n\n    Returns\n    -------\n    None\n    \"\"\"\n    await self.manager_hub.on_unit_destroyed(unit_tag)\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_took_damage","title":"<code>on_unit_took_damage(unit, amount_damage_taken)</code>  <code>async</code>","text":"<p>On unit or structure taking damage</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_took_damage--parameters","title":"Parameters","text":"<p>unit :     The Unit that took damage amount_damage_taken :     The amount of damage the Unit took</p>"},{"location":"api_reference/index.html#ares.main.AresBot.on_unit_took_damage--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>async def on_unit_took_damage(self, unit: Unit, amount_damage_taken: float) -&gt; None:\n    \"\"\"On unit or structure taking damage\n\n    Parameters\n    ----------\n    unit :\n        The Unit that took damage\n    amount_damage_taken :\n        The amount of damage the Unit took\n\n    Returns\n    -------\n    None\n    \"\"\"\n    await self.manager_hub.on_unit_took_damage(unit)\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.register_behavior","title":"<code>register_behavior(behavior)</code>","text":"<p>Register behavior.</p> <p>Shortcut to <code>self.behavior_executioner.register_behavior</code></p>"},{"location":"api_reference/index.html#ares.main.AresBot.register_behavior--parameters","title":"Parameters","text":"<p>behavior : Behavior     Class that follows the Behavior interface.</p>"},{"location":"api_reference/index.html#ares.main.AresBot.register_behavior--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>def register_behavior(self, behavior: Behavior) -&gt; None:\n    \"\"\"Register behavior.\n\n    Shortcut to `self.behavior_executioner.register_behavior`\n\n    Parameters\n    ----------\n    behavior : Behavior\n        Class that follows the Behavior interface.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.behavior_executioner.register_behavior(behavior)\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.register_managers","title":"<code>register_managers()</code>","text":"<p>Register standard and custom managers.</p> <p>Override in your bot class if you wish to use custom managers.</p>"},{"location":"api_reference/index.html#ares.main.AresBot.register_managers--examples","title":"Examples","text":"<p>custom_production_manager = CustomProductionManager(     self, self.config, manager_mediator ) new_manager = NewManager(self, self.config, manager_mediator)</p> <p>self.manager_hub = Hub(     self,     self.config,     manager_mediator,     production_manager=custom_production_manager,     additional_managers=[new_manager], )</p>"},{"location":"api_reference/index.html#ares.main.AresBot.register_managers--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/ares/main.py</code> <pre><code>def register_managers(self) -&gt; None:\n    \"\"\"Register standard and custom managers.\n\n    Override in your bot class if you wish to use custom managers.\n\n    Examples\n    --------\n    custom_production_manager = CustomProductionManager(\n        self, self.config, manager_mediator\n    )\n    new_manager = NewManager(self, self.config, manager_mediator)\n\n    self.manager_hub = Hub(\n        self,\n        self.config,\n        manager_mediator,\n        production_manager=custom_production_manager,\n        additional_managers=[new_manager],\n    )\n\n    Returns\n    -------\n    None\n    \"\"\"\n    manager_mediator: ManagerMediator = ManagerMediator()\n    self.manager_hub = Hub(self, self.config, manager_mediator)\n    self.manager_hub.init_managers()\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.structure_pending","title":"<code>structure_pending(structure_type)</code>","text":"<p>Checks pending structures, includes workers on route. Alternative and faster version of <code>self.already_pending</code></p>"},{"location":"api_reference/index.html#ares.main.AresBot.structure_pending--parameters","title":"Parameters","text":"<p>structure_type</p>"},{"location":"api_reference/index.html#ares.main.AresBot.structure_pending--returns","title":"Returns","text":"<p>int</p> Source code in <code>src/ares/main.py</code> <pre><code>def structure_pending(self, structure_type: UnitID) -&gt; int:\n    \"\"\"\n    Checks pending structures, includes workers on route.\n    Alternative and faster version of `self.already_pending`\n\n    Parameters\n    ----------\n    structure_type\n\n    Returns\n    -------\n    int\n\n    \"\"\"\n    num_pending: int = 0\n    building_tracker: dict = self.mediator.get_building_tracker_dict\n    for tag, info in building_tracker.items():\n        structure_id: UnitID = building_tracker[tag][ID]\n        if structure_id != structure_type:\n            continue\n\n        num_pending += 1\n\n    if self.race != Race.Terran or structure_type in ADD_ONS:\n        num_pending += len(\n            [\n                s\n                for s in self.mediator.get_own_structures_dict[structure_type]\n                if s.build_progress &lt; 1.0\n            ]\n        )\n\n    return num_pending\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.structure_present_or_pending","title":"<code>structure_present_or_pending(structure_type)</code>","text":"<p>Checks presence of a structure, or if worker is on route to build structure.</p>"},{"location":"api_reference/index.html#ares.main.AresBot.structure_present_or_pending--parameters","title":"Parameters","text":"<p>structure_type</p>"},{"location":"api_reference/index.html#ares.main.AresBot.structure_present_or_pending--returns","title":"Returns","text":"<p>bool</p> Source code in <code>src/ares/main.py</code> <pre><code>def structure_present_or_pending(self, structure_type: UnitID) -&gt; bool:\n    \"\"\"\n    Checks presence of a structure, or if worker is on route to\n    build structure.\n\n    Parameters\n    ----------\n    structure_type\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n    return (\n        len(self.mediator.get_own_structures_dict[structure_type]) &gt; 0\n        or self.mediator.get_building_counter[structure_type] &gt; 0\n    )\n</code></pre>"},{"location":"api_reference/index.html#ares.main.AresBot.unit_pending","title":"<code>unit_pending(unit_type)</code>","text":"<p>Checks pending units. Alternative and faster version of <code>self.already_pending</code></p>"},{"location":"api_reference/index.html#ares.main.AresBot.unit_pending--parameters","title":"Parameters","text":"<p>unit_type</p>"},{"location":"api_reference/index.html#ares.main.AresBot.unit_pending--returns","title":"Returns","text":"<p>int</p> Source code in <code>src/ares/main.py</code> <pre><code>def unit_pending(self, unit_type: UnitID) -&gt; int:\n    \"\"\"\n    Checks pending units.\n    Alternative and faster version of `self.already_pending`\n\n    Parameters\n    ----------\n    unit_type\n\n    Returns\n    -------\n    int\n\n    \"\"\"\n    return cy_unit_pending(self, unit_type)\n</code></pre>"},{"location":"api_reference/manager_mediator.html","title":"Manager mediator","text":"<p>To enable communication between managers in ares-sc2, the mediator pattern is used internally. If you need to request  information or perform an action from a manager, it is strongly recommended that you do so through the mediator,  which can be accessed via <code>self.mediator</code>. For example:</p> <pre><code>ground_grid: np.ndarray = self.mediator.get_ground_grid\n</code></pre> <p>Mediator concrete class is the single source of truth and coordinator of communications between the managers.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>class ManagerMediator(IManagerMediator):\n    \"\"\"\n    Mediator concrete class is the single source of truth and coordinator of\n    communications between the managers.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.managers: Dict[str, \"Manager\"] = {}  # noqa\n\n    def add_managers(self, managers: list[\"Manager\"]) -&gt; None:  # noqa\n        \"\"\"Generate manager dictionary.\n\n        Parameters:\n            managers: List of all Managers capable of handling ManagerRequests.\n        \"\"\"\n        for manager in managers:\n            self.managers[str(type(manager).__name__)] = manager\n\n    def manager_request(\n        self,\n        receiver: ManagerName,\n        request: ManagerRequestType,\n        reason: str = None,\n        **kwargs,\n    ) -&gt; Any:\n        \"\"\"Function to request information from a manager.\n\n        Parameters:\n            receiver: Manager receiving the request.\n            request: Requested attribute/function call.\n            reason: Why the request is being made.\n            kwargs: Keyword arguments (if any) to be passed to the requested function.\n\n        Returns:\n            Any: There are too many possible return types to list all of them.\n\n\n        \"\"\"\n        return self.managers[receiver.value].manager_request(\n            receiver, request, reason, **kwargs\n        )\n\n    \"\"\"\n    Add methods and properties below for commonly used manager requests or for\n    readability in other classes\n    Format: properties in alphabetical order followed by methods in alphabetical order\n    Basically, this can act as an API front end for accessing the managers\n    Or eventually requesting the managers calculate something (like a new attack target)\n\n    `manager_request` can also be used\n    \"\"\"\n\n    \"\"\"\n    AbilityTrackerManager\n    \"\"\"\n\n    @property\n    def get_unit_to_ability_dict(self) -&gt; dict[int, Any]:\n        \"\"\"Get a dictionary containing unit tag, to ability frame cooldowns.\n\n        AbilityTrackerManager.\n\n        Returns:\n            Unit tag to abilities and the next frame they can be casted.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.ABILITY_TRACKER_MANAGER,\n            ManagerRequestType.GET_UNIT_TO_ABILITY_DICT,\n        )\n\n    def update_unit_to_ability_dict(self, **kwargs) -&gt; None:\n        \"\"\"Update tracking to reflect ability usage.\n\n        After a unit uses an ability it should call this to update the frame the\n        ability will next be available\n\n        AbilityTrackerManager.\n\n        Parameters:\n            ability (AbilityId): The AbilityId that was used.\n            unit_tag (int): The tag of the Unit that used the ability.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.ABILITY_TRACKER_MANAGER,\n            ManagerRequestType.UPDATE_UNIT_TO_ABILITY_DICT,\n            **kwargs,\n        )\n\n    \"\"\"\n    BuildingManager\n    \"\"\"\n\n    def build_with_specific_worker(self, **kwargs) -&gt; bool:\n        \"\"\"Build a structure with a specific worker.\n\n        BuildingManager.\n\n        Parameters:\n            worker (Unit): The chosen worker.\n            structure_type (UnitTypeId): What type of structure to build.\n            pos (Point2): Where the structure should be placed.\n            building_purpose (BuildingPurpose): Why the structure is being placed.\n\n        Returns:\n            bool: True if a position for the building is found and\n            the worker is valid, otherwise False.\n\n\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.BUILDING_MANAGER,\n            ManagerRequestType.BUILD_WITH_SPECIFIC_WORKER,\n            **kwargs,\n        )\n\n    def cancel_structure(self, **kwargs) -&gt; None:\n        \"\"\"Cancel a structure and remove from internal ares bookkeeping.\n\n        If you try cancelling without calling this method, ares may try\n        to keep rebuilding the cancelled structure.\n\n        BuildingManager.\n\n        Parameters:\n            structure (Unit): The actual structure to cancel.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.BUILDING_MANAGER,\n            ManagerRequestType.CANCEL_STRUCTURE,\n            **kwargs,\n        )\n\n    @property\n    def get_building_counter(self) -&gt; DefaultDict[UnitID, int]:\n        \"\"\"Get a dictionary containing the number of each type of building in progress.\n\n        BuildingManager.\n\n        Returns:\n            DefaultDict[UnitTypeId, int]:\n                Number of each type of UnitTypeId\n                currently being tracked for building.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.BUILDING_MANAGER, ManagerRequestType.GET_BUILDING_COUNTER\n        )\n\n    @property\n    def get_building_tracker_dict(\n        self,\n    ) -&gt; dict[int, dict[str, Union[Point2, Unit, UnitID, float]]]:\n        \"\"\"Get the building tracker dictionary.\n\n        Building Manager.\n\n        Returns:\n            dict[int, dict[str, Union[Point2, Unit, UnitTypeId, float]]]:\n                Tracks the worker tag to details such as the UnitTypeId of the\n                building, the Point2 location for placement, the in-game\n                time when the order started, and the purpose of the building.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.BUILDING_MANAGER, ManagerRequestType.GET_BUILDING_TRACKER_DICT\n        )\n\n    \"\"\"\n    CombatSimManager\n    \"\"\"\n\n    def can_win_fight(self, **kwargs) -&gt; EngagementResult:\n        \"\"\"Get the predicted engagement result between two forces.\n\n        Combat Sim Manager.\n\n        Parameters:\n            own_units (Units): Our units involved in the battle.\n            enemy_units (Units): The enemy units.\n            timing_adjust (bool): Whether to consider the distance between units.\n            good_positioning (bool): Whether to assume units are decently split.\n            workers_do_no_damage (bool): Whether to ignore workers' damage.\n\n        Returns:\n            Enum indicating the human-readable engagement result.\n\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.COMBAT_SIM_MANAGER, ManagerRequestType.CAN_WIN_FIGHT, **kwargs\n        )\n\n    \"\"\"\n    CreepManager\n    \"\"\"\n\n    def find_nearby_creep_edge_position(self, **kwargs) -&gt; Point2 | None:\n        \"\"\"\n        Find the nearest position on the edge of the creep nearby a given point.\n\n        This function is used to determine a position that lies at the edge of the\n        creep, in proximity to a reference point within a game map scenario. The edge\n        of the creep refers to the boundary or border of an area covered by creep,\n        a terrain-modifying biome commonly associated with certain game mechanics.\n\n        Parameters\n        ----------\n        position : Point2\n            Where to search from\n        search_radius: float\n            How far to search for creep edge position.\n        closest_valid: bool\n            If True find the closest valid edge tile from `position`.\n            Else find the furthest\n            Default is True.\n        spread_dist: float\n            How much distance between existing tumors?\n            Default is 4.0\n        unit_tag : int | None, optional\n            Unit tag to check if queen ability is available, by default None\n        cache_result : bool, optional\n            Should we cache the result to save computation?\n            unit_tag should be set if this is True\n            by default False\n\n        Returns\n        -------\n        Point2 | None\n            The coordinates of the nearest position at the edge of the creep.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER,\n            ManagerRequestType.FIND_NEARBY_CREEP_EDGE_POSITION,\n            **kwargs,\n        )\n\n    def get_closest_creep_tile(self, **kwargs) -&gt; None | Point2:\n        \"\"\"Get closest creep tile to `pos`\n\n        WARNING: May return `None` if no creep tiles observed.\n\n        CreepManager\n\n        Example:\n        ```py\n        import numpy as np\n\n        closest_tile: Point2 = (\n            self.mediator.get_closest_creep_tile(pos=point)\n        )\n        ```\n\n        Parameters:\n            pos (Point2): The position to search for closest creep tile.\n\n        Returns:\n            Point2 representing the closest creep tile or None if no creep tiles.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER,\n            ManagerRequestType.GET_CLOSEST_CREEP_TILE,\n            **kwargs,\n        )\n\n    @property\n    def get_creep_coverage(self) -&gt; float:\n        \"\"\"\n        How much of the map is covered by creep?\n\n        CreepManager\n\n        Returns:\n            A float between 0.0 and 100.0 indicating the coverage of the map.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER, ManagerRequestType.GET_CREEP_COVERAGE\n        )\n\n    @property\n    def get_creep_edges(self) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Fetches the edges of the detected creep on the map.\n\n        CreepManager\n\n        The returned value represents\n        the creep edges in the form of NumPy arrays.\n\n        Returns:\n            tuple of numpy.ndarray\n                A tuple containing two NumPy arrays.\n                Reflecting the coordinates of the creep edges.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER, ManagerRequestType.GET_CREEP_EDGES\n        )\n\n    @property\n    def get_creep_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the creep grid.\n        Creep tiles have a value of 1.0\n        Non creep tiles have any other value.\n\n        CreepManager\n\n        Example:\n        ```py\n        import numpy as np\n\n        creep_grid: np.ndarray = (\n            self.mediator.get_creep_grid\n        )\n        ```\n\n        Returns:\n            The creep grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER, ManagerRequestType.GET_CREEP_GRID\n        )\n\n    @property\n    def get_creep_tiles(self) -&gt; np.ndarray:\n        \"\"\"Get creep tiles.\n\n        CreepManager\n\n        Example:\n        ```py\n        import numpy as np\n\n        creep_tiles: np.ndarray = (\n            self.mediator.get_creep_tiles\n        )\n        ```\n\n        Returns:\n            Coordinates of all creep tiles on the map.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER, ManagerRequestType.GET_CREEP_TILES\n        )\n\n    def get_next_tumor_on_path(self, **kwargs) -&gt; Point2 | None:\n        \"\"\"\n        Determines the next tumor position on the path, using vectorized operations\n        to find positions along the creep edge that maintain proper separation.\n\n        Parameters:\n            grid : np.ndarray\n                A 2D array to path on.\n            from_pos : Point2\n                The starting position from which the path is evaluated.\n            to_pos : Point2\n                The target position on the grid where the path leads.\n            max_distance : float, optional\n                The maximum allowable distance from the `from_pos` to the\n                next tumor position.\n                Default is 999.9.\n            min_distance: float, optional\n                The minimum allowable distance from the `from_pos` to the\n                next tumor position.\n                Default is 0.0.\n            min_separation: float, optional\n                The minimum distance required between the new\n                tumor and existing tumors/queen routes.\n                Default is 3.0.\n            find_alternative: bool, optional\n                Find an alternative position if the closest position is\n                too close to existing tumors\n                Switch to False if possible to avoid unnecessary checks.\n                Default is True.\n\n        Returns:\n            Point2 or None\n                Returns the next suitable tumor position on the grid if a valid\n                position is found within the specified conditions.\n                Returns None if no valid position exists.\n        \"\"\"\n\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER,\n            ManagerRequestType.GET_NEXT_TUMOR_ON_PATH,\n            **kwargs,\n        )\n\n    def get_position_blocks_expansion(self, **kwargs) -&gt; bool:\n        \"\"\"See if a position blocks an expansion.\n\n        Parameters:\n            position : Point2\n                The position to check.\n\n        Returns:\n            Position blocks expansion.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER,\n            ManagerRequestType.GET_RANDOM_CREEP_POSITION,\n            **kwargs,\n        )\n\n    def get_random_creep_position(self, **kwargs) -&gt; Point2 | None:\n        \"\"\"Find a random valid creep position within tumor range.\n\n        Parameters:\n            position : Point2\n                The position to search from.\n            max_attempts : int\n                Maximum attempts to find a valid position.\n\n        Returns:\n            Point2 | None\n                Random creep position.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER,\n            ManagerRequestType.GET_RANDOM_CREEP_POSITION,\n            **kwargs,\n        )\n\n    def get_overlord_creep_spotter_positions(self, **kwargs) -&gt; dict[int, Point2]:\n        \"\"\"Find optimal positions for overlords to provide vision for creep spread.\n\n        This function finds the edge of creep and distributes\n        overlord positions evenly around it.\n\n        Parameters:\n            overlords : Units | list[Unit]\n                The overlords that will be positioned for creep vision\n\n        Returns:\n            dict[int: Point2]\n                Dictionary mapping overlord tag to position where it should move\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER,\n            ManagerRequestType.GET_OVERLORD_CREEP_SPOTTER_POSTIONS,\n            **kwargs,\n        )\n\n    def get_tumor_influence_lowest_cost_position(self, **kwargs) -&gt; Point2 | None:\n        \"\"\"\n        Determines the lowest cost position influenced by the tumor through a request\n        to the creep manager.\n\n        This method sends a request to the creep manager to retrieve the position\n        with the lowest cost under tumor influence. The operation is executed\n        via the manager_request function.\n\n        Parameters:\n            position : Point2\n                Tumor position.\n\n        Returns:\n            Point2:\n                Furthest placement with lowest cost under tumor influence.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.CREEP_MANAGER,\n            ManagerRequestType.GET_TUMOR_INFLUENCE_LOWEST_COST_POSITION,\n            **kwargs,\n        )\n\n    \"\"\"\n    EnemyToBaseManager\n    \"\"\"\n\n    @property\n    def get_flying_enemy_near_bases(self) -&gt; dict[int, set[int]]:\n        \"\"\"Get dictionary containing flying enemy near townhalls.\n\n        EnemyToBase Manager\n\n        Returns:\n            dict[int, set[int]]:\n                A dictionary mapping townhall tags (keys) to sets of\n                 enemy tags (values) near each base.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.ENEMY_TO_BASE_MANAGER,\n            ManagerRequestType.GET_FLYING_ENEMY_NEAR_BASES,\n        )\n\n    @property\n    def get_ground_enemy_near_bases(self, **kwargs) -&gt; dict[int, set[int]]:\n        \"\"\"Get dictionary containing ground enemy near townhalls.\n\n        EnemyToBase Manager\n\n        Returns:\n            dict[int, set[int]]:\n                A dictionary where the integer key is a townhall tag.\n                And the value contains a set of ints containing\n                enemy tags near this base.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.ENEMY_TO_BASE_MANAGER,\n            ManagerRequestType.GET_GROUND_ENEMY_NEAR_BASES,\n            **kwargs,\n        )\n\n    @property\n    def get_main_air_threats_near_townhall(self) -&gt; Units:\n        \"\"\"Get the main enemy air force near one of our bases.\n\n        EnemyToBase Manager\n\n        Returns:\n            The largest enemy air force near our bases.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.ENEMY_TO_BASE_MANAGER,\n            ManagerRequestType.GET_MAIN_AIR_THREATS_NEAR_TOWNHALL,\n        )\n\n    @property\n    def get_main_ground_threats_near_townhall(self) -&gt; Units:\n        \"\"\"Get the main enemy ground force near one of our bases.\n\n        EnemyToBase Manager\n\n        Returns:\n            The largest enemy ground force near our bases.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.ENEMY_TO_BASE_MANAGER,\n            ManagerRequestType.GET_MAIN_GROUND_THREATS_NEAR_TOWNHALL,\n        )\n\n    @property\n    def get_th_tag_with_largest_ground_threat(self) -&gt; int:\n        \"\"\"Get the tag of our townhall with the largest enemy ground force nearby.\n\n        WARNING: This will remember the townhall tag even if enemy has gone.\n        Do not use this to detect enemy at a base.\n        Use `get_main_ground_threats_near_townhall`\n        Or `get_ground_enemy_near_bases` instead\n\n        EnemyToBase Manager\n\n        Returns:\n            The largest enemy ground force near our bases.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.ENEMY_TO_BASE_MANAGER,\n            ManagerRequestType.GET_TH_TAG_WITH_LARGEST_GROUND_THREAT,\n        )\n\n    \"\"\"\n    IntelManager\n    \"\"\"\n\n    @property\n    def get_did_enemy_rush(self) -&gt; bool:\n        \"\"\"\n        Determines whether the enemy executed a rush strategy based\n        on the intel manager's evaluation.\n\n        WARNING: Super opinionated!\n\n        Returns\n        -------\n        bool\n            True if the enemy performed a rush strategy, otherwise False.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_DID_ENEMY_RUSH\n        )\n\n    @property\n    def get_enemy_expanded(self) -&gt; bool:\n        \"\"\"Has the enemy expanded?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Has enemy expanded out of their main?\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_EXPANDED\n        )\n\n    @property\n    def get_enemy_four_gate(self) -&gt; bool:\n        \"\"\"Has the enemy gone four gate?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Is enemy four gate?\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_FOUR_GATE\n        )\n\n    @property\n    def get_enemy_has_base_outside_natural(self) -&gt; bool:\n        \"\"\"Has the enemy expanded outside of their natural?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Has enemy expanded out of natural?\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER,\n            ManagerRequestType.GET_ENEMY_HAS_BASE_OUTSIDE_NATURAL,\n        )\n\n    @property\n    def get_enemy_ling_rushed(self) -&gt; bool:\n        \"\"\"Has the enemy ling rushed?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy ling rushed?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_LING_RUSHED\n        )\n\n    @property\n    def get_enemy_marine_rush(self) -&gt; bool:\n        \"\"\"Is the enemy currently marine rushing?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy marine rushed?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_MARINE_RUSH\n        )\n\n    @property\n    def get_enemy_marauder_rush(self) -&gt; bool:\n        \"\"\"Is the enemy currently marauder rushing?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy marauder rush?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_MARAUDER_RUSH\n        )\n\n    @property\n    def get_enemy_ravager_rush(self) -&gt; Point2:\n        \"\"\"Has the enemy ravager rushed?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy ravager rush?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_RAVAGER_RUSH\n        )\n\n    @property\n    def get_enemy_roach_rushed(self) -&gt; Point2:\n        \"\"\"Did the enemy roach rush?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy roach rushed?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_ROACH_RUSHED\n        )\n\n    @property\n    def get_enemy_was_greedy(self) -&gt; Point2:\n        \"\"\"Was the enemy greedy?\n\n        WARNING: Currently not working, will always return `False`\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy was greedy?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_WAS_GREEDY\n        )\n\n    @property\n    def get_enemy_went_four_gate(self) -&gt; Point2:\n        \"\"\"The enemy went four gate this game?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy went four gate in this game?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_WENT_FOUR_GATE\n        )\n\n    @property\n    def get_enemy_went_marine_rush(self) -&gt; Point2:\n        \"\"\"The enemy went marine rush this game?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy went marine rush in this game?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_WENT_MARINE_RUSH\n        )\n\n    @property\n    def get_enemy_went_marauder_rush(self) -&gt; Point2:\n        \"\"\"The enemy went marauder rush this game?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy went marauder rush in this game?\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_WENT_MARAUDER_RUSH\n        )\n\n    @property\n    def get_enemy_went_reaper(self) -&gt; Point2:\n        \"\"\"The enemy opened with reaper this game?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy went reaper in this game?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_WENT_REAPER\n        )\n\n    @property\n    def get_enemy_worker_rushed(self) -&gt; Point2:\n        \"\"\"The enemy went for a worker rush this game?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy went worker rush in this game?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_ENEMY_WORKER_RUSHED\n        )\n\n    @property\n    def get_is_proxy_zealot(self) -&gt; bool:\n        \"\"\"There is currently proxy zealot attempt from enemy?\n\n        WARNING: Opinionated method, please write your own if you don't\n        agree with this decision.\n\n        Intel Manager\n\n        Returns:\n            Enemy is attempting a proxy zealot rush?\n        \"\"\"\n        return self.manager_request(\n            ManagerName.INTEL_MANAGER, ManagerRequestType.GET_IS_PROXY_ZEALOT\n        )\n\n    \"\"\"\n    FlyingStructureManager\n    \"\"\"\n\n    @property\n    def get_flying_structure_tracker(self) -&gt; dict[int, Any]:\n        \"\"\"Get the current information stored by FlyingStructureManager.\n\n        FlyingStructureManager\n\n        Returns:\n            Key -&gt; structure_tag, Value -&gt; Information about the flight.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.FLYING_STRUCTURE_MANAGER,\n            ManagerRequestType.GET_FLYING_STRUCTURE_TRACKER,\n        )\n\n    def move_structure(self, **kwargs) -&gt; None:\n        \"\"\"Request a structure to move via flight.\n\n        FlyingStructureManager\n\n        Parameters:\n            structure (Unit): The structure to be moved or landed.\n            target (Point2): The target location for the structure.\n            should_land (bool, optional): Whether the structure should\n                land after moving. Defaults to False.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.FLYING_STRUCTURE_MANAGER,\n            ManagerRequestType.MOVE_STRUCTURE,\n            **kwargs,\n        )\n\n    \"\"\"\n    NydusManager\n    \"\"\"\n\n    def add_to_nydus_travellers(self, **kwargs) -&gt; None:\n        \"\"\"Add a unit to the nydus travellers.\n\n        NydusManager\n\n        Parameters:\n            unit: Unit\n                The unit to be added to the nydus travellers.\n            entry_nydus_tag: int\n                The tag of the nydus we are entering.\n            exit_nydus_tag: int\n                The tag of the nydus we are exiting.\n            exit_towards: Point2\n                The direction out of the exit nydus.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER,\n            ManagerRequestType.ADD_TO_NYDUS_TRAVELLERS,\n            **kwargs,\n        )\n\n    def clear_nydus_travellers(self, **kwargs) -&gt; None:\n        \"\"\"Clear the nydus travellers dictionary.\n\n        NydusManager\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER,\n            ManagerRequestType.CLEAR_NYDUS_TRAVELLERS,\n            **kwargs,\n        )\n\n    def find_nydus_at_location(self, **kwargs) -&gt; Point2 | None:\n        \"\"\"Given a location, find a potential nydus canal placement.\n        Tries to avoid enemy visibility.\n        Prioritizes locations that are already visible.\n        Passing in a base location is recommended. But any position should work.\n\n        WARNING: This only gives an idea where to place a nydus canal.\n            You still need to calculate a valid building placement, which might\n            mean the actual valid canal location is slightly different.\n\n        WARNING: This calculates placements out of vision if needed, so you\n            may need to send a scout before the canal can be placed.\n\n        Find a Nydus position with pathing cost less than max_cost in a region\n        containing the given point, at least min_distance from an enemy base and\n        no more than max_distance from the target point.\n\n        NydusManager\n\n        Parameters:\n            base_location: Point2\n            min_base_distance: float\n            max_nydus_distance: float\n            max_cost: int\n\n        Returns:\n            May return a location to be used for a nydus canal.\n            Could return None.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER,\n            ManagerRequestType.FIND_NYDUS_AT_LOCATION,\n            **kwargs,\n        )\n\n    @property\n    def get_banned_nydus_travellers(self, **kwargs) -&gt; dict[int, float]:\n        \"\"\"Get the nydus travellers dictionary.\n\n        NydusManager\n\n        Returns:\n            Dictionary where key is unit tag, and value is info\n            about the nydus travellers.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER,\n            ManagerRequestType.GET_BANNED_NYDUS_TRAVELLERS,\n            **kwargs,\n        )\n\n    @property\n    def get_nydus_travellers_dict(self, **kwargs) -&gt; None:\n        \"\"\"Get the nydus travellers dictionary.\n\n        NydusManager\n\n        Returns:\n            Dictionary where key is unit tag, and value is info\n            about the nydus travellers.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER, ManagerRequestType.GET_NYDUS_TRAVELLERS, **kwargs\n        )\n\n    def remove_from_nydus_travellers(self, **kwargs) -&gt; None:\n        \"\"\"Remove a unit from the nydus travellers dictionary.\n\n        NydusManager\n\n        Parameters:\n            unit_tag: int\n                The unit tag to be removed from the nydus travellers.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER,\n            ManagerRequestType.REMOVE_FROM_NYDUS_TRAVELLERS,\n            **kwargs,\n        )\n\n    @property\n    def get_enemy_main_nydus_points(self) -&gt; Point2:\n        \"\"\"Get the optimal position for a nydus in enemy main,\n        considering distance from base and ramp.\n\n        NydusManager\n\n        Returns:\n            Potential nydus position.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER, ManagerRequestType.GET_ENEMY_MAIN_NYDUS_POINTS\n        )\n\n    @property\n    def get_primary_nydus_enemy_main(self) -&gt; Point2:\n        \"\"\"Get the optimal position for a nydus in enemy main,\n        considering distance from base and ramp.\n\n        Nydus Manager\n\n        Returns:\n            Potential nydus position.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER, ManagerRequestType.GET_PRIMARY_NYDUS_ENEMY_MAIN\n        )\n\n    @property\n    def get_primary_nydus_own_main(self) -&gt; Point2:\n        \"\"\"Get the optimal position for a nydus in own main.\n        Could be useful scouting position.\n\n        Nydus Manager\n\n        Returns:\n            Potential nydus position.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.NYDUS_MANAGER, ManagerRequestType.GET_PRIMARY_NYDUS_OWN_MAIN\n        )\n\n    \"\"\"\n    ResourceManager\n    \"\"\"\n\n    @property\n    def get_mineral_patch_to_list_of_workers(self) -&gt; Dict[int, Set[int]]:\n        \"\"\"Get a dictionary containing mineral tag to worker tags\n\n        Resource Manager\n\n        Returns:\n            Dictionary where key is mineral tag, and value is workers assigned here.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.GET_MINERAL_PATCH_TO_LIST_OF_WORKERS,\n        )\n\n    @property\n    def get_worker_tag_to_townhall_tag(self) -&gt; dict[int, int]:\n        \"\"\"Get a dictionary containing worker tag to townhall tag.\n        Where the townhall is the place where worker returns resources\n\n        Resource Manager\n\n        Returns:\n            Dictionary where key is worker tag, and value is townhall tag.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.GET_WORKER_TAG_TO_TOWNHALL_TAG,\n        )\n\n    @property\n    def get_worker_to_mineral_patch_dict(self) -&gt; dict[int, int]:\n        \"\"\"Get a dictionary containing worker tag to mineral patch tag.\n\n        Resource Manager\n\n        Returns:\n            Dictionary where key is worker tag, and value is mineral tag.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.GET_WORKER_TO_MINERAL_PATCH_DICT,\n        )\n\n    def remove_mineral_field(self, **kwargs) -&gt; None:\n        \"\"\"Request for a mineral field to be removed from bookkeeping.\n\n        Resource Manager\n\n        Parameters:\n            mineral_field_tag (int): The tag of the mineral patch to remove.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.REMOVE_MINERAL_FIELD,\n            **kwargs,\n        )\n\n    @property\n    def get_worker_to_vespene_dict(self) -&gt; dict:\n        \"\"\"Get a dictionary containing worker tag to gas building tag.\n\n        Resource Manager\n\n        Returns:\n            Dictionary where key is worker tag, and value is gas building tag.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.GET_WORKER_TO_GAS_BUILDING_DICT,\n        )\n\n    def remove_gas_building(self, **kwargs) -&gt; None:\n        \"\"\"Request for a gas building to be removed from bookkeeping.\n\n        Resource Manager\n\n        Parameters:\n            gas_building_tag (int): The tag of the gas building to remove.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.REMOVE_GAS_BUILDING,\n            **kwargs,\n        )\n\n    \"\"\"\n    PathManager\n    \"\"\"\n\n    def find_closest_safe_spot(self, **kwargs) -&gt; Point2:\n        \"\"\"Find the closest point with the lowest cost on a grid.\n\n        PathManager\n\n        Parameters:\n            from_pos (Point2): Where the search starts from.\n            grid (np.ndarray): The grid to find the low-cost point on.\n            radius (float): How far away the safe point can be.\n\n        Returns:\n            The closest location with the lowest cost.\n\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER, ManagerRequestType.GET_CLOSEST_SAFE_SPOT, **kwargs\n        )\n\n    def find_low_priority_path(self, **kwargs) -&gt; list[Point2]:\n        \"\"\"Find several points in a path.\n\n        This way a unit can queue them up all at once for performance reasons.\n\n        i.e. running drones from a base or sending an overlord to a new position.\n\n        This does not return every point in the path. Instead, it returns points spread\n        along the path.\n\n        PathManager\n\n        Parameters:\n            start (Point2): Start point of the path.\n            target (Point2): Desired end point of the path.\n            grid (np.ndarray): The grid that should be used for pathing.\n\n        Returns:\n            List of points composing the path.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER,\n            ManagerRequestType.FIND_LOW_PRIORITY_PATH,\n            **kwargs,\n        )\n\n    def find_lowest_cost_points(self, **kwargs) -&gt; list[Point2]:\n        \"\"\"Find the point(s) with the lowest cost within `radius` from `from_pos`.\n\n        PathManager\n\n        Parameters:\n            from_pos (Point2): Point to start the search from.\n            radius (float): How far away the returned points can be.\n            grid (np.ndarray): Which grid to query for lowest cost points.\n\n        Returns:\n            Points with the lowest cost on the grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER,\n            ManagerRequestType.FIND_LOWEST_COST_POINTS,\n            **kwargs,\n        )\n\n    def find_path_next_point(self, **kwargs) -&gt; Point2:\n        \"\"\"Find the next point in a path.\n\n        Parameters:\n            start (Point2): Start point of the path.\n            target (Point2): Desired end point of the path.\n            grid (np.ndarray): The grid that should be used for pathing.\n            sensitivity (int, optional): Amount of points that should be\n                skipped in the full path between tiles that are returned.\n                Default value is 5.\n            smoothing (bool, optional): Optional path smoothing where nodes are\n                removed if it's possible to jump ahead some tiles in\n                a straight line with a lower cost.\n                Default value is False.\n            sense_danger (bool, optional): Check to see if there are any\n                dangerous tiles near the starting point. If this is True and\n                there are no dangerous tiles near the starting point,\n                the pathing query is skipped and the target is returned.\n                Default value is True.\n            danger_distance (float, optional): How far away from the\n                start to look for danger.\n                Default value is 20.\n            danger_threshold (float, optional): Minimum value for a tile\n                to be considered dangerous.\n                Default value is 5.\n\n        Returns:\n            The next point in the path from the start to the target which may be the\n            same as the target if it's safe.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER, ManagerRequestType.PATH_NEXT_POINT, **kwargs\n        )\n\n    def find_nydus_path_next_point(\n        self, **kwargs\n    ) -&gt; tuple[Point2 | None, Point2 | None, list[int] | None]:\n        \"\"\"Find the next point in a path including via nyduses.\n\n        Parameters:\n            start (Point2): Start point of the path.\n            target (Point2): Desired end point of the path.\n            grid (np.ndarray): The grid that should be used for pathing.\n            sensitivity (int, optional): Amount of points that should be\n                skipped in the full path between tiles that are returned.\n                Default value is 5.\n            smoothing (bool, optional): Optional path smoothing where nodes are\n                removed if it's possible to jump ahead some tiles in\n                a straight line with a lower cost.\n                Default value is False.\n            sense_danger (bool, optional): Check to see if there are any\n                dangerous tiles near the starting point. If this is True and\n                there are no dangerous tiles near the starting point,\n                the pathing query is skipped and the target is returned.\n                Default value is True.\n            danger_distance (float, optional): How far away from the\n                start to look for danger.\n                Default value is 20.\n            danger_threshold (float, optional): Minimum value for a tile\n                to be considered dangerous.\n                Default value is 5.\n\n        Returns:\n            Tuple of (next_point, nydus_next_point, nydus_points)\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER, ManagerRequestType.NYDUS_PATH_NEXT_POINT, **kwargs\n        )\n\n    def find_raw_path(self, **kwargs) -&gt; list[Point2]:\n        \"\"\"Used for finding a full path, mostly for distance checks.\n\n        PathManager\n\n        Parameters:\n            start (Point2): Start point of the path.\n            target (Point2): Desired end point of the path.\n            grid (np.ndarray): The grid that should be used for pathing.\n            sensitivity (int): Amount of points that should be skipped in\n                the full path between tiles that are returned.\n\n        Returns:\n            List of points composing the path.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER, ManagerRequestType.FIND_RAW_PATH, **kwargs\n        )\n\n    @property\n    def get_air_avoidance_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the air avoidance pathing grid.\n        Any tile with a value greater than one will contain some\n        dangerous effects or spells that should always be avoided.\n        Such as storms, nukes, ravager biles etc...\n\n        GridManager\n\n        Example:\n        ```py\n        import numpy as np\n\n        avoidance_grid: np.ndarray = self.mediator.get_air_avoidance_grid\n        ```\n\n        Returns:\n            The air avoidance pathing grid.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_AIR_AVOIDANCE_GRID\n        )\n\n    @property\n    def get_air_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the air pathing grid.\n\n        Pathable tiles have a value of 1.0\n        Pathable tiles with enemy influence have a value &gt; 1.0\n            The higher the value, the more influence there is.\n        Non-pathable tiles have a value of np.inf\n\n        GridManager\n\n        Example:\n        ```py\n        import numpy as np\n\n        air_grid: np.ndarray = self.mediator.get_air_grid\n        ```\n\n        Returns:\n            The air pathing grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_AIR_GRID\n        )\n\n    @property\n    def get_air_vs_ground_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the air vs ground pathing grid. (air grid)\n\n        grid is computed in a way that lowers the\n        cost of nonpathable terrain for ground units,\n        making air units naturally \"drawn\" to it.\n\n        Pathable tiles have a value of 1.0\n        Pathable tiles with enemy influence have a value &gt; 1.0\n            The higher the value, the more influence there is.\n        Non-pathable tiles have a value of np.inf\n\n        GridManager\n\n        Example:\n        ```py\n        import numpy as np\n\n        air_vs_ground_grid: np.ndarray = (\n            self.mediator.get_air_vs_ground_grid\n        )\n        ```\n\n        Returns:\n            The air vs ground pathing grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_AIR_VS_GROUND_GRID\n        )\n\n    @property\n    def get_cached_ground_grid(self) -&gt; np.ndarray:\n        \"\"\"Get a non-influence ground pathing grid.\n\n        GridManager\n\n        Example:\n        ```py\n        import numpy as np\n\n        cached_ground_grid: np.ndarray = (\n            self.mediator.get_cached_ground_grid\n        )\n        ```\n\n        Returns:\n            The clean ground pathing grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_CACHED_GROUND_GRID\n        )\n\n    @property\n    def get_climber_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the climber ground pathing grid for reapers and colossus.\n        Pathable tiles have a value of 1.0\n        Pathable tiles with enemy influence have a value &gt; 1.0\n            The higher the value, the more influence there is.\n        Non-pathable tiles have a value of np.inf\n\n        GridManager\n\n        Example:\n        ```py\n        import numpy as np\n\n        climber_grid: np.ndarray = (\n            self.mediator.get_climber_grid\n        )\n        ```\n\n        Returns:\n            The climber pathing grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_CLIMBER_GRID\n        )\n\n    @property\n    def get_forcefield_positions(self) -&gt; list[Point2]:\n        \"\"\"Get positions of forcefields.\n\n        GridManager\n\n        Example:\n        ```py\n        from sc2.position import Point2\n\n        ff_positions: list[Point2] = self.mediator.get_forcefield_positions\n        ```\n\n        Returns:\n            List of the center point of forcefields.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER,\n            ManagerRequestType.GET_FORCEFIELD_POSITIONS,\n        )\n\n    @property\n    def get_ground_avoidance_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the ground avoidance pathing grid.\n        Any tile with a value greater than one will contain some\n        dangerous effects or spells that should always be avoided.\n        Such as storms, nukes, ravager biles etc...\n\n        GridManager\n\n        Returns:\n            The ground avoidance pathing grid.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_GROUND_AVOIDANCE_GRID\n        )\n\n    @property\n    def get_ground_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the ground pathing grid.\n        Pathable tiles have a value of 1.0\n        Pathable tiles with enemy influence have a value &gt; 1.0\n            The higher the value, the more influence there is.\n        Non-pathable tiles have a value of np.inf\n\n        GridManager\n\n        Returns:\n            The ground pathing grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_GROUND_GRID\n        )\n\n    @property\n    def get_ground_to_air_grid(self) -&gt; np.ndarray:\n        \"\"\"Get an air grid that contains influence for ground dangers\n        that can shoot air.\n        This can be useful for keeping air units safe that can't\n        attack ground units.\n\n        Pathable tiles have a value of 1.0\n        Pathable tiles with enemy influence have a value &gt; 1.0\n            The higher the value, the more influence there is.\n        Non-pathable tiles have a value of np.inf\n\n        GridManager\n\n        Returns:\n            The ground pathing grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_GROUND_TO_AIR_GRID\n        )\n\n    @property\n    def get_map_data_object(self) -&gt; MapData:\n        \"\"\"Get the MapAnalyzer.MapData object being used.\n\n        PathManager\n\n        Returns:\n            The MapAnalyzer.MapData object being used.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_MAP_DATA\n        )\n\n    @property\n    def get_priority_ground_avoidance_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the pathing grid containing things ground units should always avoid.\n\n        GridManager\n\n        Returns:\n            The priority ground avoidance pathing grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER,\n            ManagerRequestType.GET_PRIORITY_GROUND_AVOIDANCE_GRID,\n        )\n\n    @property\n    def get_tactical_ground_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the tactical ground grid.\n\n        Normal pathable tiles with no units on them\n        have a value of 200.0\n\n        Tiles with more enemy have value &gt; 200.0\n        Tiles with more friendly have value &lt; 200.0\n\n\n        GridManager\n\n        Returns:\n            The ground tactical grid.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.GRID_MANAGER, ManagerRequestType.GET_TACTICAL_GROUND_GRID\n        )\n\n    @property\n    def get_whole_map_array(self) -&gt; list[list[int]]:\n        \"\"\"Get the list containing every point on the map.\n\n        GridManager\n\n        Notes\n        -----\n        This does not return Point2s.\n\n        Returns:\n            Every point on the map.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER, ManagerRequestType.GET_WHOLE_MAP_ARRAY\n        )\n\n    @property\n    def get_whole_map_tree(self) -&gt; KDTree:\n        \"\"\"Get the KDTree of all points on the map.\n\n        PathManager\n\n        Returns:\n            KDTree of all points on the map.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER, ManagerRequestType.GET_WHOLE_MAP_TREE\n        )\n\n    def is_position_safe(self, **kwargs) -&gt; bool:\n        \"\"\"Check if the given position is considered dangerous.\n\n        PathManager\n\n        Parameters:\n            grid (np.ndarray): The grid to evaluate safety on.\n            position (Point2): The position to check the safety of.\n            weight_safety_limit (float): The maximum value the point can\n                have on the grid to be considered safe.\n                Default value is 1.0.\n\n        Returns:\n            True if the position is considered safe, False otherwise.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PATH_MANAGER,\n            ManagerRequestType.IS_POSITION_SAFE,\n            **kwargs,\n        )\n\n    \"\"\"\n    PlacementManager\n    \"\"\"\n\n    def can_place_structure(self, **kwargs) -&gt; bool:\n        \"\"\"Check if structure can be placed at a given position.\n\n        Faster cython alternative to `python-sc2` `await self.can_place()`\n\n        PlacementManager\n\n        Parameters:\n            position (Point2): The intended building position.\n            structure_type (UnitID): Structure type we want to place.\n            include_addon (bool, optional): For Terran structures,\n                check addon will place too.\n\n        Returns:\n            Indicating if structure can be placed at given position.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PLACEMENT_MANAGER,\n            ManagerRequestType.CAN_PLACE_STRUCTURE,\n            **kwargs,\n        )\n\n    @property\n    def get_placements_dict(self, **kwargs) -&gt; dict:\n        \"\"\"Get the placement dict ares calculated at beginning\n        of the game.\n\n        Structure of dictionary:\n\n        base_loc is a Point2 key for every expansion location on map.\n\n        ```\n        placement_dict = {\n            base_loc: Point2:\n                BuildingSize.TWO_BY_TWO: {\n                    building_pos: Point2((2, 2)):\n                        {\n                            available: True,\n                            has_addon: False\n                            taken: False,\n                            is_wall: True,\n                            building_tag: 0,\n                            worker_on_route: False,\n                            time_requested: 0.0,\n                            production_pylon: False,\n                            bunker: False,\n                            optimal_pylon: False\n                        },\n                        {...}\n                },\n                BuildingSize.THREE_BY_THREE: {\n                    building_pos: Point2((5, 5)):\n                        {\n                            available: True,\n                            has_addon: False\n                            taken: False,\n                            is_wall: True,\n                            building_tag: 0,\n                            worker_on_route: False,\n                            time_requested: 0.0,\n                            production_pylon: False,\n                            bunker: False,\n                            optimal_pylon: False\n                        },\n                        {...}\n                },\n            {...}\n        }\n        ```\n\n        PlacementManager\n\n        Returns:\n            Indicating if structure can be placed at given position.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PLACEMENT_MANAGER, ManagerRequestType.GET_PLACEMENTS_DICT\n        )\n\n    @property\n    def get_pvz_nat_gatekeeping_pos(self, **kwargs) -&gt; Union[Point2, None]:\n        \"\"\"Get the gatekeeper position in a PvZ natural wall if available.\n\n        WARNING: This can return `None` so your code should account for this.\n\n        PlacementManager\n\n\n        Returns:\n            Position of gatekeeper in natural wall\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PLACEMENT_MANAGER, ManagerRequestType.GET_PVZ_NAT_GATEKEEPER_POS\n        )\n\n    def request_building_placement(self, **kwargs) -&gt; Optional[Point2]:\n        \"\"\"Request a building placement from the precalculated building formation.\n\n        PlacementManager\n\n        Parameters:\n            base_location (Point2): The general area where the placement should be near.\n                This should be an expansion location.\n            structure_type (UnitID): Structure type requested.\n            first_pylon (bool, optional): Try to take designated\n                first pylon if available.\n                Default value is False.\n            static_defence (bool, optional): Try to take designated\n                static defence placements if available.\n                Default value is False.\n            wall (bool, optional): Request a wall structure placement.\n                Will find alternative if no wall placements available.\n                Default value is False.\n            find_alternative (bool, optional): If no placements available\n                at base_location, find an alternative at a nearby base.\n                Default value is True.\n            reserve_placement (bool, optional): Reserve this booking for a\n                while, so another customer doesn't request it.\n                Default value is True.\n            within_psionic_matrix (bool, optional): Protoss specific -&gt; calculated\n                position have power?\n                Default value is False.\n            pylon_build_progress (float, optional): Only relevant\n                if `within_psionic_matrix = True`.\n                Default value is 1.0.\n            closest_to (Point2, optional): Find placement at base closest to this.\n\n\n        Returns:\n            Indicating if structure can be placed at given position.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.PLACEMENT_MANAGER,\n            ManagerRequestType.REQUEST_BUILDING_PLACEMENT,\n            **kwargs,\n        )\n\n    def request_warp_in(self, **kwargs) -&gt; None:\n        \"\"\"Request a warp in spot, without making a query to the game client.\n\n        PlacementManager\n\n        Parameters:\n            unit_type (UnitTypeId): The unit we want to warp in.\n            target (Optional[Point2]): If provided, attempt to find\n                spot closest to this location.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.WARP_IN_MANAGER,\n            ManagerRequestType.REQUEST_WARP_IN,\n            **kwargs,\n        )\n\n    \"\"\"\n    ResourceManager\n    \"\"\"\n\n    @property\n    def get_num_available_mineral_patches(self) -&gt; int:\n        \"\"\"Get the number available mineral fields.\n\n        An available mineral field is one that is near a townhall and has fewer than two\n        assigned workers.\n\n        ResourceManager\n\n        Returns:\n            Number available mineral fields.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.GET_NUM_AVAILABLE_MIN_PATCHES,\n        )\n\n    def remove_worker_from_mineral(self, **kwargs) -&gt; None:\n        \"\"\"Remove worker from internal data structures.\n\n        This happens if worker gets assigned to do something else\n\n        ResourceManager\n\n        Parameters:\n            worker_tag: Tag of the worker to be removed.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.REMOVE_WORKER_FROM_MINERAL,\n            **kwargs,\n        )\n\n    def select_worker(self, **kwargs) -&gt; Optional[Unit]:\n        \"\"\"Select a worker via the ResourceManager.\n\n        This way we can select one assigned to a far mineral patch.\n        Make sure to change the worker role once selected, otherwise it will be selected\n        to mine again. This doesn't select workers from geysers, so make sure to remove\n        workers from gas if low on workers.\n\n        ResourceManager\n\n        Parameters:\n            target_position (Point2): Location to get the closest workers to.\n            force_close (bool): Select the available worker closest to\n                `target_position` if True.\n            select_persistent_builder (bool): If True, we can select\n                the persistent_builder if it's available.\n            only_select_persistent_builder (bool): If True, don't find an\n                alternative worker.\n            min_health_perc (float): Only select workers above this health percentage.\n            min_shield_perc (float): Only select workers above this shield percentage.\n\n        Returns:\n            Selected worker, if available.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.SELECT_WORKER,\n            **kwargs,\n        )\n\n    @property\n    def get_mineral_target_dict(self) -&gt; dict[int, Point2]:\n        \"\"\"Get position in front of each mineral.\n\n        This position is used for speed mining, and is also useful for\n        making sure worker is moved to the right side of a mineral.\n\n        ResourceManager\n\n        Returns:\n            Key -&gt; mineral tag, Value -&gt; Position\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.GET_MINERAL_TARGET_DICT,\n        )\n\n    \"\"\"\n    SquadManager\n    \"\"\"\n\n    def get_position_of_main_squad(self, **kwargs) -&gt; Point2:\n        \"\"\"Given a unit role, find where the main squad is.\n\n        SquadManager\n\n        Parameters:\n            role (UnitRole): Get the squads for this unit role.\n\n        Returns:\n            Position of main squad for this `role`\n        \"\"\"\n        return self.manager_request(\n            ManagerName.SQUAD_MANAGER,\n            ManagerRequestType.GET_POSITION_OF_MAIN_SQUAD,\n            **kwargs,\n        )\n\n    def get_squads(self, **kwargs) -&gt; list[\"UnitSquad\"]:\n        \"\"\"Given a unit role, get the updated squads.\n\n        SquadManager\n\n        Parameters:\n            role (UnitRole): Get the squads for this unit role.\n            squad_radius: The threshold as to which separate squads are formed.\n            unit_type: If specified, only form squads with these unit types\n                WARNING: Will not remove units that have already\n                         been assigned to a squad.\n\n        Returns:\n            Each squad with this unit role.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.SQUAD_MANAGER,\n            ManagerRequestType.GET_SQUADS,\n            **kwargs,\n        )\n\n    def remove_tag_from_squads(self, **kwargs) -&gt; None:\n        \"\"\"\n        SquadManager\n\n        Parameters:\n            tag (int): Get the squads for this unit role.\n            squad_radius (float): The threshold as to which separate squads are formed.\n            unit_type (UnitTypeId): If specified, only form squads with these unit types\n                WARNING: Will not remove units that have already\n                         been assigned to a squad.\n\n        Returns:\n            Each squad with this unit role.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.SQUAD_MANAGER,\n            ManagerRequestType.REMOVE_TAG_FROM_SQUADS,\n            **kwargs,\n        )\n\n    \"\"\"\n    TerrainManager\n    \"\"\"\n\n    def building_position_blocked_by_burrowed_unit(self, **kwargs) -&gt; Optional[Point2]:\n        \"\"\"See if the building position is blocked by a burrowed unit.\n\n        TerrainManager\n\n        Parameters:\n            worker_tag (int): The worker attempting to build the structure.\n            position (Point2): Where the structure is attempting to be placed.\n\n        Returns:\n            The position that's blocked by an enemy unit.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER,\n            ManagerRequestType.BUILDING_POSITION_BLOCKED_BY_BURROWED_UNIT,\n            **kwargs,\n        )\n\n    def get_behind_mineral_positions(self, **kwargs) -&gt; list[Point2]:\n        \"\"\"Finds 3 spots behind the mineral line\n\n        This is useful for building structures out of typical cannon range.\n\n        TerrainManager\n\n        Parameters:\n            th_pos (Point2): Position of townhall to find points behind\n                the mineral line of.\n\n        Returns:\n            Points behind the mineral line of the designated base.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER,\n            ManagerRequestType.GET_BEHIND_MINERAL_POSITIONS,\n            **kwargs,\n        )\n\n    def get_closest_overlord_spot(self, **kwargs) -&gt; Point2:\n        \"\"\"Given a position, find the closest high ground overlord spot.\n\n        TerrainManager\n\n        Parameters:\n            from_pos (Point2): Position the Overlord spot should be closest to.\n\n        Returns:\n            The closest Overlord hiding spot to the position.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER,\n            ManagerRequestType.GET_CLOSEST_OVERLORD_SPOT,\n            **kwargs,\n        )\n\n    @property\n    def get_defensive_third(self) -&gt; Point2:\n        \"\"\"Get the third furthest from enemy.\n\n        TerrainManager\n\n        Returns:\n            Location of the third base furthest from the enemy.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_DEFENSIVE_THIRD\n        )\n\n    @property\n    def get_enemy_expansions(self) -&gt; list[Tuple[Point2, float]]:\n        \"\"\"Get the expansions, as ordered from the enemy's point of view.\n\n        TerrainManager\n\n        Returns:\n            list[Tuple[Point2, float]]:\n                The first element is the\n                location of the base. The second element is the pathing\n                distance from the enemy main base.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_ENEMY_EXPANSIONS\n        )\n\n    @property\n    def get_enemy_fourth(self) -&gt; Point2:\n        \"\"\"Get the enemy fourth base.\n\n        TerrainManager\n\n        Returns:\n            Location of the enemy fourth base.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_ENEMY_FOURTH\n        )\n\n    @property\n    def get_enemy_nat(self) -&gt; Point2:\n        \"\"\"Get the enemy natural expansion.\n\n        TerrainManager\n\n        Returns:\n            Location of the enemy natural expansion.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_ENEMY_NAT\n        )\n\n    @property\n    def get_enemy_ramp(self) -&gt; Ramp:\n        \"\"\"Get the enemy main base ramp.\n\n        TerrainManager\n\n        Returns:\n            sc2 Ramp object for the enemy main base ramp.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_ENEMY_RAMP\n        )\n\n    @property\n    def get_enemy_third(self) -&gt; Point2:\n        \"\"\"Get the enemy third base.\n\n        TerrainManager\n\n        Returns:\n            Location of the enemy third base.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_ENEMY_THIRD\n        )\n\n    def get_flood_fill_area(self, **kwargs) -&gt; set[tuple[int, int]]:\n        \"\"\"Given a point, flood fill outward from it and return the valid points.\n\n        This flood fill does not continue through chokes.\n\n        TerrainManager\n\n        Parameters:\n            start_point (Point2): Where to start the flood fill.\n            max_dist (float): Only include points closer than this\n                distance to the start point.\n\n        Returns:\n            Tuple[int, List[Tuple[int, int]]]:\n                First element is the number of valid points.\n                Second element is the list of all valid points.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER,\n            ManagerRequestType.GET_FLOOD_FILL_AREA,\n            **kwargs,\n        )\n\n    @property\n    def get_initial_pathing_grid(self) -&gt; np.ndarray:\n        \"\"\"Get the pathing grid as it was on the first iteration.\n\n        TerrainManager\n\n        Returns:\n            The pathing grid as it was on the first iteration.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_INITIAL_PATHING_GRID\n        )\n\n    @property\n    def get_is_free_expansion(self) -&gt; bool:\n        \"\"\"Check all bases for a free expansion.\n\n        TerrainManager\n\n        Returns:\n            True if there exists a free expansion, False otherwise.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_IS_FREE_EXPANSION\n        )\n\n    @property\n    def get_map_choke_points(self) -&gt; set[Point2]:\n        \"\"\"All the points on the map that compose choke points.\n\n        TerrainManager\n\n        Returns:\n            All the points on the map that compose choke points.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER,\n            ManagerRequestType.GET_MAP_CHOKE_POINTS,\n        )\n\n    @property\n    def get_ol_spot_near_enemy_nat(self) -&gt; Point2:\n        \"\"\"Get the overlord spot nearest to the enemy natural.\n\n        TerrainManager\n\n        Returns:\n            Overlord spot near the enemy natural.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER,\n            ManagerRequestType.GET_OL_SPOT_NEAR_ENEMY_NATURAL,\n        )\n\n    @property\n    def get_ol_spots(self) -&gt; list[Point2]:\n        \"\"\"High ground Overlord hiding spots.\n\n        TerrainManager\n\n        Returns:\n            List of Overlord hiding spots.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER,\n            ManagerRequestType.GET_OL_SPOTS,\n        )\n\n    @property\n    def get_own_expansions(self) -&gt; list[Tuple[Point2, float]]:\n        \"\"\"Get the expansions.\n\n        TerrainManager\n\n        Returns:\n            List[Tuple[Point2, float]]: List of Tuples where\n                The first element is the location of the base.\n                The second element is the pathing distance from our main base.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_OWN_EXPANSIONS\n        )\n\n    @property\n    def get_own_nat(self) -&gt; Point2:\n        \"\"\"Get our natural expansion.\n\n        TerrainManager\n\n        Returns:\n            Location of our natural expansion.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER, ManagerRequestType.GET_OWN_NAT\n        )\n\n    @property\n    def get_positions_blocked_by_burrowed_enemy(self) -&gt; list[Point2]:\n        \"\"\"Build positions that are blocked by a burrowed enemy unit.\n\n        TerrainManager\n\n        Returns:\n            List of build positions that are blocked by a burrowed enemy unit.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.TERRAIN_MANAGER,\n            ManagerRequestType.GET_POSITIONS_BLOCKED_BY_BURROWED_ENEMY,\n        )\n\n    \"\"\"\n    UnitCacheManager\n    \"\"\"\n\n    @property\n    def get_cached_enemy_army(self) -&gt; Units:\n        \"\"\"Get the Units object for the enemy army.\n\n        UnitCacheManager\n\n        Returns:\n            The enemy army.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER, ManagerRequestType.GET_CACHED_ENEMY_ARMY\n        )\n\n    @property\n    def get_cached_enemy_workers(self) -&gt; Units:\n        \"\"\"Get the Units object for the enemy workers.\n\n        UnitCacheManager\n\n        Returns:\n            The enemy workers.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER, ManagerRequestType.GET_CACHED_ENEMY_WORKERS\n        )\n\n    @property\n    def get_enemy_army_dict(self) -&gt; DefaultDict[UnitID, Units]:\n        \"\"\"Get the dictionary of enemy army unit types to the units themselves.\n\n        UnitCacheManager\n\n        Returns:\n            The dictionary of enemy army unit types to the units themselves.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER,\n            ManagerRequestType.GET_CACHED_ENEMY_ARMY_DICT,\n        )\n\n    @property\n    def get_old_own_army_dict(self) -&gt; Dict[UnitID, Units]:\n        \"\"\"Get the previous iteration's `own_army` dict.\n\n        UnitCacheManager\n\n        Returns:\n            The dictionary of own army unit types to the units themselves.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER, ManagerRequestType.GET_OLD_OWN_ARMY_DICT\n        )\n\n    @property\n    def get_own_army(self) -&gt; Units:\n        \"\"\"Get the Units object for our own army.\n\n        UnitCacheManager\n\n        Returns:\n            Our own army.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER, ManagerRequestType.GET_CACHED_OWN_ARMY\n        )\n\n    @property\n    def get_own_army_dict(self) -&gt; Dict[UnitID, Units]:\n        \"\"\"Get the dictionary of own army unit types to the units themselves.\n\n        UnitCacheManager\n\n        Returns:\n            The dictionary of own army unit types to the units themselves.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER, ManagerRequestType.GET_CACHED_OWN_ARMY_DICT\n        )\n\n    @property\n    def get_own_structures_dict(self) -&gt; DefaultDict[UnitID, list[Unit]]:\n        \"\"\"Get the dictionary of own structure types to the units themselves.\n\n        UnitCacheManager\n\n        Returns:\n            The dictionary of own structure types to the units themselves.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER, ManagerRequestType.GET_OWN_STRUCTURES_DICT\n        )\n\n    def get_own_unit_count(self, **kwargs) -&gt; int:\n        \"\"\"Get the dictionary of own structure types to the units themselves.\n\n        UnitCacheManager\n\n        Parameters:\n            unit_type_id (UnitID): Unit type to count.\n            include_alias (bool): Check aliases. (default=True)\n\n        Returns:\n            Total count of this unit including aliases if specified.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER,\n            ManagerRequestType.GET_OWN_UNIT_COUNT,\n            **kwargs,\n        )\n\n    def get_units_from_tags(self, **kwargs) -&gt; list[Unit]:\n        \"\"\"Get a `list` of `Unit` objects corresponding to the given tags.\n\n        UnitCacheManager\n\n        Parameters:\n            tags: Tags of the units to retrieve.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER,\n            ManagerRequestType.GET_UNITS_FROM_TAGS,\n            **kwargs,\n        )\n\n    @property\n    def get_removed_units(self) -&gt; Units:\n        \"\"\"Get the units removed from memory units.\n\n        UnitCacheManager\n\n        Returns:\n            The units removed from memory units.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_CACHE_MANAGER, ManagerRequestType.GET_REMOVED_UNITS\n        )\n\n    \"\"\"\n    UnitMemoryManager\n    \"\"\"\n\n    @property\n    def get_all_enemy(self) -&gt; Units:\n        \"\"\"Get all enemy units.\n\n        UnitMemoryManager\n\n        Returns:\n            All enemy units.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_MEMORY_MANAGER, ManagerRequestType.GET_ALL_ENEMY\n        )\n\n    def get_any_enemies_in_range(self, **kwargs) -&gt; Units:\n        \"\"\"Check various positions for any enemy units in range.\n\n        UnitMemoryManager\n\n        Parameters:\n            positions: list[Point2]\n            radius: float\n\n        Returns:\n            list of bool for each position\n            True would mean something is there\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_MEMORY_MANAGER,\n            ManagerRequestType.GET_ANY_ENEMY_IN_RANGE,\n            **kwargs,\n        )\n\n    @property\n    def get_enemy_ground(self) -&gt; Units:\n        \"\"\"Get enemy ground units.\n\n        UnitMemoryManager\n\n        Returns:\n            Enemy ground units.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_MEMORY_MANAGER, ManagerRequestType.GET_ENEMY_GROUND\n        )\n\n    @property\n    def get_enemy_fliers(self) -&gt; Units:\n        \"\"\"Get enemy flying units.\n\n        UnitMemoryManager\n\n        Returns:\n            Enemy flying units.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_MEMORY_MANAGER, ManagerRequestType.GET_ENEMY_FLIERS\n        )\n\n    @property\n    def get_enemy_tree(self) -&gt; KDTree:\n        \"\"\"Get the KDTree representing all enemy unit positions.\n\n        UnitMemoryManager\n\n        Returns:\n            KDTree representing all enemy unit positions.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_MEMORY_MANAGER, ManagerRequestType.GET_ENEMY_TREE\n        )\n\n    def get_units_in_range(\n        self, **kwargs\n    ) -&gt; Union[Dict[Union[int, Tuple[float, float]], Units], list[Units]]:\n        \"\"\"Get units in range of other units or points.\n\n        UnitMemoryManager\n\n        Parameters:\n            start_points (List[Union[Unit, Tuple[float, float]]]):\n                List of `Unit`s or positions to search for units from.\n            distances (Union[float, List[float]]): How far away from each point to\n                query. Must broadcast to the length of `start_points`.\n            query_tree (UnitTreeQueryType): Which KDTree should be queried.\n            return_as_dict (bool, optional): Sets whether the returned units in range\n                should be a dictionary or list. Default is False.\n\n\n        Returns:\n            Union[Dict[Union[int, Tuple[float, float]], Units], List[Units]]:\n                Returns the units in range of each start point as a `dict` where the key\n                is the unit tag or position and the value is the `Units` in range or a\n                `list` of `Units`.\n\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_MEMORY_MANAGER,\n            ManagerRequestType.GET_UNITS_IN_RANGE,\n            **kwargs,\n        )\n\n    @property\n    def get_own_tree(self) -&gt; Units:\n        \"\"\"Get the KDTree representing all friendly unit positions.\n\n        UnitMemoryManager\n\n        Returns:\n            KDTree representing all friendly unit positions.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_MEMORY_MANAGER, ManagerRequestType.GET_OWN_TREE\n        )\n\n    def get_is_detected(self, **kwargs) -&gt; bool:\n        \"\"\"Get if the enemy currently is revealing a cloaked or burrowed unit.\n\n        UnitMemoryManager\n\n        Returns:\n            Boolean if unit is detected.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_MEMORY_MANAGER,\n            ManagerRequestType.GET_IS_DETECTED,\n            **kwargs,\n        )\n\n    \"\"\"\n    UnitRoleManager\n    \"\"\"\n\n    def assign_role(self, **kwargs) -&gt; None:\n        \"\"\"Assign a unit a role.\n\n        UnitRoleManager\n\n        Parameters:\n            tag (int): Tag of the unit to be assigned.\n            role (UnitRole): What role the unit should have.\n            remove_from_squad (bool, optional): Attempt to remove\n                this unit from squad bookkeeping. Default is True.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_ROLE_MANAGER,\n            ManagerRequestType.ASSIGN_ROLE,\n            **kwargs,\n        )\n\n    def batch_assign_role(self, **kwargs) -&gt; None:\n        \"\"\"Assign a given role to a List of unit tags.\n\n        Nothing more than a for loop, provided for convenience.\n\n        UnitRoleManager\n\n        Parameters:\n            tags (Set[int]): Tags of the units to assign to a role.\n            role (UnitRole): The role the units should be assigned to.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_ROLE_MANAGER,\n            ManagerRequestType.BATCH_ASSIGN_ROLE,\n            **kwargs,\n        )\n\n    def clear_role(self, **kwargs) -&gt; None:\n        \"\"\"Clear a unit's role.\n\n        UnitRoleManager\n\n        Parameters:\n            tag (int): Tag of the unit to clear the role of.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_ROLE_MANAGER, ManagerRequestType.CLEAR_ROLE, **kwargs\n        )\n\n    def get_all_from_roles_except(self, **kwargs) -&gt; Units:\n        \"\"\"Get all units from the given roles except for unit types in excluded.\n\n        UnitRoleManager\n\n        Parameters:\n            roles (Set[UnitRole]): Roles to get units from.\n            excluded (Set[UnitTypeId]): Unit types that should not be included.\n\n        Returns:\n            Units matching the role that are not of an excluded type.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_ROLE_MANAGER,\n            ManagerRequestType.GET_ALL_FROM_ROLES_EXCEPT,\n            **kwargs,\n        )\n\n    @property\n    def get_unit_role_dict(self) -&gt; Dict[UnitRole, Set[int]]:\n        \"\"\"Get the dictionary of `UnitRole` to the set of tags of units with that role.\n\n        UnitRoleManager\n\n        Returns:\n            Dictionary of `UnitRole` to the set of tags of units with that role.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_ROLE_MANAGER, ManagerRequestType.GET_UNIT_ROLE_DICT\n        )\n\n    def get_units_from_role(self, **kwargs) -&gt; Units:\n        \"\"\"Get a Units object containing units with a given role.\n\n        If a UnitID or set of UnitIDs are given, it will only return units of those\n        types, otherwise it will return all units with the role. If `restrict_to` is\n        specified, it will only retrieve units from that object.\n\n        UnitRoleManager\n\n        Parameters:\n            role (UnitRole): Role to get units from.\n            unit_type (UnitTypeId): Type(s) of units that should be returned.\n                If omitted, all units with the role will be returned.\n            restrict_to (Set[UnitTypeId]): If supplied, only take Units\n                with the given role and type if they also exist here.\n\n        Returns:\n            Units with the given role.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_ROLE_MANAGER,\n            ManagerRequestType.GET_UNITS_FROM_ROLE,\n            **kwargs,\n        )\n\n    def get_units_from_roles(self, **kwargs) -&gt; Units:\n        \"\"\"Get the units matching `unit_type` from the given roles.\n\n        UnitRoleManager\n\n        Parameters:\n            roles (Set[UnitRole]): Roles to get units from.\n            unit_type (UnitTypeId): Type(s) of units that should be returned.\n                If omitted, all units with the role will be returned.\n\n        Returns:\n            Units with the given roles.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_ROLE_MANAGER,\n            ManagerRequestType.GET_UNITS_FROM_ROLES,\n            **kwargs,\n        )\n\n    def set_workers_per_gas(self, **kwargs) -&gt; None:\n        \"\"\"Give all units in a role a different role.\n\n        ResourceManager\n\n        Parameters\n        ----------\n        amount (int): Num workers to assign to each gas building\n        \"\"\"\n        return self.manager_request(\n            ManagerName.RESOURCE_MANAGER,\n            ManagerRequestType.SET_WORKERS_PER_GAS,\n            **kwargs,\n        )\n\n    def switch_roles(self, **kwargs) -&gt; None:\n        \"\"\"Give all units in a role a different role.\n\n        UnitRoleManager\n\n        Parameters:\n            from_role (UnitRole): Role the units currently have.\n            to_role (UnitRole): Role to assign to the units.\n        \"\"\"\n        return self.manager_request(\n            ManagerName.UNIT_ROLE_MANAGER,\n            ManagerRequestType.SWITCH_ROLES,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_air_avoidance_grid","title":"<code>get_air_avoidance_grid</code>  <code>property</code>","text":"<p>Get the air avoidance pathing grid. Any tile with a value greater than one will contain some dangerous effects or spells that should always be avoided. Such as storms, nukes, ravager biles etc...</p> <p>GridManager</p> <p>Example: <pre><code>import numpy as np\n\navoidance_grid: np.ndarray = self.mediator.get_air_avoidance_grid\n</code></pre></p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The air avoidance pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_air_grid","title":"<code>get_air_grid</code>  <code>property</code>","text":"<p>Get the air pathing grid.</p> <p>Pathable tiles have a value of 1.0 Pathable tiles with enemy influence have a value &gt; 1.0     The higher the value, the more influence there is. Non-pathable tiles have a value of np.inf</p> <p>GridManager</p> <p>Example: <pre><code>import numpy as np\n\nair_grid: np.ndarray = self.mediator.get_air_grid\n</code></pre></p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The air pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_air_vs_ground_grid","title":"<code>get_air_vs_ground_grid</code>  <code>property</code>","text":"<p>Get the air vs ground pathing grid. (air grid)</p> <p>grid is computed in a way that lowers the cost of nonpathable terrain for ground units, making air units naturally \"drawn\" to it.</p> <p>Pathable tiles have a value of 1.0 Pathable tiles with enemy influence have a value &gt; 1.0     The higher the value, the more influence there is. Non-pathable tiles have a value of np.inf</p> <p>GridManager</p> <p>Example: <pre><code>import numpy as np\n\nair_vs_ground_grid: np.ndarray = (\n    self.mediator.get_air_vs_ground_grid\n)\n</code></pre></p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The air vs ground pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_all_enemy","title":"<code>get_all_enemy</code>  <code>property</code>","text":"<p>Get all enemy units.</p> <p>UnitMemoryManager</p> <p>Returns:</p> Type Description <code>Units</code> <p>All enemy units.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_banned_nydus_travellers","title":"<code>get_banned_nydus_travellers</code>  <code>property</code>","text":"<p>Get the nydus travellers dictionary.</p> <p>NydusManager</p> <p>Returns:</p> Type Description <code>dict[int, float]</code> <p>Dictionary where key is unit tag, and value is info</p> <code>dict[int, float]</code> <p>about the nydus travellers.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_building_counter","title":"<code>get_building_counter</code>  <code>property</code>","text":"<p>Get a dictionary containing the number of each type of building in progress.</p> <p>BuildingManager.</p> <p>Returns:</p> Type Description <code>DefaultDict[UnitTypeId, int]</code> <p>DefaultDict[UnitTypeId, int]: Number of each type of UnitTypeId currently being tracked for building.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_building_tracker_dict","title":"<code>get_building_tracker_dict</code>  <code>property</code>","text":"<p>Get the building tracker dictionary.</p> <p>Building Manager.</p> <p>Returns:</p> Type Description <code>dict[int, dict[str, Union[Point2, Unit, UnitTypeId, float]]]</code> <p>dict[int, dict[str, Union[Point2, Unit, UnitTypeId, float]]]: Tracks the worker tag to details such as the UnitTypeId of the building, the Point2 location for placement, the in-game time when the order started, and the purpose of the building.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_cached_enemy_army","title":"<code>get_cached_enemy_army</code>  <code>property</code>","text":"<p>Get the Units object for the enemy army.</p> <p>UnitCacheManager</p> <p>Returns:</p> Type Description <code>Units</code> <p>The enemy army.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_cached_enemy_workers","title":"<code>get_cached_enemy_workers</code>  <code>property</code>","text":"<p>Get the Units object for the enemy workers.</p> <p>UnitCacheManager</p> <p>Returns:</p> Type Description <code>Units</code> <p>The enemy workers.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_cached_ground_grid","title":"<code>get_cached_ground_grid</code>  <code>property</code>","text":"<p>Get a non-influence ground pathing grid.</p> <p>GridManager</p> <p>Example: <pre><code>import numpy as np\n\ncached_ground_grid: np.ndarray = (\n    self.mediator.get_cached_ground_grid\n)\n</code></pre></p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The clean ground pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_climber_grid","title":"<code>get_climber_grid</code>  <code>property</code>","text":"<p>Get the climber ground pathing grid for reapers and colossus. Pathable tiles have a value of 1.0 Pathable tiles with enemy influence have a value &gt; 1.0     The higher the value, the more influence there is. Non-pathable tiles have a value of np.inf</p> <p>GridManager</p> <p>Example: <pre><code>import numpy as np\n\nclimber_grid: np.ndarray = (\n    self.mediator.get_climber_grid\n)\n</code></pre></p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The climber pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_creep_coverage","title":"<code>get_creep_coverage</code>  <code>property</code>","text":"<p>How much of the map is covered by creep?</p> <p>CreepManager</p> <p>Returns:</p> Type Description <code>float</code> <p>A float between 0.0 and 100.0 indicating the coverage of the map.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_creep_edges","title":"<code>get_creep_edges</code>  <code>property</code>","text":"<p>Fetches the edges of the detected creep on the map.</p> <p>CreepManager</p> <p>The returned value represents the creep edges in the form of NumPy arrays.</p> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>tuple of numpy.ndarray A tuple containing two NumPy arrays. Reflecting the coordinates of the creep edges.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_creep_grid","title":"<code>get_creep_grid</code>  <code>property</code>","text":"<p>Get the creep grid. Creep tiles have a value of 1.0 Non creep tiles have any other value.</p> <p>CreepManager</p> <p>Example: <pre><code>import numpy as np\n\ncreep_grid: np.ndarray = (\n    self.mediator.get_creep_grid\n)\n</code></pre></p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The creep grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_creep_tiles","title":"<code>get_creep_tiles</code>  <code>property</code>","text":"<p>Get creep tiles.</p> <p>CreepManager</p> <p>Example: <pre><code>import numpy as np\n\ncreep_tiles: np.ndarray = (\n    self.mediator.get_creep_tiles\n)\n</code></pre></p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Coordinates of all creep tiles on the map.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_defensive_third","title":"<code>get_defensive_third</code>  <code>property</code>","text":"<p>Get the third furthest from enemy.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Location of the third base furthest from the enemy.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_did_enemy_rush","title":"<code>get_did_enemy_rush</code>  <code>property</code>","text":"<p>Determines whether the enemy executed a rush strategy based on the intel manager's evaluation.</p> <p>WARNING: Super opinionated!</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_did_enemy_rush--returns","title":"Returns","text":"<p>bool     True if the enemy performed a rush strategy, otherwise False.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_army_dict","title":"<code>get_enemy_army_dict</code>  <code>property</code>","text":"<p>Get the dictionary of enemy army unit types to the units themselves.</p> <p>UnitCacheManager</p> <p>Returns:</p> Type Description <code>DefaultDict[UnitTypeId, Units]</code> <p>The dictionary of enemy army unit types to the units themselves.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_expanded","title":"<code>get_enemy_expanded</code>  <code>property</code>","text":"<p>Has the enemy expanded?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>bool</code> <p>Has enemy expanded out of their main?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_expansions","title":"<code>get_enemy_expansions</code>  <code>property</code>","text":"<p>Get the expansions, as ordered from the enemy's point of view.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>list[Tuple[Point2, float]]</code> <p>list[Tuple[Point2, float]]: The first element is the location of the base. The second element is the pathing distance from the enemy main base.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_fliers","title":"<code>get_enemy_fliers</code>  <code>property</code>","text":"<p>Get enemy flying units.</p> <p>UnitMemoryManager</p> <p>Returns:</p> Type Description <code>Units</code> <p>Enemy flying units.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_four_gate","title":"<code>get_enemy_four_gate</code>  <code>property</code>","text":"<p>Has the enemy gone four gate?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>bool</code> <p>Is enemy four gate?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_fourth","title":"<code>get_enemy_fourth</code>  <code>property</code>","text":"<p>Get the enemy fourth base.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Location of the enemy fourth base.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_ground","title":"<code>get_enemy_ground</code>  <code>property</code>","text":"<p>Get enemy ground units.</p> <p>UnitMemoryManager</p> <p>Returns:</p> Type Description <code>Units</code> <p>Enemy ground units.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_has_base_outside_natural","title":"<code>get_enemy_has_base_outside_natural</code>  <code>property</code>","text":"<p>Has the enemy expanded outside of their natural?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>bool</code> <p>Has enemy expanded out of natural?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_ling_rushed","title":"<code>get_enemy_ling_rushed</code>  <code>property</code>","text":"<p>Has the enemy ling rushed?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>bool</code> <p>Enemy ling rushed?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_main_nydus_points","title":"<code>get_enemy_main_nydus_points</code>  <code>property</code>","text":"<p>Get the optimal position for a nydus in enemy main, considering distance from base and ramp.</p> <p>NydusManager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Potential nydus position.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_marauder_rush","title":"<code>get_enemy_marauder_rush</code>  <code>property</code>","text":"<p>Is the enemy currently marauder rushing?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>bool</code> <p>Enemy marauder rush?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_marine_rush","title":"<code>get_enemy_marine_rush</code>  <code>property</code>","text":"<p>Is the enemy currently marine rushing?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>bool</code> <p>Enemy marine rushed?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_nat","title":"<code>get_enemy_nat</code>  <code>property</code>","text":"<p>Get the enemy natural expansion.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Location of the enemy natural expansion.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_ramp","title":"<code>get_enemy_ramp</code>  <code>property</code>","text":"<p>Get the enemy main base ramp.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>Ramp</code> <p>sc2 Ramp object for the enemy main base ramp.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_ravager_rush","title":"<code>get_enemy_ravager_rush</code>  <code>property</code>","text":"<p>Has the enemy ravager rushed?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Enemy ravager rush?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_roach_rushed","title":"<code>get_enemy_roach_rushed</code>  <code>property</code>","text":"<p>Did the enemy roach rush?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Enemy roach rushed?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_third","title":"<code>get_enemy_third</code>  <code>property</code>","text":"<p>Get the enemy third base.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Location of the enemy third base.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_tree","title":"<code>get_enemy_tree</code>  <code>property</code>","text":"<p>Get the KDTree representing all enemy unit positions.</p> <p>UnitMemoryManager</p> <p>Returns:</p> Type Description <code>KDTree</code> <p>KDTree representing all enemy unit positions.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_was_greedy","title":"<code>get_enemy_was_greedy</code>  <code>property</code>","text":"<p>Was the enemy greedy?</p> <p>WARNING: Currently not working, will always return <code>False</code> WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Enemy was greedy?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_went_four_gate","title":"<code>get_enemy_went_four_gate</code>  <code>property</code>","text":"<p>The enemy went four gate this game?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Enemy went four gate in this game?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_went_marauder_rush","title":"<code>get_enemy_went_marauder_rush</code>  <code>property</code>","text":"<p>The enemy went marauder rush this game?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Enemy went marauder rush in this game?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_went_marine_rush","title":"<code>get_enemy_went_marine_rush</code>  <code>property</code>","text":"<p>The enemy went marine rush this game?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Enemy went marine rush in this game?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_went_reaper","title":"<code>get_enemy_went_reaper</code>  <code>property</code>","text":"<p>The enemy opened with reaper this game?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Enemy went reaper in this game?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_enemy_worker_rushed","title":"<code>get_enemy_worker_rushed</code>  <code>property</code>","text":"<p>The enemy went for a worker rush this game?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Enemy went worker rush in this game?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_flying_enemy_near_bases","title":"<code>get_flying_enemy_near_bases</code>  <code>property</code>","text":"<p>Get dictionary containing flying enemy near townhalls.</p> <p>EnemyToBase Manager</p> <p>Returns:</p> Type Description <code>dict[int, set[int]]</code> <p>dict[int, set[int]]: A dictionary mapping townhall tags (keys) to sets of  enemy tags (values) near each base.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_flying_structure_tracker","title":"<code>get_flying_structure_tracker</code>  <code>property</code>","text":"<p>Get the current information stored by FlyingStructureManager.</p> <p>FlyingStructureManager</p> <p>Returns:</p> Type Description <code>dict[int, Any]</code> <p>Key -&gt; structure_tag, Value -&gt; Information about the flight.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_forcefield_positions","title":"<code>get_forcefield_positions</code>  <code>property</code>","text":"<p>Get positions of forcefields.</p> <p>GridManager</p> <p>Example: <pre><code>from sc2.position import Point2\n\nff_positions: list[Point2] = self.mediator.get_forcefield_positions\n</code></pre></p> <p>Returns:</p> Type Description <code>list[Point2]</code> <p>List of the center point of forcefields.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_ground_avoidance_grid","title":"<code>get_ground_avoidance_grid</code>  <code>property</code>","text":"<p>Get the ground avoidance pathing grid. Any tile with a value greater than one will contain some dangerous effects or spells that should always be avoided. Such as storms, nukes, ravager biles etc...</p> <p>GridManager</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ground avoidance pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_ground_enemy_near_bases","title":"<code>get_ground_enemy_near_bases</code>  <code>property</code>","text":"<p>Get dictionary containing ground enemy near townhalls.</p> <p>EnemyToBase Manager</p> <p>Returns:</p> Type Description <code>dict[int, set[int]]</code> <p>dict[int, set[int]]: A dictionary where the integer key is a townhall tag. And the value contains a set of ints containing enemy tags near this base.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_ground_grid","title":"<code>get_ground_grid</code>  <code>property</code>","text":"<p>Get the ground pathing grid. Pathable tiles have a value of 1.0 Pathable tiles with enemy influence have a value &gt; 1.0     The higher the value, the more influence there is. Non-pathable tiles have a value of np.inf</p> <p>GridManager</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ground pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_ground_to_air_grid","title":"<code>get_ground_to_air_grid</code>  <code>property</code>","text":"<p>Get an air grid that contains influence for ground dangers that can shoot air. This can be useful for keeping air units safe that can't attack ground units.</p> <p>Pathable tiles have a value of 1.0 Pathable tiles with enemy influence have a value &gt; 1.0     The higher the value, the more influence there is. Non-pathable tiles have a value of np.inf</p> <p>GridManager</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ground pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_initial_pathing_grid","title":"<code>get_initial_pathing_grid</code>  <code>property</code>","text":"<p>Get the pathing grid as it was on the first iteration.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The pathing grid as it was on the first iteration.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_is_free_expansion","title":"<code>get_is_free_expansion</code>  <code>property</code>","text":"<p>Check all bases for a free expansion.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if there exists a free expansion, False otherwise.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_is_proxy_zealot","title":"<code>get_is_proxy_zealot</code>  <code>property</code>","text":"<p>There is currently proxy zealot attempt from enemy?</p> <p>WARNING: Opinionated method, please write your own if you don't agree with this decision.</p> <p>Intel Manager</p> <p>Returns:</p> Type Description <code>bool</code> <p>Enemy is attempting a proxy zealot rush?</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_main_air_threats_near_townhall","title":"<code>get_main_air_threats_near_townhall</code>  <code>property</code>","text":"<p>Get the main enemy air force near one of our bases.</p> <p>EnemyToBase Manager</p> <p>Returns:</p> Type Description <code>Units</code> <p>The largest enemy air force near our bases.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_main_ground_threats_near_townhall","title":"<code>get_main_ground_threats_near_townhall</code>  <code>property</code>","text":"<p>Get the main enemy ground force near one of our bases.</p> <p>EnemyToBase Manager</p> <p>Returns:</p> Type Description <code>Units</code> <p>The largest enemy ground force near our bases.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_map_choke_points","title":"<code>get_map_choke_points</code>  <code>property</code>","text":"<p>All the points on the map that compose choke points.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>set[Point2]</code> <p>All the points on the map that compose choke points.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_map_data_object","title":"<code>get_map_data_object</code>  <code>property</code>","text":"<p>Get the MapAnalyzer.MapData object being used.</p> <p>PathManager</p> <p>Returns:</p> Type Description <code>MapData</code> <p>The MapAnalyzer.MapData object being used.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_mineral_patch_to_list_of_workers","title":"<code>get_mineral_patch_to_list_of_workers</code>  <code>property</code>","text":"<p>Get a dictionary containing mineral tag to worker tags</p> <p>Resource Manager</p> <p>Returns:</p> Type Description <code>Dict[int, Set[int]]</code> <p>Dictionary where key is mineral tag, and value is workers assigned here.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_mineral_target_dict","title":"<code>get_mineral_target_dict</code>  <code>property</code>","text":"<p>Get position in front of each mineral.</p> <p>This position is used for speed mining, and is also useful for making sure worker is moved to the right side of a mineral.</p> <p>ResourceManager</p> <p>Returns:</p> Type Description <code>dict[int, Point2]</code> <p>Key -&gt; mineral tag, Value -&gt; Position</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_num_available_mineral_patches","title":"<code>get_num_available_mineral_patches</code>  <code>property</code>","text":"<p>Get the number available mineral fields.</p> <p>An available mineral field is one that is near a townhall and has fewer than two assigned workers.</p> <p>ResourceManager</p> <p>Returns:</p> Type Description <code>int</code> <p>Number available mineral fields.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_nydus_travellers_dict","title":"<code>get_nydus_travellers_dict</code>  <code>property</code>","text":"<p>Get the nydus travellers dictionary.</p> <p>NydusManager</p> <p>Returns:</p> Type Description <code>None</code> <p>Dictionary where key is unit tag, and value is info</p> <code>None</code> <p>about the nydus travellers.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_ol_spot_near_enemy_nat","title":"<code>get_ol_spot_near_enemy_nat</code>  <code>property</code>","text":"<p>Get the overlord spot nearest to the enemy natural.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Overlord spot near the enemy natural.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_ol_spots","title":"<code>get_ol_spots</code>  <code>property</code>","text":"<p>High ground Overlord hiding spots.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>list[Point2]</code> <p>List of Overlord hiding spots.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_old_own_army_dict","title":"<code>get_old_own_army_dict</code>  <code>property</code>","text":"<p>Get the previous iteration's <code>own_army</code> dict.</p> <p>UnitCacheManager</p> <p>Returns:</p> Type Description <code>Dict[UnitTypeId, Units]</code> <p>The dictionary of own army unit types to the units themselves.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_own_army","title":"<code>get_own_army</code>  <code>property</code>","text":"<p>Get the Units object for our own army.</p> <p>UnitCacheManager</p> <p>Returns:</p> Type Description <code>Units</code> <p>Our own army.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_own_army_dict","title":"<code>get_own_army_dict</code>  <code>property</code>","text":"<p>Get the dictionary of own army unit types to the units themselves.</p> <p>UnitCacheManager</p> <p>Returns:</p> Type Description <code>Dict[UnitTypeId, Units]</code> <p>The dictionary of own army unit types to the units themselves.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_own_expansions","title":"<code>get_own_expansions</code>  <code>property</code>","text":"<p>Get the expansions.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>list[Tuple[Point2, float]]</code> <p>List[Tuple[Point2, float]]: List of Tuples where The first element is the location of the base. The second element is the pathing distance from our main base.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_own_nat","title":"<code>get_own_nat</code>  <code>property</code>","text":"<p>Get our natural expansion.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Location of our natural expansion.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_own_structures_dict","title":"<code>get_own_structures_dict</code>  <code>property</code>","text":"<p>Get the dictionary of own structure types to the units themselves.</p> <p>UnitCacheManager</p> <p>Returns:</p> Type Description <code>DefaultDict[UnitTypeId, list[Unit]]</code> <p>The dictionary of own structure types to the units themselves.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_own_tree","title":"<code>get_own_tree</code>  <code>property</code>","text":"<p>Get the KDTree representing all friendly unit positions.</p> <p>UnitMemoryManager</p> <p>Returns:</p> Type Description <code>Units</code> <p>KDTree representing all friendly unit positions.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_placements_dict","title":"<code>get_placements_dict</code>  <code>property</code>","text":"<p>Get the placement dict ares calculated at beginning of the game.</p> <p>Structure of dictionary:</p> <p>base_loc is a Point2 key for every expansion location on map.</p> <pre><code>placement_dict = {\n    base_loc: Point2:\n        BuildingSize.TWO_BY_TWO: {\n            building_pos: Point2((2, 2)):\n                {\n                    available: True,\n                    has_addon: False\n                    taken: False,\n                    is_wall: True,\n                    building_tag: 0,\n                    worker_on_route: False,\n                    time_requested: 0.0,\n                    production_pylon: False,\n                    bunker: False,\n                    optimal_pylon: False\n                },\n                {...}\n        },\n        BuildingSize.THREE_BY_THREE: {\n            building_pos: Point2((5, 5)):\n                {\n                    available: True,\n                    has_addon: False\n                    taken: False,\n                    is_wall: True,\n                    building_tag: 0,\n                    worker_on_route: False,\n                    time_requested: 0.0,\n                    production_pylon: False,\n                    bunker: False,\n                    optimal_pylon: False\n                },\n                {...}\n        },\n    {...}\n}\n</code></pre> <p>PlacementManager</p> <p>Returns:</p> Type Description <code>dict</code> <p>Indicating if structure can be placed at given position.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_positions_blocked_by_burrowed_enemy","title":"<code>get_positions_blocked_by_burrowed_enemy</code>  <code>property</code>","text":"<p>Build positions that are blocked by a burrowed enemy unit.</p> <p>TerrainManager</p> <p>Returns:</p> Type Description <code>list[Point2]</code> <p>List of build positions that are blocked by a burrowed enemy unit.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_primary_nydus_enemy_main","title":"<code>get_primary_nydus_enemy_main</code>  <code>property</code>","text":"<p>Get the optimal position for a nydus in enemy main, considering distance from base and ramp.</p> <p>Nydus Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Potential nydus position.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_primary_nydus_own_main","title":"<code>get_primary_nydus_own_main</code>  <code>property</code>","text":"<p>Get the optimal position for a nydus in own main. Could be useful scouting position.</p> <p>Nydus Manager</p> <p>Returns:</p> Type Description <code>Point2</code> <p>Potential nydus position.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_priority_ground_avoidance_grid","title":"<code>get_priority_ground_avoidance_grid</code>  <code>property</code>","text":"<p>Get the pathing grid containing things ground units should always avoid.</p> <p>GridManager</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The priority ground avoidance pathing grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_pvz_nat_gatekeeping_pos","title":"<code>get_pvz_nat_gatekeeping_pos</code>  <code>property</code>","text":"<p>Get the gatekeeper position in a PvZ natural wall if available.</p> <p>WARNING: This can return <code>None</code> so your code should account for this.</p> <p>PlacementManager</p> <p>Returns:</p> Type Description <code>Union[Point2, None]</code> <p>Position of gatekeeper in natural wall</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_removed_units","title":"<code>get_removed_units</code>  <code>property</code>","text":"<p>Get the units removed from memory units.</p> <p>UnitCacheManager</p> <p>Returns:</p> Type Description <code>Units</code> <p>The units removed from memory units.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_tactical_ground_grid","title":"<code>get_tactical_ground_grid</code>  <code>property</code>","text":"<p>Get the tactical ground grid.</p> <p>Normal pathable tiles with no units on them have a value of 200.0</p> <p>Tiles with more enemy have value &gt; 200.0 Tiles with more friendly have value &lt; 200.0</p> <p>GridManager</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ground tactical grid.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_th_tag_with_largest_ground_threat","title":"<code>get_th_tag_with_largest_ground_threat</code>  <code>property</code>","text":"<p>Get the tag of our townhall with the largest enemy ground force nearby.</p> <p>WARNING: This will remember the townhall tag even if enemy has gone. Do not use this to detect enemy at a base. Use <code>get_main_ground_threats_near_townhall</code> Or <code>get_ground_enemy_near_bases</code> instead</p> <p>EnemyToBase Manager</p> <p>Returns:</p> Type Description <code>int</code> <p>The largest enemy ground force near our bases.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_unit_role_dict","title":"<code>get_unit_role_dict</code>  <code>property</code>","text":"<p>Get the dictionary of <code>UnitRole</code> to the set of tags of units with that role.</p> <p>UnitRoleManager</p> <p>Returns:</p> Type Description <code>Dict[UnitRole, Set[int]]</code> <p>Dictionary of <code>UnitRole</code> to the set of tags of units with that role.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_unit_to_ability_dict","title":"<code>get_unit_to_ability_dict</code>  <code>property</code>","text":"<p>Get a dictionary containing unit tag, to ability frame cooldowns.</p> <p>AbilityTrackerManager.</p> <p>Returns:</p> Type Description <code>dict[int, Any]</code> <p>Unit tag to abilities and the next frame they can be casted.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_whole_map_array","title":"<code>get_whole_map_array</code>  <code>property</code>","text":"<p>Get the list containing every point on the map.</p> <p>GridManager</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_whole_map_array--notes","title":"Notes","text":"<p>This does not return Point2s.</p> <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>Every point on the map.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_whole_map_tree","title":"<code>get_whole_map_tree</code>  <code>property</code>","text":"<p>Get the KDTree of all points on the map.</p> <p>PathManager</p> <p>Returns:</p> Type Description <code>KDTree</code> <p>KDTree of all points on the map.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_worker_tag_to_townhall_tag","title":"<code>get_worker_tag_to_townhall_tag</code>  <code>property</code>","text":"<p>Get a dictionary containing worker tag to townhall tag. Where the townhall is the place where worker returns resources</p> <p>Resource Manager</p> <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>Dictionary where key is worker tag, and value is townhall tag.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_worker_to_mineral_patch_dict","title":"<code>get_worker_to_mineral_patch_dict</code>  <code>property</code>","text":"<p>Get a dictionary containing worker tag to mineral patch tag.</p> <p>Resource Manager</p> <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>Dictionary where key is worker tag, and value is mineral tag.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_worker_to_vespene_dict","title":"<code>get_worker_to_vespene_dict</code>  <code>property</code>","text":"<p>Get a dictionary containing worker tag to gas building tag.</p> <p>Resource Manager</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary where key is worker tag, and value is gas building tag.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.add_managers","title":"<code>add_managers(managers)</code>","text":"<p>Generate manager dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>managers</code> <code>list['Manager']</code> <p>List of all Managers capable of handling ManagerRequests.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def add_managers(self, managers: list[\"Manager\"]) -&gt; None:  # noqa\n    \"\"\"Generate manager dictionary.\n\n    Parameters:\n        managers: List of all Managers capable of handling ManagerRequests.\n    \"\"\"\n    for manager in managers:\n        self.managers[str(type(manager).__name__)] = manager\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.add_to_nydus_travellers","title":"<code>add_to_nydus_travellers(**kwargs)</code>","text":"<p>Add a unit to the nydus travellers.</p> <p>NydusManager</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <p>Unit The unit to be added to the nydus travellers.</p> required <code>entry_nydus_tag</code> <p>int The tag of the nydus we are entering.</p> required <code>exit_nydus_tag</code> <p>int The tag of the nydus we are exiting.</p> required <code>exit_towards</code> <p>Point2 The direction out of the exit nydus.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def add_to_nydus_travellers(self, **kwargs) -&gt; None:\n    \"\"\"Add a unit to the nydus travellers.\n\n    NydusManager\n\n    Parameters:\n        unit: Unit\n            The unit to be added to the nydus travellers.\n        entry_nydus_tag: int\n            The tag of the nydus we are entering.\n        exit_nydus_tag: int\n            The tag of the nydus we are exiting.\n        exit_towards: Point2\n            The direction out of the exit nydus.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.NYDUS_MANAGER,\n        ManagerRequestType.ADD_TO_NYDUS_TRAVELLERS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.assign_role","title":"<code>assign_role(**kwargs)</code>","text":"<p>Assign a unit a role.</p> <p>UnitRoleManager</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>int</code> <p>Tag of the unit to be assigned.</p> required <code>role</code> <code>UnitRole</code> <p>What role the unit should have.</p> required <code>remove_from_squad</code> <code>bool</code> <p>Attempt to remove this unit from squad bookkeeping. Default is True.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def assign_role(self, **kwargs) -&gt; None:\n    \"\"\"Assign a unit a role.\n\n    UnitRoleManager\n\n    Parameters:\n        tag (int): Tag of the unit to be assigned.\n        role (UnitRole): What role the unit should have.\n        remove_from_squad (bool, optional): Attempt to remove\n            this unit from squad bookkeeping. Default is True.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_ROLE_MANAGER,\n        ManagerRequestType.ASSIGN_ROLE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.batch_assign_role","title":"<code>batch_assign_role(**kwargs)</code>","text":"<p>Assign a given role to a List of unit tags.</p> <p>Nothing more than a for loop, provided for convenience.</p> <p>UnitRoleManager</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>Set[int]</code> <p>Tags of the units to assign to a role.</p> required <code>role</code> <code>UnitRole</code> <p>The role the units should be assigned to.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def batch_assign_role(self, **kwargs) -&gt; None:\n    \"\"\"Assign a given role to a List of unit tags.\n\n    Nothing more than a for loop, provided for convenience.\n\n    UnitRoleManager\n\n    Parameters:\n        tags (Set[int]): Tags of the units to assign to a role.\n        role (UnitRole): The role the units should be assigned to.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_ROLE_MANAGER,\n        ManagerRequestType.BATCH_ASSIGN_ROLE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.build_with_specific_worker","title":"<code>build_with_specific_worker(**kwargs)</code>","text":"<p>Build a structure with a specific worker.</p> <p>BuildingManager.</p> <p>Parameters:</p> Name Type Description Default <code>worker</code> <code>Unit</code> <p>The chosen worker.</p> required <code>structure_type</code> <code>UnitTypeId</code> <p>What type of structure to build.</p> required <code>pos</code> <code>Point2</code> <p>Where the structure should be placed.</p> required <code>building_purpose</code> <code>BuildingPurpose</code> <p>Why the structure is being placed.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a position for the building is found and</p> <code>bool</code> <p>the worker is valid, otherwise False.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def build_with_specific_worker(self, **kwargs) -&gt; bool:\n    \"\"\"Build a structure with a specific worker.\n\n    BuildingManager.\n\n    Parameters:\n        worker (Unit): The chosen worker.\n        structure_type (UnitTypeId): What type of structure to build.\n        pos (Point2): Where the structure should be placed.\n        building_purpose (BuildingPurpose): Why the structure is being placed.\n\n    Returns:\n        bool: True if a position for the building is found and\n        the worker is valid, otherwise False.\n\n\n\n    \"\"\"\n    return self.manager_request(\n        ManagerName.BUILDING_MANAGER,\n        ManagerRequestType.BUILD_WITH_SPECIFIC_WORKER,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.building_position_blocked_by_burrowed_unit","title":"<code>building_position_blocked_by_burrowed_unit(**kwargs)</code>","text":"<p>See if the building position is blocked by a burrowed unit.</p> <p>TerrainManager</p> <p>Parameters:</p> Name Type Description Default <code>worker_tag</code> <code>int</code> <p>The worker attempting to build the structure.</p> required <code>position</code> <code>Point2</code> <p>Where the structure is attempting to be placed.</p> required <p>Returns:</p> Type Description <code>Optional[Point2]</code> <p>The position that's blocked by an enemy unit.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def building_position_blocked_by_burrowed_unit(self, **kwargs) -&gt; Optional[Point2]:\n    \"\"\"See if the building position is blocked by a burrowed unit.\n\n    TerrainManager\n\n    Parameters:\n        worker_tag (int): The worker attempting to build the structure.\n        position (Point2): Where the structure is attempting to be placed.\n\n    Returns:\n        The position that's blocked by an enemy unit.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.TERRAIN_MANAGER,\n        ManagerRequestType.BUILDING_POSITION_BLOCKED_BY_BURROWED_UNIT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.can_place_structure","title":"<code>can_place_structure(**kwargs)</code>","text":"<p>Check if structure can be placed at a given position.</p> <p>Faster cython alternative to <code>python-sc2</code> <code>await self.can_place()</code></p> <p>PlacementManager</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Point2</code> <p>The intended building position.</p> required <code>structure_type</code> <code>UnitTypeId</code> <p>Structure type we want to place.</p> required <code>include_addon</code> <code>bool</code> <p>For Terran structures, check addon will place too.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Indicating if structure can be placed at given position.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def can_place_structure(self, **kwargs) -&gt; bool:\n    \"\"\"Check if structure can be placed at a given position.\n\n    Faster cython alternative to `python-sc2` `await self.can_place()`\n\n    PlacementManager\n\n    Parameters:\n        position (Point2): The intended building position.\n        structure_type (UnitID): Structure type we want to place.\n        include_addon (bool, optional): For Terran structures,\n            check addon will place too.\n\n    Returns:\n        Indicating if structure can be placed at given position.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PLACEMENT_MANAGER,\n        ManagerRequestType.CAN_PLACE_STRUCTURE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.can_win_fight","title":"<code>can_win_fight(**kwargs)</code>","text":"<p>Get the predicted engagement result between two forces.</p> <p>Combat Sim Manager.</p> <p>Parameters:</p> Name Type Description Default <code>own_units</code> <code>Units</code> <p>Our units involved in the battle.</p> required <code>enemy_units</code> <code>Units</code> <p>The enemy units.</p> required <code>timing_adjust</code> <code>bool</code> <p>Whether to consider the distance between units.</p> required <code>good_positioning</code> <code>bool</code> <p>Whether to assume units are decently split.</p> required <code>workers_do_no_damage</code> <code>bool</code> <p>Whether to ignore workers' damage.</p> required <p>Returns:</p> Type Description <code>EngagementResult</code> <p>Enum indicating the human-readable engagement result.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def can_win_fight(self, **kwargs) -&gt; EngagementResult:\n    \"\"\"Get the predicted engagement result between two forces.\n\n    Combat Sim Manager.\n\n    Parameters:\n        own_units (Units): Our units involved in the battle.\n        enemy_units (Units): The enemy units.\n        timing_adjust (bool): Whether to consider the distance between units.\n        good_positioning (bool): Whether to assume units are decently split.\n        workers_do_no_damage (bool): Whether to ignore workers' damage.\n\n    Returns:\n        Enum indicating the human-readable engagement result.\n\n\n    \"\"\"\n    return self.manager_request(\n        ManagerName.COMBAT_SIM_MANAGER, ManagerRequestType.CAN_WIN_FIGHT, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.cancel_structure","title":"<code>cancel_structure(**kwargs)</code>","text":"<p>Cancel a structure and remove from internal ares bookkeeping.</p> <p>If you try cancelling without calling this method, ares may try to keep rebuilding the cancelled structure.</p> <p>BuildingManager.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Unit</code> <p>The actual structure to cancel.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def cancel_structure(self, **kwargs) -&gt; None:\n    \"\"\"Cancel a structure and remove from internal ares bookkeeping.\n\n    If you try cancelling without calling this method, ares may try\n    to keep rebuilding the cancelled structure.\n\n    BuildingManager.\n\n    Parameters:\n        structure (Unit): The actual structure to cancel.\n\n    \"\"\"\n    return self.manager_request(\n        ManagerName.BUILDING_MANAGER,\n        ManagerRequestType.CANCEL_STRUCTURE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.clear_nydus_travellers","title":"<code>clear_nydus_travellers(**kwargs)</code>","text":"<p>Clear the nydus travellers dictionary.</p> <p>NydusManager</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def clear_nydus_travellers(self, **kwargs) -&gt; None:\n    \"\"\"Clear the nydus travellers dictionary.\n\n    NydusManager\n    \"\"\"\n    return self.manager_request(\n        ManagerName.NYDUS_MANAGER,\n        ManagerRequestType.CLEAR_NYDUS_TRAVELLERS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.clear_role","title":"<code>clear_role(**kwargs)</code>","text":"<p>Clear a unit's role.</p> <p>UnitRoleManager</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>int</code> <p>Tag of the unit to clear the role of.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def clear_role(self, **kwargs) -&gt; None:\n    \"\"\"Clear a unit's role.\n\n    UnitRoleManager\n\n    Parameters:\n        tag (int): Tag of the unit to clear the role of.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_ROLE_MANAGER, ManagerRequestType.CLEAR_ROLE, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_closest_safe_spot","title":"<code>find_closest_safe_spot(**kwargs)</code>","text":"<p>Find the closest point with the lowest cost on a grid.</p> <p>PathManager</p> <p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>Point2</code> <p>Where the search starts from.</p> required <code>grid</code> <code>ndarray</code> <p>The grid to find the low-cost point on.</p> required <code>radius</code> <code>float</code> <p>How far away the safe point can be.</p> required <p>Returns:</p> Type Description <code>Point2</code> <p>The closest location with the lowest cost.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def find_closest_safe_spot(self, **kwargs) -&gt; Point2:\n    \"\"\"Find the closest point with the lowest cost on a grid.\n\n    PathManager\n\n    Parameters:\n        from_pos (Point2): Where the search starts from.\n        grid (np.ndarray): The grid to find the low-cost point on.\n        radius (float): How far away the safe point can be.\n\n    Returns:\n        The closest location with the lowest cost.\n\n\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PATH_MANAGER, ManagerRequestType.GET_CLOSEST_SAFE_SPOT, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_low_priority_path","title":"<code>find_low_priority_path(**kwargs)</code>","text":"<p>Find several points in a path.</p> <p>This way a unit can queue them up all at once for performance reasons.</p> <p>i.e. running drones from a base or sending an overlord to a new position.</p> <p>This does not return every point in the path. Instead, it returns points spread along the path.</p> <p>PathManager</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Point2</code> <p>Start point of the path.</p> required <code>target</code> <code>Point2</code> <p>Desired end point of the path.</p> required <code>grid</code> <code>ndarray</code> <p>The grid that should be used for pathing.</p> required <p>Returns:</p> Type Description <code>list[Point2]</code> <p>List of points composing the path.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def find_low_priority_path(self, **kwargs) -&gt; list[Point2]:\n    \"\"\"Find several points in a path.\n\n    This way a unit can queue them up all at once for performance reasons.\n\n    i.e. running drones from a base or sending an overlord to a new position.\n\n    This does not return every point in the path. Instead, it returns points spread\n    along the path.\n\n    PathManager\n\n    Parameters:\n        start (Point2): Start point of the path.\n        target (Point2): Desired end point of the path.\n        grid (np.ndarray): The grid that should be used for pathing.\n\n    Returns:\n        List of points composing the path.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PATH_MANAGER,\n        ManagerRequestType.FIND_LOW_PRIORITY_PATH,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_lowest_cost_points","title":"<code>find_lowest_cost_points(**kwargs)</code>","text":"<p>Find the point(s) with the lowest cost within <code>radius</code> from <code>from_pos</code>.</p> <p>PathManager</p> <p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>Point2</code> <p>Point to start the search from.</p> required <code>radius</code> <code>float</code> <p>How far away the returned points can be.</p> required <code>grid</code> <code>ndarray</code> <p>Which grid to query for lowest cost points.</p> required <p>Returns:</p> Type Description <code>list[Point2]</code> <p>Points with the lowest cost on the grid.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def find_lowest_cost_points(self, **kwargs) -&gt; list[Point2]:\n    \"\"\"Find the point(s) with the lowest cost within `radius` from `from_pos`.\n\n    PathManager\n\n    Parameters:\n        from_pos (Point2): Point to start the search from.\n        radius (float): How far away the returned points can be.\n        grid (np.ndarray): Which grid to query for lowest cost points.\n\n    Returns:\n        Points with the lowest cost on the grid.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PATH_MANAGER,\n        ManagerRequestType.FIND_LOWEST_COST_POINTS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_nearby_creep_edge_position","title":"<code>find_nearby_creep_edge_position(**kwargs)</code>","text":"<p>Find the nearest position on the edge of the creep nearby a given point.</p> <p>This function is used to determine a position that lies at the edge of the creep, in proximity to a reference point within a game map scenario. The edge of the creep refers to the boundary or border of an area covered by creep, a terrain-modifying biome commonly associated with certain game mechanics.</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_nearby_creep_edge_position--parameters","title":"Parameters","text":"<p>position : Point2     Where to search from search_radius: float     How far to search for creep edge position. closest_valid: bool     If True find the closest valid edge tile from <code>position</code>.     Else find the furthest     Default is True. spread_dist: float     How much distance between existing tumors?     Default is 4.0 unit_tag : int | None, optional     Unit tag to check if queen ability is available, by default None cache_result : bool, optional     Should we cache the result to save computation?     unit_tag should be set if this is True     by default False</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_nearby_creep_edge_position--returns","title":"Returns","text":"<p>Point2 | None     The coordinates of the nearest position at the edge of the creep.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def find_nearby_creep_edge_position(self, **kwargs) -&gt; Point2 | None:\n    \"\"\"\n    Find the nearest position on the edge of the creep nearby a given point.\n\n    This function is used to determine a position that lies at the edge of the\n    creep, in proximity to a reference point within a game map scenario. The edge\n    of the creep refers to the boundary or border of an area covered by creep,\n    a terrain-modifying biome commonly associated with certain game mechanics.\n\n    Parameters\n    ----------\n    position : Point2\n        Where to search from\n    search_radius: float\n        How far to search for creep edge position.\n    closest_valid: bool\n        If True find the closest valid edge tile from `position`.\n        Else find the furthest\n        Default is True.\n    spread_dist: float\n        How much distance between existing tumors?\n        Default is 4.0\n    unit_tag : int | None, optional\n        Unit tag to check if queen ability is available, by default None\n    cache_result : bool, optional\n        Should we cache the result to save computation?\n        unit_tag should be set if this is True\n        by default False\n\n    Returns\n    -------\n    Point2 | None\n        The coordinates of the nearest position at the edge of the creep.\n\n    \"\"\"\n    return self.manager_request(\n        ManagerName.CREEP_MANAGER,\n        ManagerRequestType.FIND_NEARBY_CREEP_EDGE_POSITION,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_nydus_at_location","title":"<code>find_nydus_at_location(**kwargs)</code>","text":"<p>Given a location, find a potential nydus canal placement. Tries to avoid enemy visibility. Prioritizes locations that are already visible. Passing in a base location is recommended. But any position should work.</p> This only gives an idea where to place a nydus canal. <p>You still need to calculate a valid building placement, which might mean the actual valid canal location is slightly different.</p> This calculates placements out of vision if needed, so you <p>may need to send a scout before the canal can be placed.</p> <p>Find a Nydus position with pathing cost less than max_cost in a region containing the given point, at least min_distance from an enemy base and no more than max_distance from the target point.</p> <p>NydusManager</p> <p>Parameters:</p> Name Type Description Default <code>base_location</code> <p>Point2</p> required <code>min_base_distance</code> <p>float</p> required <code>max_nydus_distance</code> <p>float</p> required <code>max_cost</code> <p>int</p> required <p>Returns:</p> Type Description <code>Point2 | None</code> <p>May return a location to be used for a nydus canal.</p> <code>Point2 | None</code> <p>Could return None.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def find_nydus_at_location(self, **kwargs) -&gt; Point2 | None:\n    \"\"\"Given a location, find a potential nydus canal placement.\n    Tries to avoid enemy visibility.\n    Prioritizes locations that are already visible.\n    Passing in a base location is recommended. But any position should work.\n\n    WARNING: This only gives an idea where to place a nydus canal.\n        You still need to calculate a valid building placement, which might\n        mean the actual valid canal location is slightly different.\n\n    WARNING: This calculates placements out of vision if needed, so you\n        may need to send a scout before the canal can be placed.\n\n    Find a Nydus position with pathing cost less than max_cost in a region\n    containing the given point, at least min_distance from an enemy base and\n    no more than max_distance from the target point.\n\n    NydusManager\n\n    Parameters:\n        base_location: Point2\n        min_base_distance: float\n        max_nydus_distance: float\n        max_cost: int\n\n    Returns:\n        May return a location to be used for a nydus canal.\n        Could return None.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.NYDUS_MANAGER,\n        ManagerRequestType.FIND_NYDUS_AT_LOCATION,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_nydus_path_next_point","title":"<code>find_nydus_path_next_point(**kwargs)</code>","text":"<p>Find the next point in a path including via nyduses.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Point2</code> <p>Start point of the path.</p> required <code>target</code> <code>Point2</code> <p>Desired end point of the path.</p> required <code>grid</code> <code>ndarray</code> <p>The grid that should be used for pathing.</p> required <code>sensitivity</code> <code>int</code> <p>Amount of points that should be skipped in the full path between tiles that are returned. Default value is 5.</p> required <code>smoothing</code> <code>bool</code> <p>Optional path smoothing where nodes are removed if it's possible to jump ahead some tiles in a straight line with a lower cost. Default value is False.</p> required <code>sense_danger</code> <code>bool</code> <p>Check to see if there are any dangerous tiles near the starting point. If this is True and there are no dangerous tiles near the starting point, the pathing query is skipped and the target is returned. Default value is True.</p> required <code>danger_distance</code> <code>float</code> <p>How far away from the start to look for danger. Default value is 20.</p> required <code>danger_threshold</code> <code>float</code> <p>Minimum value for a tile to be considered dangerous. Default value is 5.</p> required <p>Returns:</p> Type Description <code>tuple[Point2 | None, Point2 | None, list[int] | None]</code> <p>Tuple of (next_point, nydus_next_point, nydus_points)</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def find_nydus_path_next_point(\n    self, **kwargs\n) -&gt; tuple[Point2 | None, Point2 | None, list[int] | None]:\n    \"\"\"Find the next point in a path including via nyduses.\n\n    Parameters:\n        start (Point2): Start point of the path.\n        target (Point2): Desired end point of the path.\n        grid (np.ndarray): The grid that should be used for pathing.\n        sensitivity (int, optional): Amount of points that should be\n            skipped in the full path between tiles that are returned.\n            Default value is 5.\n        smoothing (bool, optional): Optional path smoothing where nodes are\n            removed if it's possible to jump ahead some tiles in\n            a straight line with a lower cost.\n            Default value is False.\n        sense_danger (bool, optional): Check to see if there are any\n            dangerous tiles near the starting point. If this is True and\n            there are no dangerous tiles near the starting point,\n            the pathing query is skipped and the target is returned.\n            Default value is True.\n        danger_distance (float, optional): How far away from the\n            start to look for danger.\n            Default value is 20.\n        danger_threshold (float, optional): Minimum value for a tile\n            to be considered dangerous.\n            Default value is 5.\n\n    Returns:\n        Tuple of (next_point, nydus_next_point, nydus_points)\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PATH_MANAGER, ManagerRequestType.NYDUS_PATH_NEXT_POINT, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_path_next_point","title":"<code>find_path_next_point(**kwargs)</code>","text":"<p>Find the next point in a path.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Point2</code> <p>Start point of the path.</p> required <code>target</code> <code>Point2</code> <p>Desired end point of the path.</p> required <code>grid</code> <code>ndarray</code> <p>The grid that should be used for pathing.</p> required <code>sensitivity</code> <code>int</code> <p>Amount of points that should be skipped in the full path between tiles that are returned. Default value is 5.</p> required <code>smoothing</code> <code>bool</code> <p>Optional path smoothing where nodes are removed if it's possible to jump ahead some tiles in a straight line with a lower cost. Default value is False.</p> required <code>sense_danger</code> <code>bool</code> <p>Check to see if there are any dangerous tiles near the starting point. If this is True and there are no dangerous tiles near the starting point, the pathing query is skipped and the target is returned. Default value is True.</p> required <code>danger_distance</code> <code>float</code> <p>How far away from the start to look for danger. Default value is 20.</p> required <code>danger_threshold</code> <code>float</code> <p>Minimum value for a tile to be considered dangerous. Default value is 5.</p> required <p>Returns:</p> Type Description <code>Point2</code> <p>The next point in the path from the start to the target which may be the</p> <code>Point2</code> <p>same as the target if it's safe.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def find_path_next_point(self, **kwargs) -&gt; Point2:\n    \"\"\"Find the next point in a path.\n\n    Parameters:\n        start (Point2): Start point of the path.\n        target (Point2): Desired end point of the path.\n        grid (np.ndarray): The grid that should be used for pathing.\n        sensitivity (int, optional): Amount of points that should be\n            skipped in the full path between tiles that are returned.\n            Default value is 5.\n        smoothing (bool, optional): Optional path smoothing where nodes are\n            removed if it's possible to jump ahead some tiles in\n            a straight line with a lower cost.\n            Default value is False.\n        sense_danger (bool, optional): Check to see if there are any\n            dangerous tiles near the starting point. If this is True and\n            there are no dangerous tiles near the starting point,\n            the pathing query is skipped and the target is returned.\n            Default value is True.\n        danger_distance (float, optional): How far away from the\n            start to look for danger.\n            Default value is 20.\n        danger_threshold (float, optional): Minimum value for a tile\n            to be considered dangerous.\n            Default value is 5.\n\n    Returns:\n        The next point in the path from the start to the target which may be the\n        same as the target if it's safe.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PATH_MANAGER, ManagerRequestType.PATH_NEXT_POINT, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.find_raw_path","title":"<code>find_raw_path(**kwargs)</code>","text":"<p>Used for finding a full path, mostly for distance checks.</p> <p>PathManager</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Point2</code> <p>Start point of the path.</p> required <code>target</code> <code>Point2</code> <p>Desired end point of the path.</p> required <code>grid</code> <code>ndarray</code> <p>The grid that should be used for pathing.</p> required <code>sensitivity</code> <code>int</code> <p>Amount of points that should be skipped in the full path between tiles that are returned.</p> required <p>Returns:</p> Type Description <code>list[Point2]</code> <p>List of points composing the path.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def find_raw_path(self, **kwargs) -&gt; list[Point2]:\n    \"\"\"Used for finding a full path, mostly for distance checks.\n\n    PathManager\n\n    Parameters:\n        start (Point2): Start point of the path.\n        target (Point2): Desired end point of the path.\n        grid (np.ndarray): The grid that should be used for pathing.\n        sensitivity (int): Amount of points that should be skipped in\n            the full path between tiles that are returned.\n\n    Returns:\n        List of points composing the path.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PATH_MANAGER, ManagerRequestType.FIND_RAW_PATH, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_all_from_roles_except","title":"<code>get_all_from_roles_except(**kwargs)</code>","text":"<p>Get all units from the given roles except for unit types in excluded.</p> <p>UnitRoleManager</p> <p>Parameters:</p> Name Type Description Default <code>roles</code> <code>Set[UnitRole]</code> <p>Roles to get units from.</p> required <code>excluded</code> <code>Set[UnitTypeId]</code> <p>Unit types that should not be included.</p> required <p>Returns:</p> Type Description <code>Units</code> <p>Units matching the role that are not of an excluded type.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_all_from_roles_except(self, **kwargs) -&gt; Units:\n    \"\"\"Get all units from the given roles except for unit types in excluded.\n\n    UnitRoleManager\n\n    Parameters:\n        roles (Set[UnitRole]): Roles to get units from.\n        excluded (Set[UnitTypeId]): Unit types that should not be included.\n\n    Returns:\n        Units matching the role that are not of an excluded type.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_ROLE_MANAGER,\n        ManagerRequestType.GET_ALL_FROM_ROLES_EXCEPT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_any_enemies_in_range","title":"<code>get_any_enemies_in_range(**kwargs)</code>","text":"<p>Check various positions for any enemy units in range.</p> <p>UnitMemoryManager</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <p>list[Point2]</p> required <code>radius</code> <p>float</p> required <p>Returns:</p> Type Description <code>Units</code> <p>list of bool for each position</p> <code>Units</code> <p>True would mean something is there</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_any_enemies_in_range(self, **kwargs) -&gt; Units:\n    \"\"\"Check various positions for any enemy units in range.\n\n    UnitMemoryManager\n\n    Parameters:\n        positions: list[Point2]\n        radius: float\n\n    Returns:\n        list of bool for each position\n        True would mean something is there\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_MEMORY_MANAGER,\n        ManagerRequestType.GET_ANY_ENEMY_IN_RANGE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_behind_mineral_positions","title":"<code>get_behind_mineral_positions(**kwargs)</code>","text":"<p>Finds 3 spots behind the mineral line</p> <p>This is useful for building structures out of typical cannon range.</p> <p>TerrainManager</p> <p>Parameters:</p> Name Type Description Default <code>th_pos</code> <code>Point2</code> <p>Position of townhall to find points behind the mineral line of.</p> required <p>Returns:</p> Type Description <code>list[Point2]</code> <p>Points behind the mineral line of the designated base.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_behind_mineral_positions(self, **kwargs) -&gt; list[Point2]:\n    \"\"\"Finds 3 spots behind the mineral line\n\n    This is useful for building structures out of typical cannon range.\n\n    TerrainManager\n\n    Parameters:\n        th_pos (Point2): Position of townhall to find points behind\n            the mineral line of.\n\n    Returns:\n        Points behind the mineral line of the designated base.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.TERRAIN_MANAGER,\n        ManagerRequestType.GET_BEHIND_MINERAL_POSITIONS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_closest_creep_tile","title":"<code>get_closest_creep_tile(**kwargs)</code>","text":"<p>Get closest creep tile to <code>pos</code></p> <p>WARNING: May return <code>None</code> if no creep tiles observed.</p> <p>CreepManager</p> <p>Example: <pre><code>import numpy as np\n\nclosest_tile: Point2 = (\n    self.mediator.get_closest_creep_tile(pos=point)\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Point2</code> <p>The position to search for closest creep tile.</p> required <p>Returns:</p> Type Description <code>None | Point2</code> <p>Point2 representing the closest creep tile or None if no creep tiles.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_closest_creep_tile(self, **kwargs) -&gt; None | Point2:\n    \"\"\"Get closest creep tile to `pos`\n\n    WARNING: May return `None` if no creep tiles observed.\n\n    CreepManager\n\n    Example:\n    ```py\n    import numpy as np\n\n    closest_tile: Point2 = (\n        self.mediator.get_closest_creep_tile(pos=point)\n    )\n    ```\n\n    Parameters:\n        pos (Point2): The position to search for closest creep tile.\n\n    Returns:\n        Point2 representing the closest creep tile or None if no creep tiles.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.CREEP_MANAGER,\n        ManagerRequestType.GET_CLOSEST_CREEP_TILE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_closest_overlord_spot","title":"<code>get_closest_overlord_spot(**kwargs)</code>","text":"<p>Given a position, find the closest high ground overlord spot.</p> <p>TerrainManager</p> <p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>Point2</code> <p>Position the Overlord spot should be closest to.</p> required <p>Returns:</p> Type Description <code>Point2</code> <p>The closest Overlord hiding spot to the position.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_closest_overlord_spot(self, **kwargs) -&gt; Point2:\n    \"\"\"Given a position, find the closest high ground overlord spot.\n\n    TerrainManager\n\n    Parameters:\n        from_pos (Point2): Position the Overlord spot should be closest to.\n\n    Returns:\n        The closest Overlord hiding spot to the position.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.TERRAIN_MANAGER,\n        ManagerRequestType.GET_CLOSEST_OVERLORD_SPOT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_flood_fill_area","title":"<code>get_flood_fill_area(**kwargs)</code>","text":"<p>Given a point, flood fill outward from it and return the valid points.</p> <p>This flood fill does not continue through chokes.</p> <p>TerrainManager</p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>Point2</code> <p>Where to start the flood fill.</p> required <code>max_dist</code> <code>float</code> <p>Only include points closer than this distance to the start point.</p> required <p>Returns:</p> Type Description <code>set[tuple[int, int]]</code> <p>Tuple[int, List[Tuple[int, int]]]: First element is the number of valid points. Second element is the list of all valid points.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_flood_fill_area(self, **kwargs) -&gt; set[tuple[int, int]]:\n    \"\"\"Given a point, flood fill outward from it and return the valid points.\n\n    This flood fill does not continue through chokes.\n\n    TerrainManager\n\n    Parameters:\n        start_point (Point2): Where to start the flood fill.\n        max_dist (float): Only include points closer than this\n            distance to the start point.\n\n    Returns:\n        Tuple[int, List[Tuple[int, int]]]:\n            First element is the number of valid points.\n            Second element is the list of all valid points.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.TERRAIN_MANAGER,\n        ManagerRequestType.GET_FLOOD_FILL_AREA,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_is_detected","title":"<code>get_is_detected(**kwargs)</code>","text":"<p>Get if the enemy currently is revealing a cloaked or burrowed unit.</p> <p>UnitMemoryManager</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean if unit is detected.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_is_detected(self, **kwargs) -&gt; bool:\n    \"\"\"Get if the enemy currently is revealing a cloaked or burrowed unit.\n\n    UnitMemoryManager\n\n    Returns:\n        Boolean if unit is detected.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_MEMORY_MANAGER,\n        ManagerRequestType.GET_IS_DETECTED,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_next_tumor_on_path","title":"<code>get_next_tumor_on_path(**kwargs)</code>","text":"<p>Determines the next tumor position on the path, using vectorized operations to find positions along the creep edge that maintain proper separation.</p> <p>Parameters:</p> Name Type Description Default <code>grid </code> <p>np.ndarray A 2D array to path on.</p> required <code>from_pos </code> <p>Point2 The starting position from which the path is evaluated.</p> required <code>to_pos </code> <p>Point2 The target position on the grid where the path leads.</p> required <code>max_distance </code> <p>float, optional The maximum allowable distance from the <code>from_pos</code> to the next tumor position. Default is 999.9.</p> required <code>min_distance</code> <p>float, optional The minimum allowable distance from the <code>from_pos</code> to the next tumor position. Default is 0.0.</p> required <code>min_separation</code> <p>float, optional The minimum distance required between the new tumor and existing tumors/queen routes. Default is 3.0.</p> required <code>find_alternative</code> <p>bool, optional Find an alternative position if the closest position is too close to existing tumors Switch to False if possible to avoid unnecessary checks. Default is True.</p> required <p>Returns:</p> Type Description <code>Point2 | None</code> <p>Point2 or None Returns the next suitable tumor position on the grid if a valid position is found within the specified conditions. Returns None if no valid position exists.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_next_tumor_on_path(self, **kwargs) -&gt; Point2 | None:\n    \"\"\"\n    Determines the next tumor position on the path, using vectorized operations\n    to find positions along the creep edge that maintain proper separation.\n\n    Parameters:\n        grid : np.ndarray\n            A 2D array to path on.\n        from_pos : Point2\n            The starting position from which the path is evaluated.\n        to_pos : Point2\n            The target position on the grid where the path leads.\n        max_distance : float, optional\n            The maximum allowable distance from the `from_pos` to the\n            next tumor position.\n            Default is 999.9.\n        min_distance: float, optional\n            The minimum allowable distance from the `from_pos` to the\n            next tumor position.\n            Default is 0.0.\n        min_separation: float, optional\n            The minimum distance required between the new\n            tumor and existing tumors/queen routes.\n            Default is 3.0.\n        find_alternative: bool, optional\n            Find an alternative position if the closest position is\n            too close to existing tumors\n            Switch to False if possible to avoid unnecessary checks.\n            Default is True.\n\n    Returns:\n        Point2 or None\n            Returns the next suitable tumor position on the grid if a valid\n            position is found within the specified conditions.\n            Returns None if no valid position exists.\n    \"\"\"\n\n    return self.manager_request(\n        ManagerName.CREEP_MANAGER,\n        ManagerRequestType.GET_NEXT_TUMOR_ON_PATH,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_overlord_creep_spotter_positions","title":"<code>get_overlord_creep_spotter_positions(**kwargs)</code>","text":"<p>Find optimal positions for overlords to provide vision for creep spread.</p> <p>This function finds the edge of creep and distributes overlord positions evenly around it.</p> <p>Parameters:</p> Name Type Description Default <code>overlords </code> <p>Units | list[Unit] The overlords that will be positioned for creep vision</p> required <p>Returns:</p> Type Description <code>dict[int, Point2]</code> <p>dict[int: Point2] Dictionary mapping overlord tag to position where it should move</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_overlord_creep_spotter_positions(self, **kwargs) -&gt; dict[int, Point2]:\n    \"\"\"Find optimal positions for overlords to provide vision for creep spread.\n\n    This function finds the edge of creep and distributes\n    overlord positions evenly around it.\n\n    Parameters:\n        overlords : Units | list[Unit]\n            The overlords that will be positioned for creep vision\n\n    Returns:\n        dict[int: Point2]\n            Dictionary mapping overlord tag to position where it should move\n    \"\"\"\n    return self.manager_request(\n        ManagerName.CREEP_MANAGER,\n        ManagerRequestType.GET_OVERLORD_CREEP_SPOTTER_POSTIONS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_own_unit_count","title":"<code>get_own_unit_count(**kwargs)</code>","text":"<p>Get the dictionary of own structure types to the units themselves.</p> <p>UnitCacheManager</p> <p>Parameters:</p> Name Type Description Default <code>unit_type_id</code> <code>UnitTypeId</code> <p>Unit type to count.</p> required <code>include_alias</code> <code>bool</code> <p>Check aliases. (default=True)</p> required <p>Returns:</p> Type Description <code>int</code> <p>Total count of this unit including aliases if specified.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_own_unit_count(self, **kwargs) -&gt; int:\n    \"\"\"Get the dictionary of own structure types to the units themselves.\n\n    UnitCacheManager\n\n    Parameters:\n        unit_type_id (UnitID): Unit type to count.\n        include_alias (bool): Check aliases. (default=True)\n\n    Returns:\n        Total count of this unit including aliases if specified.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_CACHE_MANAGER,\n        ManagerRequestType.GET_OWN_UNIT_COUNT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_position_blocks_expansion","title":"<code>get_position_blocks_expansion(**kwargs)</code>","text":"<p>See if a position blocks an expansion.</p> <p>Parameters:</p> Name Type Description Default <code>position </code> <p>Point2 The position to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Position blocks expansion.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_position_blocks_expansion(self, **kwargs) -&gt; bool:\n    \"\"\"See if a position blocks an expansion.\n\n    Parameters:\n        position : Point2\n            The position to check.\n\n    Returns:\n        Position blocks expansion.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.CREEP_MANAGER,\n        ManagerRequestType.GET_RANDOM_CREEP_POSITION,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_position_of_main_squad","title":"<code>get_position_of_main_squad(**kwargs)</code>","text":"<p>Given a unit role, find where the main squad is.</p> <p>SquadManager</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>UnitRole</code> <p>Get the squads for this unit role.</p> required <p>Returns:</p> Type Description <code>Point2</code> <p>Position of main squad for this <code>role</code></p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_position_of_main_squad(self, **kwargs) -&gt; Point2:\n    \"\"\"Given a unit role, find where the main squad is.\n\n    SquadManager\n\n    Parameters:\n        role (UnitRole): Get the squads for this unit role.\n\n    Returns:\n        Position of main squad for this `role`\n    \"\"\"\n    return self.manager_request(\n        ManagerName.SQUAD_MANAGER,\n        ManagerRequestType.GET_POSITION_OF_MAIN_SQUAD,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_random_creep_position","title":"<code>get_random_creep_position(**kwargs)</code>","text":"<p>Find a random valid creep position within tumor range.</p> <p>Parameters:</p> Name Type Description Default <code>position </code> <p>Point2 The position to search from.</p> required <code>max_attempts </code> <p>int Maximum attempts to find a valid position.</p> required <p>Returns:</p> Type Description <code>Point2 | None</code> <p>Point2 | None Random creep position.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_random_creep_position(self, **kwargs) -&gt; Point2 | None:\n    \"\"\"Find a random valid creep position within tumor range.\n\n    Parameters:\n        position : Point2\n            The position to search from.\n        max_attempts : int\n            Maximum attempts to find a valid position.\n\n    Returns:\n        Point2 | None\n            Random creep position.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.CREEP_MANAGER,\n        ManagerRequestType.GET_RANDOM_CREEP_POSITION,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_squads","title":"<code>get_squads(**kwargs)</code>","text":"<p>Given a unit role, get the updated squads.</p> <p>SquadManager</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>UnitRole</code> <p>Get the squads for this unit role.</p> required <code>squad_radius</code> <p>The threshold as to which separate squads are formed.</p> required <code>unit_type</code> <p>If specified, only form squads with these unit types WARNING: Will not remove units that have already          been assigned to a squad.</p> required <p>Returns:</p> Type Description <code>list['UnitSquad']</code> <p>Each squad with this unit role.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_squads(self, **kwargs) -&gt; list[\"UnitSquad\"]:\n    \"\"\"Given a unit role, get the updated squads.\n\n    SquadManager\n\n    Parameters:\n        role (UnitRole): Get the squads for this unit role.\n        squad_radius: The threshold as to which separate squads are formed.\n        unit_type: If specified, only form squads with these unit types\n            WARNING: Will not remove units that have already\n                     been assigned to a squad.\n\n    Returns:\n        Each squad with this unit role.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.SQUAD_MANAGER,\n        ManagerRequestType.GET_SQUADS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_tumor_influence_lowest_cost_position","title":"<code>get_tumor_influence_lowest_cost_position(**kwargs)</code>","text":"<p>Determines the lowest cost position influenced by the tumor through a request to the creep manager.</p> <p>This method sends a request to the creep manager to retrieve the position with the lowest cost under tumor influence. The operation is executed via the manager_request function.</p> <p>Parameters:</p> Name Type Description Default <code>position </code> <p>Point2 Tumor position.</p> required <p>Returns:</p> Name Type Description <code>Point2</code> <code>Point2 | None</code> <p>Furthest placement with lowest cost under tumor influence.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_tumor_influence_lowest_cost_position(self, **kwargs) -&gt; Point2 | None:\n    \"\"\"\n    Determines the lowest cost position influenced by the tumor through a request\n    to the creep manager.\n\n    This method sends a request to the creep manager to retrieve the position\n    with the lowest cost under tumor influence. The operation is executed\n    via the manager_request function.\n\n    Parameters:\n        position : Point2\n            Tumor position.\n\n    Returns:\n        Point2:\n            Furthest placement with lowest cost under tumor influence.\n\n    \"\"\"\n    return self.manager_request(\n        ManagerName.CREEP_MANAGER,\n        ManagerRequestType.GET_TUMOR_INFLUENCE_LOWEST_COST_POSITION,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_units_from_role","title":"<code>get_units_from_role(**kwargs)</code>","text":"<p>Get a Units object containing units with a given role.</p> <p>If a UnitID or set of UnitIDs are given, it will only return units of those types, otherwise it will return all units with the role. If <code>restrict_to</code> is specified, it will only retrieve units from that object.</p> <p>UnitRoleManager</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>UnitRole</code> <p>Role to get units from.</p> required <code>unit_type</code> <code>UnitTypeId</code> <p>Type(s) of units that should be returned. If omitted, all units with the role will be returned.</p> required <code>restrict_to</code> <code>Set[UnitTypeId]</code> <p>If supplied, only take Units with the given role and type if they also exist here.</p> required <p>Returns:</p> Type Description <code>Units</code> <p>Units with the given role.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_units_from_role(self, **kwargs) -&gt; Units:\n    \"\"\"Get a Units object containing units with a given role.\n\n    If a UnitID or set of UnitIDs are given, it will only return units of those\n    types, otherwise it will return all units with the role. If `restrict_to` is\n    specified, it will only retrieve units from that object.\n\n    UnitRoleManager\n\n    Parameters:\n        role (UnitRole): Role to get units from.\n        unit_type (UnitTypeId): Type(s) of units that should be returned.\n            If omitted, all units with the role will be returned.\n        restrict_to (Set[UnitTypeId]): If supplied, only take Units\n            with the given role and type if they also exist here.\n\n    Returns:\n        Units with the given role.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_ROLE_MANAGER,\n        ManagerRequestType.GET_UNITS_FROM_ROLE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_units_from_roles","title":"<code>get_units_from_roles(**kwargs)</code>","text":"<p>Get the units matching <code>unit_type</code> from the given roles.</p> <p>UnitRoleManager</p> <p>Parameters:</p> Name Type Description Default <code>roles</code> <code>Set[UnitRole]</code> <p>Roles to get units from.</p> required <code>unit_type</code> <code>UnitTypeId</code> <p>Type(s) of units that should be returned. If omitted, all units with the role will be returned.</p> required <p>Returns:</p> Type Description <code>Units</code> <p>Units with the given roles.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_units_from_roles(self, **kwargs) -&gt; Units:\n    \"\"\"Get the units matching `unit_type` from the given roles.\n\n    UnitRoleManager\n\n    Parameters:\n        roles (Set[UnitRole]): Roles to get units from.\n        unit_type (UnitTypeId): Type(s) of units that should be returned.\n            If omitted, all units with the role will be returned.\n\n    Returns:\n        Units with the given roles.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_ROLE_MANAGER,\n        ManagerRequestType.GET_UNITS_FROM_ROLES,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_units_from_tags","title":"<code>get_units_from_tags(**kwargs)</code>","text":"<p>Get a <code>list</code> of <code>Unit</code> objects corresponding to the given tags.</p> <p>UnitCacheManager</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <p>Tags of the units to retrieve.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_units_from_tags(self, **kwargs) -&gt; list[Unit]:\n    \"\"\"Get a `list` of `Unit` objects corresponding to the given tags.\n\n    UnitCacheManager\n\n    Parameters:\n        tags: Tags of the units to retrieve.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_CACHE_MANAGER,\n        ManagerRequestType.GET_UNITS_FROM_TAGS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.get_units_in_range","title":"<code>get_units_in_range(**kwargs)</code>","text":"<p>Get units in range of other units or points.</p> <p>UnitMemoryManager</p> <p>Parameters:</p> Name Type Description Default <code>start_points</code> <code>List[Union[Unit, Tuple[float, float]]]</code> <p>List of <code>Unit</code>s or positions to search for units from.</p> required <code>distances</code> <code>Union[float, List[float]]</code> <p>How far away from each point to query. Must broadcast to the length of <code>start_points</code>.</p> required <code>query_tree</code> <code>UnitTreeQueryType</code> <p>Which KDTree should be queried.</p> required <code>return_as_dict</code> <code>bool</code> <p>Sets whether the returned units in range should be a dictionary or list. Default is False.</p> required <p>Returns:</p> Type Description <code>Union[Dict[Union[int, Tuple[float, float]], Units], list[Units]]</code> <p>Union[Dict[Union[int, Tuple[float, float]], Units], List[Units]]: Returns the units in range of each start point as a <code>dict</code> where the key is the unit tag or position and the value is the <code>Units</code> in range or a <code>list</code> of <code>Units</code>.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def get_units_in_range(\n    self, **kwargs\n) -&gt; Union[Dict[Union[int, Tuple[float, float]], Units], list[Units]]:\n    \"\"\"Get units in range of other units or points.\n\n    UnitMemoryManager\n\n    Parameters:\n        start_points (List[Union[Unit, Tuple[float, float]]]):\n            List of `Unit`s or positions to search for units from.\n        distances (Union[float, List[float]]): How far away from each point to\n            query. Must broadcast to the length of `start_points`.\n        query_tree (UnitTreeQueryType): Which KDTree should be queried.\n        return_as_dict (bool, optional): Sets whether the returned units in range\n            should be a dictionary or list. Default is False.\n\n\n    Returns:\n        Union[Dict[Union[int, Tuple[float, float]], Units], List[Units]]:\n            Returns the units in range of each start point as a `dict` where the key\n            is the unit tag or position and the value is the `Units` in range or a\n            `list` of `Units`.\n\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_MEMORY_MANAGER,\n        ManagerRequestType.GET_UNITS_IN_RANGE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.is_position_safe","title":"<code>is_position_safe(**kwargs)</code>","text":"<p>Check if the given position is considered dangerous.</p> <p>PathManager</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to evaluate safety on.</p> required <code>position</code> <code>Point2</code> <p>The position to check the safety of.</p> required <code>weight_safety_limit</code> <code>float</code> <p>The maximum value the point can have on the grid to be considered safe. Default value is 1.0.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the position is considered safe, False otherwise.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def is_position_safe(self, **kwargs) -&gt; bool:\n    \"\"\"Check if the given position is considered dangerous.\n\n    PathManager\n\n    Parameters:\n        grid (np.ndarray): The grid to evaluate safety on.\n        position (Point2): The position to check the safety of.\n        weight_safety_limit (float): The maximum value the point can\n            have on the grid to be considered safe.\n            Default value is 1.0.\n\n    Returns:\n        True if the position is considered safe, False otherwise.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PATH_MANAGER,\n        ManagerRequestType.IS_POSITION_SAFE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.manager_request","title":"<code>manager_request(receiver, request, reason=None, **kwargs)</code>","text":"<p>Function to request information from a manager.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>ManagerName</code> <p>Manager receiving the request.</p> required <code>request</code> <code>ManagerRequestType</code> <p>Requested attribute/function call.</p> required <code>reason</code> <code>str</code> <p>Why the request is being made.</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments (if any) to be passed to the requested function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>There are too many possible return types to list all of them.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def manager_request(\n    self,\n    receiver: ManagerName,\n    request: ManagerRequestType,\n    reason: str = None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Function to request information from a manager.\n\n    Parameters:\n        receiver: Manager receiving the request.\n        request: Requested attribute/function call.\n        reason: Why the request is being made.\n        kwargs: Keyword arguments (if any) to be passed to the requested function.\n\n    Returns:\n        Any: There are too many possible return types to list all of them.\n\n\n    \"\"\"\n    return self.managers[receiver.value].manager_request(\n        receiver, request, reason, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.move_structure","title":"<code>move_structure(**kwargs)</code>","text":"<p>Request a structure to move via flight.</p> <p>FlyingStructureManager</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Unit</code> <p>The structure to be moved or landed.</p> required <code>target</code> <code>Point2</code> <p>The target location for the structure.</p> required <code>should_land</code> <code>bool</code> <p>Whether the structure should land after moving. Defaults to False.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def move_structure(self, **kwargs) -&gt; None:\n    \"\"\"Request a structure to move via flight.\n\n    FlyingStructureManager\n\n    Parameters:\n        structure (Unit): The structure to be moved or landed.\n        target (Point2): The target location for the structure.\n        should_land (bool, optional): Whether the structure should\n            land after moving. Defaults to False.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.FLYING_STRUCTURE_MANAGER,\n        ManagerRequestType.MOVE_STRUCTURE,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.remove_from_nydus_travellers","title":"<code>remove_from_nydus_travellers(**kwargs)</code>","text":"<p>Remove a unit from the nydus travellers dictionary.</p> <p>NydusManager</p> <p>Parameters:</p> Name Type Description Default <code>unit_tag</code> <p>int The unit tag to be removed from the nydus travellers.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def remove_from_nydus_travellers(self, **kwargs) -&gt; None:\n    \"\"\"Remove a unit from the nydus travellers dictionary.\n\n    NydusManager\n\n    Parameters:\n        unit_tag: int\n            The unit tag to be removed from the nydus travellers.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.NYDUS_MANAGER,\n        ManagerRequestType.REMOVE_FROM_NYDUS_TRAVELLERS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.remove_gas_building","title":"<code>remove_gas_building(**kwargs)</code>","text":"<p>Request for a gas building to be removed from bookkeeping.</p> <p>Resource Manager</p> <p>Parameters:</p> Name Type Description Default <code>gas_building_tag</code> <code>int</code> <p>The tag of the gas building to remove.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def remove_gas_building(self, **kwargs) -&gt; None:\n    \"\"\"Request for a gas building to be removed from bookkeeping.\n\n    Resource Manager\n\n    Parameters:\n        gas_building_tag (int): The tag of the gas building to remove.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.RESOURCE_MANAGER,\n        ManagerRequestType.REMOVE_GAS_BUILDING,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.remove_mineral_field","title":"<code>remove_mineral_field(**kwargs)</code>","text":"<p>Request for a mineral field to be removed from bookkeeping.</p> <p>Resource Manager</p> <p>Parameters:</p> Name Type Description Default <code>mineral_field_tag</code> <code>int</code> <p>The tag of the mineral patch to remove.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def remove_mineral_field(self, **kwargs) -&gt; None:\n    \"\"\"Request for a mineral field to be removed from bookkeeping.\n\n    Resource Manager\n\n    Parameters:\n        mineral_field_tag (int): The tag of the mineral patch to remove.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.RESOURCE_MANAGER,\n        ManagerRequestType.REMOVE_MINERAL_FIELD,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.remove_tag_from_squads","title":"<code>remove_tag_from_squads(**kwargs)</code>","text":"<p>SquadManager</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>int</code> <p>Get the squads for this unit role.</p> required <code>squad_radius</code> <code>float</code> <p>The threshold as to which separate squads are formed.</p> required <code>unit_type</code> <code>UnitTypeId</code> <p>If specified, only form squads with these unit types WARNING: Will not remove units that have already          been assigned to a squad.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Each squad with this unit role.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def remove_tag_from_squads(self, **kwargs) -&gt; None:\n    \"\"\"\n    SquadManager\n\n    Parameters:\n        tag (int): Get the squads for this unit role.\n        squad_radius (float): The threshold as to which separate squads are formed.\n        unit_type (UnitTypeId): If specified, only form squads with these unit types\n            WARNING: Will not remove units that have already\n                     been assigned to a squad.\n\n    Returns:\n        Each squad with this unit role.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.SQUAD_MANAGER,\n        ManagerRequestType.REMOVE_TAG_FROM_SQUADS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.remove_worker_from_mineral","title":"<code>remove_worker_from_mineral(**kwargs)</code>","text":"<p>Remove worker from internal data structures.</p> <p>This happens if worker gets assigned to do something else</p> <p>ResourceManager</p> <p>Parameters:</p> Name Type Description Default <code>worker_tag</code> <p>Tag of the worker to be removed.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def remove_worker_from_mineral(self, **kwargs) -&gt; None:\n    \"\"\"Remove worker from internal data structures.\n\n    This happens if worker gets assigned to do something else\n\n    ResourceManager\n\n    Parameters:\n        worker_tag: Tag of the worker to be removed.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.RESOURCE_MANAGER,\n        ManagerRequestType.REMOVE_WORKER_FROM_MINERAL,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.request_building_placement","title":"<code>request_building_placement(**kwargs)</code>","text":"<p>Request a building placement from the precalculated building formation.</p> <p>PlacementManager</p> <p>Parameters:</p> Name Type Description Default <code>base_location</code> <code>Point2</code> <p>The general area where the placement should be near. This should be an expansion location.</p> required <code>structure_type</code> <code>UnitTypeId</code> <p>Structure type requested.</p> required <code>first_pylon</code> <code>bool</code> <p>Try to take designated first pylon if available. Default value is False.</p> required <code>static_defence</code> <code>bool</code> <p>Try to take designated static defence placements if available. Default value is False.</p> required <code>wall</code> <code>bool</code> <p>Request a wall structure placement. Will find alternative if no wall placements available. Default value is False.</p> required <code>find_alternative</code> <code>bool</code> <p>If no placements available at base_location, find an alternative at a nearby base. Default value is True.</p> required <code>reserve_placement</code> <code>bool</code> <p>Reserve this booking for a while, so another customer doesn't request it. Default value is True.</p> required <code>within_psionic_matrix</code> <code>bool</code> <p>Protoss specific -&gt; calculated position have power? Default value is False.</p> required <code>pylon_build_progress</code> <code>float</code> <p>Only relevant if <code>within_psionic_matrix = True</code>. Default value is 1.0.</p> required <code>closest_to</code> <code>Point2</code> <p>Find placement at base closest to this.</p> required <p>Returns:</p> Type Description <code>Optional[Point2]</code> <p>Indicating if structure can be placed at given position.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def request_building_placement(self, **kwargs) -&gt; Optional[Point2]:\n    \"\"\"Request a building placement from the precalculated building formation.\n\n    PlacementManager\n\n    Parameters:\n        base_location (Point2): The general area where the placement should be near.\n            This should be an expansion location.\n        structure_type (UnitID): Structure type requested.\n        first_pylon (bool, optional): Try to take designated\n            first pylon if available.\n            Default value is False.\n        static_defence (bool, optional): Try to take designated\n            static defence placements if available.\n            Default value is False.\n        wall (bool, optional): Request a wall structure placement.\n            Will find alternative if no wall placements available.\n            Default value is False.\n        find_alternative (bool, optional): If no placements available\n            at base_location, find an alternative at a nearby base.\n            Default value is True.\n        reserve_placement (bool, optional): Reserve this booking for a\n            while, so another customer doesn't request it.\n            Default value is True.\n        within_psionic_matrix (bool, optional): Protoss specific -&gt; calculated\n            position have power?\n            Default value is False.\n        pylon_build_progress (float, optional): Only relevant\n            if `within_psionic_matrix = True`.\n            Default value is 1.0.\n        closest_to (Point2, optional): Find placement at base closest to this.\n\n\n    Returns:\n        Indicating if structure can be placed at given position.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.PLACEMENT_MANAGER,\n        ManagerRequestType.REQUEST_BUILDING_PLACEMENT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.request_warp_in","title":"<code>request_warp_in(**kwargs)</code>","text":"<p>Request a warp in spot, without making a query to the game client.</p> <p>PlacementManager</p> <p>Parameters:</p> Name Type Description Default <code>unit_type</code> <code>UnitTypeId</code> <p>The unit we want to warp in.</p> required <code>target</code> <code>Optional[Point2]</code> <p>If provided, attempt to find spot closest to this location.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def request_warp_in(self, **kwargs) -&gt; None:\n    \"\"\"Request a warp in spot, without making a query to the game client.\n\n    PlacementManager\n\n    Parameters:\n        unit_type (UnitTypeId): The unit we want to warp in.\n        target (Optional[Point2]): If provided, attempt to find\n            spot closest to this location.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.WARP_IN_MANAGER,\n        ManagerRequestType.REQUEST_WARP_IN,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.select_worker","title":"<code>select_worker(**kwargs)</code>","text":"<p>Select a worker via the ResourceManager.</p> <p>This way we can select one assigned to a far mineral patch. Make sure to change the worker role once selected, otherwise it will be selected to mine again. This doesn't select workers from geysers, so make sure to remove workers from gas if low on workers.</p> <p>ResourceManager</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>Point2</code> <p>Location to get the closest workers to.</p> required <code>force_close</code> <code>bool</code> <p>Select the available worker closest to <code>target_position</code> if True.</p> required <code>select_persistent_builder</code> <code>bool</code> <p>If True, we can select the persistent_builder if it's available.</p> required <code>only_select_persistent_builder</code> <code>bool</code> <p>If True, don't find an alternative worker.</p> required <code>min_health_perc</code> <code>float</code> <p>Only select workers above this health percentage.</p> required <code>min_shield_perc</code> <code>float</code> <p>Only select workers above this shield percentage.</p> required <p>Returns:</p> Type Description <code>Optional[Unit]</code> <p>Selected worker, if available.</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def select_worker(self, **kwargs) -&gt; Optional[Unit]:\n    \"\"\"Select a worker via the ResourceManager.\n\n    This way we can select one assigned to a far mineral patch.\n    Make sure to change the worker role once selected, otherwise it will be selected\n    to mine again. This doesn't select workers from geysers, so make sure to remove\n    workers from gas if low on workers.\n\n    ResourceManager\n\n    Parameters:\n        target_position (Point2): Location to get the closest workers to.\n        force_close (bool): Select the available worker closest to\n            `target_position` if True.\n        select_persistent_builder (bool): If True, we can select\n            the persistent_builder if it's available.\n        only_select_persistent_builder (bool): If True, don't find an\n            alternative worker.\n        min_health_perc (float): Only select workers above this health percentage.\n        min_shield_perc (float): Only select workers above this shield percentage.\n\n    Returns:\n        Selected worker, if available.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.RESOURCE_MANAGER,\n        ManagerRequestType.SELECT_WORKER,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.set_workers_per_gas","title":"<code>set_workers_per_gas(**kwargs)</code>","text":"<p>Give all units in a role a different role.</p> <p>ResourceManager</p>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.set_workers_per_gas--parameters","title":"Parameters","text":"<p>amount (int): Num workers to assign to each gas building</p> Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def set_workers_per_gas(self, **kwargs) -&gt; None:\n    \"\"\"Give all units in a role a different role.\n\n    ResourceManager\n\n    Parameters\n    ----------\n    amount (int): Num workers to assign to each gas building\n    \"\"\"\n    return self.manager_request(\n        ManagerName.RESOURCE_MANAGER,\n        ManagerRequestType.SET_WORKERS_PER_GAS,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.switch_roles","title":"<code>switch_roles(**kwargs)</code>","text":"<p>Give all units in a role a different role.</p> <p>UnitRoleManager</p> <p>Parameters:</p> Name Type Description Default <code>from_role</code> <code>UnitRole</code> <p>Role the units currently have.</p> required <code>to_role</code> <code>UnitRole</code> <p>Role to assign to the units.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def switch_roles(self, **kwargs) -&gt; None:\n    \"\"\"Give all units in a role a different role.\n\n    UnitRoleManager\n\n    Parameters:\n        from_role (UnitRole): Role the units currently have.\n        to_role (UnitRole): Role to assign to the units.\n    \"\"\"\n    return self.manager_request(\n        ManagerName.UNIT_ROLE_MANAGER,\n        ManagerRequestType.SWITCH_ROLES,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/manager_mediator.html#ares.managers.manager_mediator.ManagerMediator.update_unit_to_ability_dict","title":"<code>update_unit_to_ability_dict(**kwargs)</code>","text":"<p>Update tracking to reflect ability usage.</p> <p>After a unit uses an ability it should call this to update the frame the ability will next be available</p> <p>AbilityTrackerManager.</p> <p>Parameters:</p> Name Type Description Default <code>ability</code> <code>AbilityId</code> <p>The AbilityId that was used.</p> required <code>unit_tag</code> <code>int</code> <p>The tag of the Unit that used the ability.</p> required Source code in <code>src/ares/managers/manager_mediator.py</code> <pre><code>def update_unit_to_ability_dict(self, **kwargs) -&gt; None:\n    \"\"\"Update tracking to reflect ability usage.\n\n    After a unit uses an ability it should call this to update the frame the\n    ability will next be available\n\n    AbilityTrackerManager.\n\n    Parameters:\n        ability (AbilityId): The AbilityId that was used.\n        unit_tag (int): The tag of the Unit that used the ability.\n\n    \"\"\"\n    return self.manager_request(\n        ManagerName.ABILITY_TRACKER_MANAGER,\n        ManagerRequestType.UPDATE_UNIT_TO_ABILITY_DICT,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/behaviors/index.html","title":"Behaviors","text":"<p>Use the menu to browse available combat and macro behaviors.</p>"},{"location":"api_reference/behaviors/combat_behaviors.html","title":"Individual Combat Behaviors","text":""},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.combat_maneuver.CombatManeuver","title":"<code>CombatManeuver</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Behavior</code></p> <p>Execute behaviors sequentially.</p> <p>Add behaviors</p> <p>Example: <pre><code>from ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.individual import (\n    DropCargo,\n    KeepUnitSafe,\n    PathUnitToTarget,\n    PickUpCargo,\n)\n\nclass MyBot(AresBot):\n    mine_drop_medivac_tag: int\n\n    async def on_step(self, iteration):\n        # Left out here, but `self.mine_drop_medivac_tag`\n        # bookkeeping is up to the user\n        medivac: Optional[Unit] = self.unit_tag_dict.get(\n            self.mine_drop_medivac_tag, None\n        )\n        if not medivac:\n            return\n\n        air_grid: np.ndarray = self.mediator.get_air_grid\n\n        # initiate a new CombatManeuver\n        mine_drop: CombatManeuver = CombatManeuver()\n\n        # then add behaviors in the order they should be executed\n        # first priority is picking up units\n        # (will return False if no cargo and move to next behavior)\n        mine_drop.add(\n            PickUpCargo(\n                unit=medivac,\n                grid=air_grid,\n                pickup_targets=mines_to_pickup\n            )\n        )\n\n        # if there is cargo, path to target and drop them off\n        if medivac.has_cargo:\n            # path\n            mine_drop.add(\n                PathUnitToTarget(\n                    unit=medivac,\n                    grid=air_grid,\n                    target=self.enemy_start_locations[0],\n                )\n            )\n            # drop off the mines\n            mine_drop.add(DropCargo(unit=medivac, target=medivac.position))\n\n        # no cargo and no units to pick up, stay safe\n        else:\n            mine_drop.add(KeepUnitSafe(unit=medivac, grid=air_grid))\n\n        # register the mine_drop behavior\n        self.register_behavior(mine_drop)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>micros</code> <code>list[Behavior]</code> <p>A list of behaviors that should be executed. Defaults to an empty list.</p> Source code in <code>src/ares/behaviors/combat/combat_maneuver.py</code> <pre><code>@dataclass\nclass CombatManeuver(Behavior):\n    \"\"\"Execute behaviors sequentially.\n\n    Add behaviors\n\n    Example:\n    ```py\n    from ares import AresBot\n    from ares.behaviors.combat import CombatManeuver\n    from ares.behaviors.combat.individual import (\n        DropCargo,\n        KeepUnitSafe,\n        PathUnitToTarget,\n        PickUpCargo,\n    )\n\n    class MyBot(AresBot):\n        mine_drop_medivac_tag: int\n\n        async def on_step(self, iteration):\n            # Left out here, but `self.mine_drop_medivac_tag`\n            # bookkeeping is up to the user\n            medivac: Optional[Unit] = self.unit_tag_dict.get(\n                self.mine_drop_medivac_tag, None\n            )\n            if not medivac:\n                return\n\n            air_grid: np.ndarray = self.mediator.get_air_grid\n\n            # initiate a new CombatManeuver\n            mine_drop: CombatManeuver = CombatManeuver()\n\n            # then add behaviors in the order they should be executed\n            # first priority is picking up units\n            # (will return False if no cargo and move to next behavior)\n            mine_drop.add(\n                PickUpCargo(\n                    unit=medivac,\n                    grid=air_grid,\n                    pickup_targets=mines_to_pickup\n                )\n            )\n\n            # if there is cargo, path to target and drop them off\n            if medivac.has_cargo:\n                # path\n                mine_drop.add(\n                    PathUnitToTarget(\n                        unit=medivac,\n                        grid=air_grid,\n                        target=self.enemy_start_locations[0],\n                    )\n                )\n                # drop off the mines\n                mine_drop.add(DropCargo(unit=medivac, target=medivac.position))\n\n            # no cargo and no units to pick up, stay safe\n            else:\n                mine_drop.add(KeepUnitSafe(unit=medivac, grid=air_grid))\n\n            # register the mine_drop behavior\n            self.register_behavior(mine_drop)\n    ```\n\n    Attributes:\n        micros: A list of behaviors that should be executed. Defaults to an empty list.\n\n    \"\"\"\n\n    micros: list[Behavior] = field(default_factory=list)\n\n    def add(\n        self,\n        behavior: Union[\n            \"CombatIndividualBehavior\", \"CombatGroupBehavior\", \"CombatManeuver\"\n        ],\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            behavior: Add a new combat behavior to the current maneuver object.\n\n        \"\"\"\n        self.micros.append(behavior)\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        for order in self.micros:\n            if order.execute(ai, config, mediator):\n                # executed an action\n                return True\n        # none of the combat micros completed, no actions executed\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.combat_maneuver.CombatManeuver.add","title":"<code>add(behavior)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Union[CombatIndividualBehavior, CombatGroupBehavior, CombatManeuver]</code> <p>Add a new combat behavior to the current maneuver object.</p> required Source code in <code>src/ares/behaviors/combat/combat_maneuver.py</code> <pre><code>def add(\n    self,\n    behavior: Union[\n        \"CombatIndividualBehavior\", \"CombatGroupBehavior\", \"CombatManeuver\"\n    ],\n) -&gt; None:\n    \"\"\"\n    Args:\n        behavior: Add a new combat behavior to the current maneuver object.\n\n    \"\"\"\n    self.micros.append(behavior)\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.a_move.AMove","title":"<code>AMove</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>A-Move a unit to a target.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import AMove\n\nself.register_behavior(AMove(unit, self.game_info.map_center))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to stay safe.</p> <code>target</code> <code>Union[Point2, Unit]</code> <p>Where the unit is going.</p> <code>success_at_distance</code> <code>float</code> <p>Distance at which we don't need to issue a new move command because it's near the target.</p> Source code in <code>src/ares/behaviors/combat/individual/a_move.py</code> <pre><code>@dataclass\nclass AMove(CombatIndividualBehavior):\n    \"\"\"A-Move a unit to a target.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import AMove\n\n    self.register_behavior(AMove(unit, self.game_info.map_center))\n    ```\n\n    Attributes:\n        unit: The unit to stay safe.\n        target: Where the unit is going.\n        success_at_distance: Distance at which we don't need to issue\n            a new move command because it's near the target.\n\n    \"\"\"\n\n    unit: Unit\n    target: Union[Point2, Unit]\n    success_at_distance: float = 7.0\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if (\n            self.success_at_distance &gt; 0\n            and cy_distance_to(self.unit.position, self.target.position)\n            &lt; self.success_at_distance\n        ):\n            return False\n        self.unit.attack(self.target)\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.attack_target.AttackTarget","title":"<code>AttackTarget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Shoot a target.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import AttackTarget\n\nunit: Unit\ntarget: Unit\nself.register_behavior(AttackTarget(unit, target))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to shoot.</p> <code>target</code> <code>Unit</code> <p>The unit we want to shoot at.</p> Source code in <code>src/ares/behaviors/combat/individual/attack_target.py</code> <pre><code>@dataclass\nclass AttackTarget(CombatIndividualBehavior):\n    \"\"\"Shoot a target.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import AttackTarget\n\n    unit: Unit\n    target: Unit\n    self.register_behavior(AttackTarget(unit, target))\n    ```\n\n    Attributes:\n        unit: The unit to shoot.\n        target: The unit we want to shoot at.\n\n    \"\"\"\n\n    unit: Unit\n    target: Unit\n    extra_range: float = 0.0\n\n    def execute(\n        self, ai: \"AresBot\", config: dict, mediator: ManagerMediator, **kwargs\n    ) -&gt; bool:\n        self.unit.attack(self.target)\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.drop_cargo.DropCargo","title":"<code>DropCargo</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Handle releasing cargo from a container.</p> <p>Medivacs, WarpPrism, Overlords, Nydus.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import DropCargo\n\nunit: Unit\ntarget: Unit\nself.register_behavior(DropCargo(unit, target))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The container unit.</p> <code>target</code> <code>Point2</code> <p>The target position where to drop the cargo.</p> Source code in <code>src/ares/behaviors/combat/individual/drop_cargo.py</code> <pre><code>@dataclass\nclass DropCargo(CombatIndividualBehavior):\n    \"\"\"Handle releasing cargo from a container.\n\n    Medivacs, WarpPrism, Overlords, Nydus.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import DropCargo\n\n    unit: Unit\n    target: Unit\n    self.register_behavior(DropCargo(unit, target))\n    ```\n\n    Attributes:\n        unit: The container unit.\n        target: The target position where to drop the cargo.\n\n    \"\"\"\n\n    unit: Unit\n    target: Point2\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        # TODO: Expand logic as needed, initial working version.\n        # no action executed\n        if self.unit.cargo_used == 0 or not cy_in_pathing_grid_ma(\n            mediator.get_ground_grid, self.unit.position\n        ):\n            return False\n\n        ai.do_unload_container(self.unit.tag)\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.ghost_snipe.GhostSnipe","title":"<code>GhostSnipe</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Very opinionated ghost snipe. Create own behavior based on this if needed.</p> <p>Attributes: unit: The ghost. close_enemy: All close by allied units we want to heal.</p> Source code in <code>src/ares/behaviors/combat/individual/ghost_snipe.py</code> <pre><code>@dataclass\nclass GhostSnipe(CombatIndividualBehavior):\n    \"\"\"Very opinionated ghost snipe.\n    Create own behavior based on this if needed.\n\n    Attributes:\n    unit: The ghost.\n    close_enemy: All close by allied units we want to heal.\n    \"\"\"\n\n    unit: Unit\n    close_enemy: Union[list[Unit], Units]\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if (\n            ai.enemy_race != Race.Zerg\n            or not self.close_enemy\n            or self.unit.type_id != UnitID.GHOST\n        ):\n            return False\n\n        snipe_ability: AbilityId = AbilityId.EFFECT_GHOSTSNIPE\n        ghosts: list[Unit] = mediator.get_own_army_dict[UnitID.GHOST]\n        if snipe_ability in self.unit.abilities:\n            if target := self.get_snipe_target(ai, ghosts, self.close_enemy):\n                self.unit(snipe_ability, target)\n                return True\n\n        return False\n\n    def get_snipe_target(\n        self, ai: \"AresBot\", ghosts: list[Unit], units: Units\n    ) -&gt; Optional[Unit]:\n        max_value: float = 0.0\n        target: Optional[Unit] = None\n\n        for unit in units:\n            if (\n                unit.is_memory\n                or unit.type_id in ALL_STRUCTURES\n                or cy_distance_to_squared(self.unit.position, unit.position) &gt; 125.0\n                or ai.get_terrain_height(unit.position)\n                &gt; ai.get_terrain_height(self.unit.position)\n            ):\n                continue\n            already_snipe_in_progress: bool = False\n            for g in ghosts:\n                if g.order_target and g.order_target == unit.tag:\n                    already_snipe_in_progress = True\n            if already_snipe_in_progress:\n                continue\n\n            value: float = (\n                UNIT_DATA[unit.type_id][\"minerals\"] + UNIT_DATA[unit.type_id][\"gas\"]\n            )\n            if value &gt;= 100.0 and value &gt; max_value:\n                max_value = value\n                target = unit\n\n        return target\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.keep_unit_safe.KeepUnitSafe","title":"<code>KeepUnitSafe</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Get a unit to safety based on the influence grid passed in.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import KeepUnitSafe\n\nunit: Unit\ngrid: np.ndarray = self.mediator.get_ground_grid\nself.register_behavior(KeepUnitSafe(unit, grid))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to stay safe.</p> <code>grid</code> <code>ndarray</code> <p>2D grid which usually contains enemy influence.</p> Source code in <code>src/ares/behaviors/combat/individual/keep_unit_safe.py</code> <pre><code>@dataclass\nclass KeepUnitSafe(CombatIndividualBehavior):\n    \"\"\"Get a unit to safety based on the influence grid passed in.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import KeepUnitSafe\n\n    unit: Unit\n    grid: np.ndarray = self.mediator.get_ground_grid\n    self.register_behavior(KeepUnitSafe(unit, grid))\n    ```\n\n    Attributes:\n        unit: The unit to stay safe.\n        grid: 2D grid which usually contains enemy influence.\n\n    \"\"\"\n\n    unit: Unit\n    grid: np.ndarray\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        # no action executed\n        if mediator.is_position_safe(grid=self.grid, position=self.unit.position):\n            return False\n        else:\n            safe_spot: Point2 = mediator.find_closest_safe_spot(\n                from_pos=self.unit.position, grid=self.grid\n            )\n            path: Behavior = PathUnitToTarget(\n                unit=self.unit,\n                grid=self.grid,\n                target=safe_spot,\n                success_at_distance=0.0,\n            )\n            return path.execute(ai, config, mediator)\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.medivac_heal.MedivacHeal","title":"<code>MedivacHeal</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Given close allied units, heal things up.</p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The siege tank unit.</p> <code>close_allied</code> <code>list[Unit]</code> <p>All close by allied units we want to heal.</p> <code>grid</code> <code>ndarray</code> <p>The path for medivac to heal on</p> <code>keep_safe</code> <code>bool</code> <p>Attempt to stay safe, this may result in not always healing units (Default is True)</p> Source code in <code>src/ares/behaviors/combat/individual/medivac_heal.py</code> <pre><code>@dataclass\nclass MedivacHeal(CombatIndividualBehavior):\n    \"\"\"Given close allied units, heal things up.\n\n    Attributes:\n        unit: The siege tank unit.\n        close_allied: All close by allied units we want to heal.\n        grid: The path for medivac to heal on\n        keep_safe: Attempt to stay safe, this may result in\n            not always healing units (Default is True)\n    \"\"\"\n\n    unit: Unit\n    close_allied: list[Unit]\n    grid: np.ndarray\n    keep_safe: bool = True\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if self.unit.type_id != UnitID.MEDIVAC:\n            return False\n\n        if self.keep_safe and KeepUnitSafe(self.unit, self.grid).execute(\n            ai, config, mediator\n        ):\n            return True\n\n        # don't interfere\n        if self.unit.is_using_ability(AbilityId.MEDIVACHEAL_HEAL):\n            return True\n\n        bio_need_healing: list[Unit] = [\n            u\n            for u in self.close_allied\n            if u.is_biological and u.health_percentage &lt; 1.0\n        ]\n        # found something to heal\n        if len(bio_need_healing) &gt; 0:\n            target_unit: Unit = cy_closest_to(self.unit.position, bio_need_healing)\n            self.unit(AbilityId.MEDIVACHEAL_HEAL, target_unit)\n            return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.move_to_safe_target.MoveToSafeTarget","title":"<code>MoveToSafeTarget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Given a destination <code>target</code>, find the nearest safe position and move unit there.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import MoveToSafeTarget\n\nunit: Unit\ngrid: np.ndarray = self.mediator.get_ground_grid\ntarget: Point2 = self.game_info.map_center\nself.register_behavior(MoveToSafeTarget(unit, grid, target))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to path.</p> <code>grid</code> <code>ndarray</code> <p>2D grid to path on.</p> <code>target</code> <code>Point2</code> <p>Target destination.</p> <code>use_pathing</code> <code>bool</code> <p>Whether to use pathing or just move directly towards the target. Defaults to True.</p> <code>success_at_distance</code> <code>float</code> <p>If the unit has gotten this close, consider path behavior complete. Defaults to 0.0.</p> <code>sensitivity</code> <code>int</code> <p>Path precision. Defaults to 5.</p> <code>smoothing</code> <code>bool</code> <p>Whether to smooth out the path. Defaults to False.</p> <code>sense_danger</code> <code>bool</code> <p>Whether to check for dangers. If none are present, the pathing query is skipped. Defaults to True.</p> <code>danger_distance</code> <code>float</code> <p>If <code>sense_danger</code> is True, how far to check for dangers. Defaults to 20.0.</p> <code>danger_threshold</code> <code>float</code> <p>Influence at which a danger is respected. Defaults to 5.0.</p> <code>radius</code> <code>float</code> <p>How far to look for a safe spot around the target. Defaults to 12.0.</p> Source code in <code>src/ares/behaviors/combat/individual/move_to_safe_target.py</code> <pre><code>@dataclass\nclass MoveToSafeTarget(CombatIndividualBehavior):\n    \"\"\"Given a destination `target`, find the nearest safe position and move\n    unit there.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import MoveToSafeTarget\n\n    unit: Unit\n    grid: np.ndarray = self.mediator.get_ground_grid\n    target: Point2 = self.game_info.map_center\n    self.register_behavior(MoveToSafeTarget(unit, grid, target))\n    ```\n\n    Attributes:\n        unit: The unit to path.\n        grid: 2D grid to path on.\n        target: Target destination.\n        use_pathing: Whether to use pathing or just move directly towards the target.\n            Defaults to True.\n        success_at_distance: If the unit has gotten this close, consider path\n            behavior complete. Defaults to 0.0.\n        sensitivity: Path precision. Defaults to 5.\n        smoothing: Whether to smooth out the path. Defaults to False.\n        sense_danger: Whether to check for dangers. If none are present,\n            the pathing query is skipped. Defaults to True.\n        danger_distance: If `sense_danger` is True, how far to check for dangers.\n            Defaults to 20.0.\n        danger_threshold: Influence at which a danger is respected.\n            Defaults to 5.0.\n        radius: How far to look for a safe spot around the target.\n            Defaults to 12.0.\n\n    \"\"\"\n\n    unit: Unit\n    grid: np.ndarray\n    target: Point2\n    use_pathing: bool = True\n    success_at_distance: float = 1.0\n    sensitivity: int = 5\n    smoothing: bool = False\n    sense_danger: bool = True\n    danger_distance: float = 20.0\n    danger_threshold: float = 5.0\n    radius: float = 12.0\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if cy_distance_to(self.unit.position, self.target) &lt;= self.success_at_distance:\n            return False\n\n        safe_spot: Point2 = mediator.find_closest_safe_spot(\n            from_pos=self.target, grid=self.grid, radius=self.radius\n        )\n        if self.use_pathing:\n            return PathUnitToTarget(\n                unit=self.unit,\n                grid=self.grid,\n                target=safe_spot,\n                success_at_distance=self.success_at_distance,\n                sensitivity=self.sensitivity,\n                sense_danger=self.sense_danger,\n                smoothing=self.smoothing,\n            ).execute(ai, config, mediator)\n        else:\n            return UseAbility(AbilityId.MOVE_MOVE, self.unit, safe_spot).execute(\n                ai, config, mediator\n            )\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.path_unit_to_target.PathUnitToTarget","title":"<code>PathUnitToTarget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Path a unit to its target destination.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import PathUnitToTarget\n\nunit: Unit\ngrid: np.ndarray = self.mediator.get_ground_grid\ntarget: Point2 = self.game_info.map_center\nself.register_behavior(PathUnitToTarget(unit, grid, target))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to path.</p> <code>grid</code> <code>ndarray</code> <p>2D grid to path on.</p> <code>target</code> <code>Point2</code> <p>Target destination.</p> <code>success_at_distance</code> <code>float</code> <p>If the unit has gotten this close, consider path behavior complete. Defaults to 0.0.</p> <code>sensitivity</code> <code>int</code> <p>Path precision. Defaults to 5.</p> <code>smoothing</code> <code>bool</code> <p>Whether to smooth out the path. Defaults to False.</p> <code>sense_danger</code> <code>bool</code> <p>Whether to check for dangers. If none are present, the pathing query is skipped. Defaults to True.</p> <code>danger_distance</code> <code>float</code> <p>If <code>sense_danger</code> is True, how far to check for dangers. Defaults to 20.0.</p> <code>danger_threshold</code> <code>float</code> <p>Influence at which a danger is respected. Defaults to 5.0.</p> Source code in <code>src/ares/behaviors/combat/individual/path_unit_to_target.py</code> <pre><code>@dataclass\nclass PathUnitToTarget(CombatIndividualBehavior):\n    \"\"\"Path a unit to its target destination.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import PathUnitToTarget\n\n    unit: Unit\n    grid: np.ndarray = self.mediator.get_ground_grid\n    target: Point2 = self.game_info.map_center\n    self.register_behavior(PathUnitToTarget(unit, grid, target))\n    ```\n\n    Attributes:\n        unit: The unit to path.\n        grid: 2D grid to path on.\n        target: Target destination.\n        success_at_distance: If the unit has gotten this close, consider path\n            behavior complete. Defaults to 0.0.\n        sensitivity: Path precision. Defaults to 5.\n        smoothing: Whether to smooth out the path. Defaults to False.\n        sense_danger: Whether to check for dangers. If none are present,\n            the pathing query is skipped. Defaults to True.\n        danger_distance: If `sense_danger` is True, how far to check for dangers.\n            Defaults to 20.0.\n        danger_threshold: Influence at which a danger is respected.\n            Defaults to 5.0.\n\n    \"\"\"\n\n    unit: Unit\n    grid: np.ndarray\n    target: Point2\n    success_at_distance: float = 0.0\n    sensitivity: int = 5\n    smoothing: bool = False\n    sense_danger: bool = True\n    danger_distance: float = 20.0\n    danger_threshold: float = 5.0\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        distance_to_target: float = cy_distance_to(self.unit.position, self.target)\n        # no action executed\n        if distance_to_target &lt; self.success_at_distance:\n            return False\n\n        move_to: Point2 = mediator.find_path_next_point(\n            start=self.unit.position,\n            target=self.target,\n            grid=self.grid,\n            sensitivity=self.sensitivity,\n            smoothing=self.smoothing,\n            sense_danger=self.sense_danger,\n            danger_distance=self.danger_distance,\n            danger_threshold=self.danger_threshold,\n        )\n        self.unit.move(move_to)\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.pick_up_and_drop_cargo.PickUpAndDropCargo","title":"<code>PickUpAndDropCargo</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Combines <code>PickUpCargo</code> and <code>DropCargo</code> behaviors.</p> <p>Medivacs, WarpPrism, Overlords.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import PickUpAndDropCargo\n\nunit: Unit # medivac for example\ngrid: np.ndarray = self.mediator.get_ground_grid\npickup_targets: Union[Units, list[Unit]] = self.workers\nself.register_behavior(\n    PickUpAndDropCargo(unit, grid, pickup_targets, self.ai.game_info.map_center)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The container unit.</p> <code>grid</code> <code>ndarray</code> <p>Pathing grid for the container unit.</p> <code>pickup_targets</code> <code>Union[Units, list[Unit]]</code> <p>Units we want to load into the container.</p> <code>target</code> <code>Point2</code> <p>Drop at this target</p> <code>cargo_switch_to_role</code> <code>Optional[UnitRole]</code> <p>Sometimes useful to switch cargo to a new role immediately after loading. Defaults to None.</p> <code>should_drop_units</code> <code>bool</code> <p>Whether to drop units once they are loaded. Defaults to True.</p> <code>keep_dropship_safe</code> <code>bool</code> <p>If true, will keep dropship safe if nothing else to do. Defaults to True.</p> <code>success_at_distance</code> <code>float</code> <p>Distance at which pathing to target stops being checked. Defaults to 2.0.</p> Source code in <code>src/ares/behaviors/combat/individual/pick_up_and_drop_cargo.py</code> <pre><code>@dataclass\nclass PickUpAndDropCargo(CombatIndividualBehavior):\n    \"\"\"Combines `PickUpCargo` and `DropCargo` behaviors.\n\n    Medivacs, WarpPrism, Overlords.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import PickUpAndDropCargo\n\n    unit: Unit # medivac for example\n    grid: np.ndarray = self.mediator.get_ground_grid\n    pickup_targets: Union[Units, list[Unit]] = self.workers\n    self.register_behavior(\n        PickUpAndDropCargo(unit, grid, pickup_targets, self.ai.game_info.map_center)\n    )\n    ```\n\n    Attributes:\n        unit: The container unit.\n        grid: Pathing grid for the container unit.\n        pickup_targets: Units we want to load into the container.\n        target: Drop at this target\n        cargo_switch_to_role: Sometimes useful to switch cargo to\n            a new role immediately after loading. Defaults to None.\n        should_drop_units: Whether to drop units once they are loaded.\n            Defaults to True.\n        keep_dropship_safe: If true, will keep dropship safe if nothing else to do.\n            Defaults to True.\n        success_at_distance: Distance at which pathing to target stops being checked.\n            Defaults to 2.0.\n\n    \"\"\"\n\n    unit: Unit\n    grid: np.ndarray\n    pickup_targets: Union[Units, list[Unit]]\n    target: Point2\n    cargo_switch_to_role: Optional[UnitRole] = None\n    should_drop_units: bool = True\n    keep_dropship_safe: bool = True\n    success_at_distance: float = 2.0\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        # check for units to pick up.\n        if PickUpCargo(\n            unit=self.unit,\n            grid=self.grid,\n            pickup_targets=self.pickup_targets,\n            cargo_switch_to_role=self.cargo_switch_to_role,\n        ).execute(ai, config, mediator):\n            return True\n\n        if self.unit.has_cargo:\n            # path to target\n            if PathUnitToTarget(\n                unit=self.unit,\n                grid=self.grid,\n                target=self.target,\n                success_at_distance=self.success_at_distance,\n            ).execute(ai, config, mediator):\n                return True\n            if self.should_drop_units:\n                if DropCargo(unit=self.unit, target=self.unit.position).execute(\n                    ai, config, mediator\n                ):\n                    return True\n\n            if self.keep_dropship_safe and KeepUnitSafe(\n                unit=self.unit, grid=self.grid\n            ).execute(ai, config, mediator):\n                return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.pick_up_cargo.PickUpCargo","title":"<code>PickUpCargo</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Handle loading cargo into a container.</p> <p>Medivacs, WarpPrism, Overlords, Nydus.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import PickUpCargo\n\nunit: Unit # medivac for example\ngrid: np.ndarray = self.mediator.get_ground_grid\npickup_targets: Union[Units, list[Unit]] = self.workers\nself.register_behavior(PickUpCargo(unit, grid, pickup_targets))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The container unit.</p> <code>grid</code> <code>ndarray</code> <p>Pathing grid for the container unit.</p> <code>pickup_targets</code> <code>Union[Units, list[Unit]]</code> <p>Units we want to load into the container.</p> <code>cargo_switch_to_role</code> <code>Optional[UnitRole]</code> <p>Sometimes useful to switch cargo to a new role immediately after loading. Defaults to None.</p> Source code in <code>src/ares/behaviors/combat/individual/pick_up_cargo.py</code> <pre><code>@dataclass\nclass PickUpCargo(CombatIndividualBehavior):\n    \"\"\"Handle loading cargo into a container.\n\n    Medivacs, WarpPrism, Overlords, Nydus.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import PickUpCargo\n\n    unit: Unit # medivac for example\n    grid: np.ndarray = self.mediator.get_ground_grid\n    pickup_targets: Union[Units, list[Unit]] = self.workers\n    self.register_behavior(PickUpCargo(unit, grid, pickup_targets))\n    ```\n\n    Attributes:\n        unit: The container unit.\n        grid: Pathing grid for the container unit.\n        pickup_targets: Units we want to load into the container.\n        cargo_switch_to_role: Sometimes useful to switch cargo to\n            a new role immediately after loading. Defaults to None.\n\n    \"\"\"\n\n    unit: Unit\n    grid: np.ndarray\n    pickup_targets: Union[Units, list[Unit]]\n    cargo_switch_to_role: Optional[UnitRole] = None\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        # no action executed\n        if not self.pickup_targets or self.unit.type_id not in PICKUP_RANGE:\n            # just ensure tags inside are assigned correctly\n            if len(self.unit.passengers_tags) &gt; 0 and self.cargo_switch_to_role:\n                for tag in self.unit.passengers_tags:\n                    mediator.assign_role(tag=tag, role=self.cargo_switch_to_role)\n            return False\n\n        unit_pos: Point2 = self.unit.position\n        target: Unit = cy_closest_to(unit_pos, self.pickup_targets)\n        distance: float = cy_distance_to(self.unit.position, target.position)\n\n        if distance &lt;= PICKUP_RANGE[self.unit.type_id]:\n            self.unit(AbilityId.SMART, target)\n        else:\n            move_to: Point2 = mediator.find_path_next_point(\n                start=unit_pos, target=target.position, grid=self.grid\n            )\n            self.unit.move(move_to)\n\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.place_predictive_aoe.PlacePredictiveAoE","title":"<code>PlacePredictiveAoE</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Predict an enemy position and fire AoE accordingly.</p> <p>Warning: Use this at your own risk. Work in progress.</p> Guess where the enemy is going based on how it's been moving. <p>Cythonize this.</p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to fire the AoE.</p> <code>path</code> <code>List[Point2]</code> <p>How we're getting to the target position (the last point in the list).</p> <code>enemy_center_unit</code> <code>Unit</code> <p>Enemy unit to calculate positions based on.</p> <code>aoe_ability</code> <code>AbilityId</code> <p>AoE ability to use.</p> <code>ability_delay</code> <code>int</code> <p>Amount of frames between using the ability and the ability occurring.</p> Source code in <code>src/ares/behaviors/combat/individual/place_predictive_aoe.py</code> <pre><code>@dataclass\nclass PlacePredictiveAoE(CombatIndividualBehavior):\n    \"\"\"Predict an enemy position and fire AoE accordingly.\n\n    Warning: Use this at your own risk. Work in progress.\n\n    TODO: Guess where the enemy is going based on how it's been moving.\n        Cythonize this.\n\n    Attributes:\n        unit: The unit to fire the AoE.\n        path: How we're getting to the target position (the last point in the list).\n        enemy_center_unit: Enemy unit to calculate positions based on.\n        aoe_ability: AoE ability to use.\n        ability_delay: Amount of frames between using the ability and\n            the ability occurring.\n\n    \"\"\"\n\n    unit: Unit\n    path: List[Point2]\n    enemy_center_unit: Unit\n    aoe_ability: AbilityId\n    ability_delay: int\n    reaper_grenade_range: float = 5.0\n\n    def execute(\n        self, ai: \"AresBot\", config: dict, mediator: ManagerMediator, **kwargs\n    ) -&gt; bool:\n        if self.aoe_ability in self.unit.abilities:\n            # try to fire the ability if we find a position\n            if pos := self._calculate_target_position(ai):\n                if ai.is_visible(pos) and (\n                    cy_distance_to(pos, self.unit.position) &lt; self.reaper_grenade_range\n                ):\n                    return self.unit(self.aoe_ability, pos)\n        # no position found or the ability isn't ready\n        return False\n\n    def _calculate_target_position(self, ai: \"AresBot\") -&gt; Point2:\n        \"\"\"Calculate where we want to put the AoE.\n\n        Returns\n        -------\n        Point2 :\n            Where we want to place the AoE.\n\n        \"\"\"\n        # figure out where our unit is going to be during the chase\n        own_unit_path = self._get_unit_real_path(self.path, self.unit.distance_per_step)\n\n        # enemy path, assuming it moves directly towards our unit at all times\n        chasing_path, _reached_target = self._get_chasing_unit_path(\n            own_unit_path,\n            self.enemy_center_unit.position,\n            self.enemy_center_unit.distance_per_step,\n        )\n\n        # pick the spot along the predicted path that the enemy will have reached when\n        # the ability goes off\n        delayed_idx = math.ceil(self.ability_delay / ai.client.game_step)\n\n        return chasing_path[min(delayed_idx, len(chasing_path) - 1)]\n\n    @staticmethod\n    def _get_unit_next_position(\n        current_position: Point2,\n        current_target: Point2,\n        distance_per_step: float,\n        next_target: Optional[Point2] = None,\n    ) -&gt; Tuple[Point2, bool]:\n        \"\"\"Calculate where a unit will be on the next step.\n\n        Assumes knowledge of the unit's current position, target position, and that the\n        unit will not change direction.\n\n        TODO: handle the case where the unit is fast enough to travel multiple path\n            points per game step\n\n        Parameters\n        ----------\n        current_position: Point2\n            Where the unit currently is.\n        current_target: Point2\n            Where the unit is going.\n        distance_per_step: float\n            How far the unit moves per game step.\n        next_target: Optional[Point2]\n            Where the unit should head if it reaches the target point between steps.\n\n        Returns\n        -------\n        Tuple[Point2, bool] :\n            Point2 is where the unit will be\n            bool is whether the unit reached `current_target` in this step\n\n        \"\"\"\n        reached_target: bool = False\n\n        # make sure we won't run past the target point\n        distance_to_target: float = current_position.distance_to(current_target)\n        if distance_to_target &lt; distance_per_step:\n            if next_target:\n                \"\"\"\n                Overwrite initial values to reflect moving from the current target\n                to the next position.\n                \"\"\"\n                distance_per_step = (\n                    1 - distance_to_target / distance_per_step\n                ) * distance_per_step\n                current_position = current_target\n                current_target = next_target\n                reached_target = True\n            else:\n                # we don't have a next point to go to, so stop at the current target\n                return current_target, True\n\n        # offset the current position towards the target position by the amount of\n        # distance covered per game step\n        return (\n            current_position.towards(current_target, distance_per_step),\n            reached_target,\n        )\n\n    def _get_unit_real_path(\n        self, unit_path: List[Point2], unit_speed: float\n    ) -&gt; List[Point2]:\n        \"\"\"Find the location of the unit at each game step given its path.\n\n        Parameters\n        ----------\n        unit_path: List[Point2]\n            Where the unit is being told to move.\n        unit_speed: float\n            How far the unit moves each game step.\n\n        Returns\n        -------\n        List[Point2] :\n            Where the unit will be at each game iteration.\n\n        \"\"\"\n        real_path: List[Point2] = [unit_path[0]]\n        curr_target_idx: int = 1\n        # 100 should be overkill, but I'm really just trying to avoid a `while` loop\n        for step in range(100):\n            if curr_target_idx &gt;= len(unit_path):\n                # we've made it to the end of the path\n                break\n            # travel directly towards the next point on the path, updating the target\n            # point when the one before it is reached\n            next_position, increase_target_idx = self._get_unit_next_position(\n                current_position=real_path[-1],\n                current_target=unit_path[curr_target_idx],\n                distance_per_step=unit_speed,\n                next_target=unit_path[curr_target_idx + 1]\n                if curr_target_idx != len(unit_path) - 1\n                else None,\n            )\n            real_path.append(next_position)\n\n            if increase_target_idx:\n                # we made it to the current target point, get the next one\n                curr_target_idx += 1\n\n        return real_path\n\n    def _get_chasing_unit_path(\n        self, target_unit_path: List[Point2], start_position: Point2, unit_speed: float\n    ) -&gt; Tuple[List[Point2], bool]:\n        \"\"\"Calculate the path the chasing unit will take to catch the target unit.\n\n        Arguments\n        ---------\n        target_unit_path: List[Point2]\n            Where the target unit is going to be at each game iteration.\n        start_position: Point2\n            Where the chasing unit is starting from.\n        unit_speed: float\n            How far the chasing unit moves per game step.\n\n        Returns\n        -------\n        Tuple[List[Point2], bool] :\n            List[Point2] is the chasing unit's path\n            bool is whether the chasing unit caught the target unit\n\n        \"\"\"\n        reached_target: bool = False\n\n        unit_path: List[Point2] = [start_position]\n        target_idx = 0\n\n        for i in range(100):\n            next_position, reached_target = self._get_unit_next_position(\n                current_position=unit_path[-1],\n                current_target=target_unit_path[target_idx],\n                distance_per_step=unit_speed,\n            )\n            unit_path.append(next_position)\n            # keep updating the target index because we're chasing a moving target, but\n            # stop if the unit we're chasing isn't moving any further\n            target_idx = min(len(target_unit_path) - 1, target_idx + 1)\n\n            if reached_target:\n                # we caught the unit\n                break\n\n        return unit_path, reached_target\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.queen_spread_creep.QueenSpreadCreep","title":"<code>QueenSpreadCreep</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Attempt to spread creep along a path, from <code>start</code> to <code>target</code>.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import QueenSpreadCreep\n\ntarget: Point2 = self.ai.enemy_start_locations[0]\nself.register_behavior(QueenSpreadCreep(queen, queen.position, target))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>Unit</p> <code>cancel_if_close_enemy</code> <code>bool</code> <p>if on route to spread creep, and queen in danger.</p> <code>pre_move_queen_to_tumor</code> <code>bool</code> <p>move queen to tumor placement even if not enough energy to spread creep.</p> Source code in <code>src/ares/behaviors/combat/individual/queen_spread_creep.py</code> <pre><code>@dataclass\nclass QueenSpreadCreep(CombatIndividualBehavior):\n    \"\"\"Attempt to spread creep along a path, from\n    `start` to `target`.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import QueenSpreadCreep\n\n    target: Point2 = self.ai.enemy_start_locations[0]\n    self.register_behavior(QueenSpreadCreep(queen, queen.position, target))\n    ```\n\n    Attributes:\n        unit: Unit\n        cancel_if_close_enemy: if on route to spread creep,\n            and queen in danger.\n        pre_move_queen_to_tumor: move queen to tumor placement even\n            if not enough energy to spread creep.\n    \"\"\"\n\n    unit: Unit\n    cancel_if_close_enemy: bool = True\n    pre_move_queen_to_tumor: bool = True\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        spreading: bool = self.unit.is_using_ability(AbilityId.BUILD_CREEPTUMOR)\n        grid: np.ndarray = mediator.get_cached_ground_grid\n        if spreading and (self.cancel_if_close_enemy or self.pre_move_queen_to_tumor):\n            return KeepUnitSafe(self.unit, grid).execute(ai, config, mediator)\n\n        # queen already spreading creep, leave alone\n        if spreading and not [\n            u\n            for u in mediator.get_own_structures_dict[UnitID.CREEPTUMORQUEEN]\n            if cy_distance_to_squared(self.unit.order_target, u.position) &lt; 3.0\n        ]:\n            return True\n\n        ability_available: bool = (\n            AbilityId.BUILD_CREEPTUMOR_QUEEN in self.unit.abilities\n        )\n\n        edge_position: Point2 = mediator.find_nearby_creep_edge_position(\n            position=self.unit.position,\n            search_radius=200.0,\n            unit_tag=self.unit.tag,\n            cache_result=not ability_available,\n        )\n        if not ability_available:\n            if (\n                edge_position\n                and self.pre_move_queen_to_tumor\n                and cy_distance_to_squared(self.unit.position, edge_position) &gt; 9.0\n            ):\n                self.unit.move(edge_position)\n                return True\n            return False\n\n        creep_spot: Point2 | None = None\n        target: Point2 = (\n            ai.game_info.map_center\n            if not cy_has_creep(mediator.get_creep_grid, self.unit.position)\n            else mediator.get_enemy_nat\n        )\n        if edge_position and mediator.get_creep_coverage &gt; 20.0:\n            creep_spot = edge_position\n        elif tumor_placement := mediator.get_next_tumor_on_path(\n            grid=grid,\n            from_pos=self.unit.position,\n            to_pos=target,\n            find_alternative=True,\n        ):\n            creep_spot = tumor_placement\n\n        if creep_spot:\n            if cy_distance_to_squared(self.unit.position, creep_spot) &gt; 25.0:\n                self.unit.move(creep_spot)\n            else:\n                self.unit(AbilityId.BUILD_CREEPTUMOR_QUEEN, creep_spot)\n            return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.raven_auto_turret.RavenAutoTurret","title":"<code>RavenAutoTurret</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Drop a turret, opinionated and could be improved Create own behavior based on this if needed.</p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>Unit</p> <code>all_close_enemy</code> <code>list[Unit]</code> <p>All close by allied units we want to heal.</p> Source code in <code>src/ares/behaviors/combat/individual/raven_auto_turret.py</code> <pre><code>@dataclass\nclass RavenAutoTurret(CombatIndividualBehavior):\n    \"\"\"Drop a turret, opinionated and could be improved\n    Create own behavior based on this if needed.\n\n    Attributes:\n        unit: Unit\n        all_close_enemy: All close by allied units we want to heal.\n    \"\"\"\n\n    unit: Unit\n    all_close_enemy: list[Unit]\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if AbilityId.BUILDAUTOTURRET_AUTOTURRET not in self.unit.abilities:\n            return False\n\n        only_enemy_units: list[Unit] = [\n            u for u in self.all_close_enemy if u.type_id not in ALL_STRUCTURES\n        ]\n\n        if len(only_enemy_units) &lt;= 1:\n            return False\n\n        if (\n            ai.get_total_supply(only_enemy_units) &gt; 3\n            and AbilityId.BUILDAUTOTURRET_AUTOTURRET in self.unit.abilities\n        ):\n            target: Point2 = cy_closest_to(\n                self.unit.position, only_enemy_units\n            ).position.towards(self.unit, 3.0)\n            if not ai.in_placement_grid(target):\n                return False\n\n            self.unit(AbilityId.BUILDAUTOTURRET_AUTOTURRET, target)\n            return True\n\n        if self.all_close_enemy and not only_enemy_units:\n            target: Point2 = cy_closest_to(\n                self.unit.position, self.all_close_enemy\n            ).position.towards(self.unit, 3.0)\n            if not ai.in_placement_grid(target):\n                return False\n\n            self.unit(AbilityId.BUILDAUTOTURRET_AUTOTURRET, target)\n            return True\n\n        if self.unit.is_using_ability(AbilityId.BUILDAUTOTURRET_AUTOTURRET):\n            return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.reaper_grenade.ReaperGrenade","title":"<code>ReaperGrenade</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Do reaper grenade.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import ReaperGrenade\n\nunit: Unit\ntarget: Unit\nself.register_behavior(DropCargo(unit, target))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The container unit.</p> <code>enemy_units</code> <code>Units | list[Unit]</code> <p>The enemy units.</p> <code>retreat_target</code> <code>Point2</code> <p>The target position where reaper would retreat.</p> <code>grid</code> <code>ndarray</code> <p>The grid used to predicatively place the grenade.</p> <code>place_predictive</code> <code>bool</code> <p>Whether to predicatively place the grenade.</p> <code>reaper_grenade_range</code> <code>float</code> <p>The range at which to use the grenade.</p> Source code in <code>src/ares/behaviors/combat/individual/reaper_grenade.py</code> <pre><code>@dataclass\nclass ReaperGrenade(CombatIndividualBehavior):\n    \"\"\"Do reaper grenade.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import ReaperGrenade\n\n    unit: Unit\n    target: Unit\n    self.register_behavior(DropCargo(unit, target))\n    ```\n\n    Attributes:\n        unit: The container unit.\n        enemy_units: The enemy units.\n        retreat_target: The target position where reaper would retreat.\n        grid: The grid used to predicatively place the grenade.\n        place_predictive: Whether to predicatively place the grenade.\n        reaper_grenade_range: The range at which to use the grenade.\n\n    \"\"\"\n\n    unit: Unit\n    enemy_units: Units | list[Unit]\n    retreat_target: Point2\n    grid: np.ndarray\n    place_predictive: bool = True\n    reaper_grenade_range: float = 5.0\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if (\n            not self.enemy_units\n            or AbilityId.KD8CHARGE_KD8CHARGE not in self.unit.abilities\n        ):\n            return False\n\n        unit_pos: Point2 = self.unit.position\n        targets: list[Unit] = [\n            t\n            for t in self.enemy_units\n            if t.is_visible and not UNIT_DATA[t.type_id][\"flying\"]\n        ]\n        if not targets:\n            return False\n\n        close_unit: Unit = cy_closest_to(unit_pos, targets)\n\n        # close unit is not chasing reaper, throw aggressive grenade\n        if (\n            self.place_predictive\n            and close_unit.type_id not in ALL_WORKER_TYPES\n            and cy_is_facing(self.unit, close_unit, 0.1)\n        ):\n            if path_to_target := mediator.find_raw_path(\n                start=unit_pos,\n                target=close_unit.position,\n                grid=self.grid,\n                sensitivity=1,\n            ):\n\n                if PlacePredictiveAoE(\n                    unit=self.unit,\n                    path=path_to_target[:30],\n                    enemy_center_unit=close_unit,\n                    aoe_ability=AbilityId.KD8CHARGE_KD8CHARGE,\n                    ability_delay=34,\n                ).execute(ai, config=config, mediator=mediator):\n                    return True\n\n        close_targets: list[Unit] = [\n            t\n            for t in self.enemy_units\n            if cy_distance_to_squared(t.position, close_unit.position) &lt; 20\n        ]\n        if (\n            cy_distance_to(close_unit.position, self.unit.position)\n            &lt; self.reaper_grenade_range + close_unit.radius\n            and len(close_targets) &gt;= 2\n        ):\n            if UseAOEAbility(\n                unit=self.unit,\n                ability_id=AbilityId.KD8CHARGE_KD8CHARGE,\n                targets=close_targets,\n                min_targets=2,\n            ).execute(ai, config, mediator):\n                return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.siege_tank_decision.SiegeTankDecision","title":"<code>SiegeTankDecision</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Decide if a tank should either siege or unsiege.</p> <p>VERY OPINIONATED, recommend to write own version based on this.</p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The siege tank unit.</p> <code>close_enemy</code> <code>list[Unit]</code> <p>All close by enemies.</p> <code>target</code> <code>Point2</code> <p>Intended destination for this tank.</p> <code>stay_sieged_near_target</code> <code>bool</code> <p>This is useful for tanks in defensive position. If on offensive, might not be needed Default is False.</p> <code>remain_sieged</code> <code>bool</code> <p>Sometimes we might just want to leave the tank sieged up Default is False.</p> <code>force_unsiege</code> <code>bool</code> <p>We might want to not ever siege Default is False.</p> Source code in <code>src/ares/behaviors/combat/individual/siege_tank_decision.py</code> <pre><code>@dataclass\nclass SiegeTankDecision(CombatIndividualBehavior):\n    \"\"\"Decide if a tank should either siege or unsiege.\n\n    VERY OPINIONATED, recommend to write own version based on this.\n\n    Attributes:\n        unit: The siege tank unit.\n        close_enemy: All close by enemies.\n        target: Intended destination for this tank.\n        stay_sieged_near_target: This is useful for tanks in defensive position.\n            If on offensive, might not be needed\n            Default is False.\n        remain_sieged: Sometimes we might just want to leave the tank sieged up\n            Default is False.\n        force_unsiege: We might want to not ever siege\n            Default is False.\n    \"\"\"\n\n    unit: Unit\n    close_enemy: list[Unit]\n    target: Point2\n    stay_sieged_near_target: bool = False\n    remain_sieged: bool = False\n    force_unsiege: bool = False\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        type_id: UnitID = self.unit.type_id\n        if type_id not in TANK_TYPES:\n            return False\n\n        enemy_ground: list[Unit] = [\n            e\n            for e in self.close_enemy\n            if not e.is_burrowed\n            and e.type_id not in CHANGELING_TYPES\n            and not UNIT_DATA[type_id][\"flying\"]\n        ]\n        unit_pos: Point2 = self.unit.position\n\n        if type_id == UnitID.SIEGETANK:\n            if self.force_unsiege:\n                return False\n\n            # enemy are too close, don't siege no matter what\n            if (\n                len(\n                    [\n                        e\n                        for e in enemy_ground\n                        if cy_distance_to_squared(e.position, unit_pos) &lt; 42.25\n                    ]\n                )\n                &gt; 0\n            ):\n                return False\n\n            # siege up for any enemy static defence\n            if (\n                len(\n                    [\n                        e\n                        for e in enemy_ground\n                        if e.type_id in STATIC_DEFENCE\n                        and cy_distance_to_squared(e.position, self.unit.position)\n                        &lt; 169.0\n                    ]\n                )\n                &gt; 0\n            ):\n                self.unit(AbilityId.SIEGEMODE_SIEGEMODE)\n                return True\n            elif (\n                self.stay_sieged_near_target\n                and cy_distance_to_squared(unit_pos, self.target) &lt; 25.0\n            ):\n                self.unit(AbilityId.SIEGEMODE_SIEGEMODE)\n                return True\n\n            elif (\n                ai.get_total_supply(enemy_ground) &gt;= 4.0 and len(enemy_ground) &gt; 1\n            ) or ([t for t in enemy_ground if t.type_id in TANK_TYPES]):\n                self.unit(AbilityId.SIEGEMODE_SIEGEMODE)\n                return True\n\n        elif type_id == UnitID.SIEGETANKSIEGED:\n            if self.force_unsiege:\n                self.unit(AbilityId.UNSIEGE_UNSIEGE)\n                return True\n\n            # what if we are sieged and ground enemy have got too close\n            if self._enemy_too_close(unit_pos, enemy_ground):\n                self.unit(AbilityId.UNSIEGE_UNSIEGE)\n                return True\n\n            # didn't actually issue an action, but nothing more needs to be done\n            if self.remain_sieged or (\n                self.stay_sieged_near_target\n                and cy_distance_to_squared(unit_pos, self.target) &lt; 49.0\n            ):\n                return False\n\n            # sometimes tanks get isolated a bit, which messes with close enemy calcs\n            # but if there are for example marines ahead, we should stay sieged\n            if self._own_units_between_tank_and_target(mediator):\n                return False\n\n            # just a general if nothing around then unsiege\n            if (\n                len(\n                    [\n                        e\n                        for e in enemy_ground\n                        if e.type_id not in ALL_STRUCTURES\n                        or (\n                            e.type_id in STATIC_DEFENCE\n                            and cy_distance_to_squared(e.position, self.unit.position)\n                            &lt; 110.0\n                        )\n                    ]\n                )\n                == 0\n                and cy_distance_to_squared(unit_pos, self.target) &gt; 200.0\n            ):\n                self.unit(AbilityId.UNSIEGE_UNSIEGE)\n                return True\n\n        # return true for sieged up tanks, as no further action needed\n        # return False for non sieged tanks\n        return type_id == UnitID.SIEGETANKSIEGED\n\n    @staticmethod\n    def _enemy_too_close(unit_pos: Point2, near_enemy_ground) -&gt; bool:\n        return (\n            len(\n                [\n                    e\n                    for e in near_enemy_ground\n                    if cy_distance_to_squared(e.position, unit_pos) &lt; 16.0\n                ]\n            )\n            &gt; 0\n            and len(\n                [\n                    e\n                    for e in near_enemy_ground\n                    if cy_distance_to_squared(e.position, unit_pos) &lt; 144.0\n                ]\n            )\n            &lt; 2\n        )\n\n    def _own_units_between_tank_and_target(self, mediator: ManagerMediator) -&gt; bool:\n        tank_pos: Point2 = self.unit.position\n        target: Point2 = self.target\n\n        midway_point: Point2 = Point2(\n            ((tank_pos.x + target.x) / 2, (tank_pos.y + target.y) / 2)\n        )\n\n        # too far away for consideration\n        if cy_distance_to_squared(tank_pos, midway_point) &gt; 100.0:\n            return False\n\n        own_units_ahead: Units = mediator.get_units_in_range(\n            start_points=[midway_point],\n            distances=12,\n            query_tree=UnitTreeQueryType.AllOwn,\n        )[0].filter(lambda u: not u.is_flying)\n\n        if not own_units_ahead or len(own_units_ahead) &lt; 3:\n            return False\n\n        # own units close enough?\n        closest_to_tank: Unit = cy_closest_to(tank_pos, own_units_ahead)\n        return cy_distance_to_squared(closest_to_tank.position, tank_pos) &lt; 72.25\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.shoot_and_move_to_target.ShootAndMoveToTarget","title":"<code>ShootAndMoveToTarget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>We want to move to a specific point on the map, but shoot     any in range enemies along the way.     Can also optionally shoot destructables.     If unit is left near target     it gets a moved, so keep in mind when calling this method.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import ShootAndMoveToTarget\nself.ai.register_behavior(ShootAndMoveToTarget(\n    unit=unit,\n    enemy_units=enemies,\n    target=target,\n    grid=grid,\n))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit we want tp control.</p> <code>enemy_units</code> <code>Units | list[Unit]</code> <p>The units that we will shoot at while moving.</p> <code>target</code> <code>Point2</code> <p>The position where we want our unit to end up.</p> <code>grid</code> <code>ndarray</code> <p>Grid used for pathfinding.</p> <code>dist_to_target</code> <code>float</code> <p>Distance away from target where pathfinding stops. Default value of 4.0 means that once within 4 tiles of the target we stop pathfinding.</p> <code>attack_destructables</code> <code>bool</code> <p>Whether we should shoot destructibles. Default value is <code>True</code>.</p> Source code in <code>src/ares/behaviors/combat/individual/shoot_and_move_to_target.py</code> <pre><code>@dataclass\nclass ShootAndMoveToTarget(CombatIndividualBehavior):\n    \"\"\"We want to move to a specific point on the map, but shoot\n        any in range enemies along the way.\n        Can also optionally shoot destructables.\n        If unit is left near target\n        it gets a moved, so keep in mind when calling this method.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import ShootAndMoveToTarget\n    self.ai.register_behavior(ShootAndMoveToTarget(\n        unit=unit,\n        enemy_units=enemies,\n        target=target,\n        grid=grid,\n    ))\n    ```\n\n    Attributes:\n        unit: The unit we want tp control.\n        enemy_units: The units that we will shoot at while moving.\n        target: The position where we want our unit to end up.\n        grid: Grid used for pathfinding.\n        dist_to_target: Distance away from target where pathfinding stops.\n            Default value of 4.0 means that once within 4 tiles of the target\n            we stop pathfinding.\n        attack_destructables: Whether we should shoot destructibles.\n            Default value is `True`.\n    \"\"\"\n\n    unit: Unit\n    enemy_units: Units | list[Unit]\n    target: Point2\n    grid: np.ndarray\n    dist_to_target: float = 4.0\n    attack_destructables: bool = True\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if ShootTargetInRange(self.unit, self.enemy_units).execute(\n            ai, config, mediator\n        ):\n            return True\n\n        if self.attack_destructables and ShootTargetInRange(\n            self.unit, ai.destructables\n        ).execute(ai, config, mediator):\n            return True\n\n        if PathUnitToTarget(\n            unit=self.unit,\n            grid=self.grid,\n            target=self.target,\n            success_at_distance=self.dist_to_target,\n        ).execute(ai, config, mediator):\n            return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.shoot_target_in_range.ShootTargetInRange","title":"<code>ShootTargetInRange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Find something to shoot at.</p> Currently only picks lowest health. <p>Might want to pick best one shot KO for example</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import ShootTargetInRange\n\nunit: Unit\ntargets: Units | list[Unit]\nself.register_behavior(ShootTargetInRange(unit, targets))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to shoot.</p> <code>targets</code> <code>list[Unit] | Units</code> <p>Units we want to check.</p> <code>extra_range</code> <code>float</code> <p>Look outside the unit's weapon range. This might be useful for hunting down low HP units.</p> Source code in <code>src/ares/behaviors/combat/individual/shoot_target_in_range.py</code> <pre><code>@dataclass\nclass ShootTargetInRange(CombatIndividualBehavior):\n    \"\"\"Find something to shoot at.\n\n    TODO: Currently only picks lowest health.\n        Might want to pick best one shot KO for example\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import ShootTargetInRange\n\n    unit: Unit\n    targets: Units | list[Unit]\n    self.register_behavior(ShootTargetInRange(unit, targets))\n    ```\n\n    Attributes:\n        unit: The unit to shoot.\n        targets: Units we want to check.\n        extra_range: Look outside the unit's weapon range.\n            This might be useful for hunting down low HP units.\n\n    \"\"\"\n\n    unit: Unit\n    targets: list[Unit] | Units\n    extra_range: float = 0.0\n\n    def execute(\n        self, ai: \"AresBot\", config: dict, mediator: ManagerMediator, **kwargs\n    ) -&gt; bool:\n        if not self.targets:\n            return False\n\n        targets = [\n            t\n            for t in self.targets\n            if not t.is_memory and (not t.is_cloaked or t.is_cloaked and t.is_revealed)\n        ]\n        in_attack_range: list[Unit] = cy_in_attack_range(\n            self.unit, targets, self.extra_range\n        )\n\n        if len(in_attack_range) == 0:\n            return False\n\n        # idea here is if our unit already has an order to shoot one of these\n        # in attack range enemies then we return True but don't issue a\n        # new action\n        if (\n            self.unit.orders\n            and len([u for u in in_attack_range if u.tag == self.unit.order_target])\n            and self.unit.weapon_cooldown == 0.0\n        ):\n            return True\n\n        enemy_target: Unit = cy_pick_enemy_target(in_attack_range)\n\n        if cy_attack_ready(ai, self.unit, enemy_target):\n            self.unit.attack(enemy_target)\n            return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.stutter_unit_back.StutterUnitBack","title":"<code>StutterUnitBack</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Shoot at the target if possible, else move back.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import StutterUnitBack\n\nunit: Unit\ntarget: Unit\nself.register_behavior(StutterUnitBack(unit, target))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to shoot.</p> <code>target</code> <code>Unit</code> <p>The unit we want to shoot at.</p> <code>kite_via_pathing</code> <code>bool</code> <p>Kite back using pathing? Value for <code>grid</code> must be present.</p> <code>grid</code> <code>Optional[ndarray]</code> <p>Pass in if using <code>kite_via_pathing</code>.</p> Source code in <code>src/ares/behaviors/combat/individual/stutter_unit_back.py</code> <pre><code>@dataclass\nclass StutterUnitBack(CombatIndividualBehavior):\n    \"\"\"Shoot at the target if possible, else move back.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import StutterUnitBack\n\n    unit: Unit\n    target: Unit\n    self.register_behavior(StutterUnitBack(unit, target))\n    ```\n\n    Attributes:\n        unit: The unit to shoot.\n        target: The unit we want to shoot at.\n        kite_via_pathing: Kite back using pathing? Value for `grid` must be present.\n        grid: Pass in if using `kite_via_pathing`.\n\n    \"\"\"\n\n    unit: Unit\n    target: Unit\n    kite_via_pathing: bool = True\n    grid: Optional[np.ndarray] = None\n\n    def execute(\n        self, ai: \"AresBot\", config: dict, mediator: ManagerMediator, **kwargs\n    ) -&gt; bool:\n        unit = self.unit\n        target = self.target\n        if self.kite_via_pathing and self.grid is None:\n            self.grid = mediator.get_ground_grid\n\n        if cy_attack_ready(ai, unit, target):\n            return AttackTarget(unit=unit, target=target).execute(ai, config, mediator)\n        elif self.kite_via_pathing and self.grid is not None:\n            return KeepUnitSafe(unit=unit, grid=self.grid).execute(ai, config, mediator)\n        # TODO: Implement non pathing kite back\n        else:\n            logger.warning(\"Stutter back doesn't work for kite_via_pathing=False yet\")\n            return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.stutter_unit_forward.StutterUnitForward","title":"<code>StutterUnitForward</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Shoot at the target if possible, else move back.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import StutterUnitForward\n\nunit: Unit\ntarget: Unit\nself.register_behavior(StutterUnitForward(unit, target))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to shoot.</p> <code>target</code> <code>Unit</code> <p>The unit we want to shoot at.</p> Source code in <code>src/ares/behaviors/combat/individual/stutter_unit_forward.py</code> <pre><code>@dataclass\nclass StutterUnitForward(CombatIndividualBehavior):\n    \"\"\"Shoot at the target if possible, else move back.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import StutterUnitForward\n\n    unit: Unit\n    target: Unit\n    self.register_behavior(StutterUnitForward(unit, target))\n    ```\n\n    Attributes:\n        unit: The unit to shoot.\n        target: The unit we want to shoot at.\n    \"\"\"\n\n    unit: Unit\n    target: Unit\n\n    def execute(\n        self, ai: \"AresBot\", config: dict, mediator: ManagerMediator, **kwargs\n    ) -&gt; bool:\n        unit = self.unit\n        target = self.target\n        if cy_attack_ready(ai, unit, target):\n            return AttackTarget(unit=unit, target=target).execute(ai, config, mediator)\n        else:\n            unit.move(target.position)\n            return True\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.tumor_spread_creep.TumorSpreadCreep","title":"<code>TumorSpreadCreep</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Coordinate tumor spread behavior for creep expansion.</p> <p>Strategy:</p> <ol> <li> <p>Try to spread directly to creep edge if within range</p> </li> <li> <p>If no edges in range, spread in direction furthest from existing tumors</p> </li> <li> <p>If all else fails, spread to random position within range</p> </li> </ol> <p>Example: <pre><code>from ares.behaviors.combat.individual import TumorSpreadCreep\n\ntumors: Units = self.mediator.get_own_structures_dict[UnitID.CREEPTUMORBURROWED]\nfor tumor in tumors:\n    self.register_behavior(\n        TumorSpreadCreep(tumor, self.enemy_start_locations[0])\n    )\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The tumor unit executing the tumor creep spread.</p> <code>target</code> <code>Point2</code> <p>The target point for the tumor placement.</p> Source code in <code>src/ares/behaviors/combat/individual/tumor_spread_creep.py</code> <pre><code>@dataclass\nclass TumorSpreadCreep(CombatIndividualBehavior):\n    \"\"\"Coordinate tumor spread behavior for creep expansion.\n\n    Strategy:\n\n    1. Try to spread directly to creep edge if within range\n\n    2. If no edges in range, spread in direction furthest from existing tumors\n\n    3. If all else fails, spread to random position within range\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import TumorSpreadCreep\n\n    tumors: Units = self.mediator.get_own_structures_dict[UnitID.CREEPTUMORBURROWED]\n    for tumor in tumors:\n        self.register_behavior(\n            TumorSpreadCreep(tumor, self.enemy_start_locations[0])\n        )\n    ```\n\n    Attributes:\n        unit (Unit): The tumor unit executing the tumor creep spread.\n        target (Point2): The target point for the tumor placement.\n    \"\"\"\n\n    unit: Unit\n    target: Point2\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if AbilityId.BUILD_CREEPTUMOR_TUMOR not in self.unit.abilities:\n            return False\n\n        # Strategy 1: Try to spread to nearby creep edges\n        if chosen_pos := mediator.find_nearby_creep_edge_position(\n            position=self.unit.position,\n            search_radius=10.2,\n            closest_valid=False,\n            spread_dist=1.0,\n        ):\n            self.unit(AbilityId.BUILD_CREEPTUMOR, chosen_pos)\n            return True\n\n        # Strategy 2: Random placement as fallback\n        if random_pos := mediator.get_random_creep_position(\n            position=self.unit.position\n        ):\n            self.unit(AbilityId.BUILD_CREEPTUMOR, random_pos)\n            return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.use_ability.UseAbility","title":"<code>UseAbility</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>A-Move a unit to a target.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import UseAbility\nfrom sc2.ids.ability_id import AbilityId\n\nunit: Unit\ntarget: Union[Unit, Point2]\nself.register_behavior(\n    UseAbility(\n        AbilityId.FUNGALGROWTH_FUNGALGROWTH, unit, target\n    )\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>ability</code> <code>AbilityId</code> <p>The ability we want to use.</p> <code>unit</code> <code>Unit</code> <p>The unit to use the ability.</p> <code>target</code> <code>Optional[Union[Point2, Unit]]</code> <p>Target for this ability.</p> Source code in <code>src/ares/behaviors/combat/individual/use_ability.py</code> <pre><code>@dataclass\nclass UseAbility(CombatIndividualBehavior):\n    \"\"\"A-Move a unit to a target.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import UseAbility\n    from sc2.ids.ability_id import AbilityId\n\n    unit: Unit\n    target: Union[Unit, Point2]\n    self.register_behavior(\n        UseAbility(\n            AbilityId.FUNGALGROWTH_FUNGALGROWTH, unit, target\n        )\n    )\n    ```\n\n    Attributes:\n        ability: The ability we want to use.\n        unit: The unit to use the ability.\n        target: Target for this ability.\n\n    \"\"\"\n\n    ability: AbilityId\n    unit: Unit\n    target: Optional[Union[Point2, Unit]] = None\n\n    def execute(\n        self, ai: \"AresBot\", config: dict, mediator: ManagerMediator, **kwargs\n    ) -&gt; bool:\n        if self.ability not in self.unit.abilities:\n            return False\n\n        if self.target:\n            self.unit(self.ability, self.target)\n        else:\n            self.unit(self.ability)\n\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.use_aoe_ability.UseAOEAbility","title":"<code>UseAOEAbility</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Attempt to use AOE ability for a unit.</p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit that potentially has an AOE ability.</p> <code>ability_id</code> <code>AbilityId</code> <p>Ability we want to use.</p> <code>targets</code> <code>list[Unit]</code> <p>The targets we want to hit.</p> <code>min_targets</code> <code>int</code> <p>Minimum targets to hit with spell.</p> <code>avoid_own_flying</code> <code>bool</code> <p>Avoid own flying with this spell? Default is False.</p> <code>avoid_own_ground</code> <code>bool</code> <p>Avoid own ground with this spell? Default is False.</p> <code>bonus_tags</code> <code>Optional[set]</code> <p>Give more emphasize on this unit tags. For example, perhaps a ravager can do corrosive bile Provide enemy tags that are currently fungaled? Default is empty <code>Set</code></p> <code>recalculate</code> <code>bool</code> <p>If unit is already using ability, should we recalculate this behavior? WARNING: could have performance impact Default is False.</p> <code>stack_same_spell</code> <code>bool</code> <p>Stack spell in same position? Default is False.</p> Source code in <code>src/ares/behaviors/combat/individual/use_aoe_ability.py</code> <pre><code>@dataclass\nclass UseAOEAbility(CombatIndividualBehavior):\n    \"\"\"Attempt to use AOE ability for a unit.\n\n    Attributes:\n        unit: The unit that potentially has an AOE ability.\n        ability_id: Ability we want to use.\n        targets: The targets we want to hit.\n        min_targets: Minimum targets to hit with spell.\n        avoid_own_flying: Avoid own flying with this spell?\n            Default is False.\n        avoid_own_ground: Avoid own ground with this spell?\n            Default is False.\n        bonus_tags: Give more emphasize on this unit tags.\n            For example, perhaps a ravager can do corrosive bile\n            Provide enemy tags that are currently fungaled?\n            Default is empty `Set`\n        recalculate: If unit is already using ability, should\n            we recalculate this behavior?\n            WARNING: could have performance impact\n            Default is False.\n        stack_same_spell: Stack spell in same position?\n            Default is False.\n\n    \"\"\"\n\n    unit: Unit\n    ability_id: AbilityId\n    targets: list[Unit]\n    min_targets: int\n    avoid_own_flying: bool = False\n    avoid_own_ground: bool = False\n    bonus_tags: Optional[set] = field(default_factory=set)\n    recalculate: bool = False\n    stack_same_spell: bool = False\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if self.ability_id not in AOE_ABILITY_SPELLS_INFO:\n            logger.warning(\n                f\"You're trying to use {self.ability_id} with `UseAOEAbility`, \"\n                f\"but this behavior doesn't support it\"\n            )\n            return False\n\n        radius: float = AOE_ABILITY_SPELLS_INFO[self.ability_id][\"radius\"]\n        # prevent computation if unit is going to use ability\n        if (\n            not self.recalculate\n            and self.unit.is_using_ability(self.ability_id)\n            and self._can_cast(ai, mediator, self.unit.order_target, radius)\n        ):\n            return True\n\n        # no targets / ability not ready / or\n        # total targets not enough / or not valid ability id\n        if (\n            not self.targets\n            or self.ability_id not in self.unit.abilities\n            or len(self.targets) &lt; self.min_targets\n        ):\n            return False\n\n        position = Point2(\n            cy_find_aoe_position(\n                radius, self.targets, self.min_targets, self.bonus_tags\n            )\n        )\n\n        if self._can_cast(ai, mediator, position, radius):\n            # need to cast on the actual unit\n            if self.ability_id in {\n                AbilityId.PARASITICBOMB_PARASITICBOMB,\n                AbilityId.EFFECT_ANTIARMORMISSILE,\n            }:\n                self.unit(self.ability_id, cy_closest_to(position, self.targets))\n            else:\n                self.unit(self.ability_id, Point2(position))\n\n            return True\n        return False\n\n    def _can_cast(\n        self, ai: \"AresBot\", mediator: ManagerMediator, position: Point2, radius: float\n    ) -&gt; bool:\n        can_cast: bool = (\n            self.min_targets &gt;= 1\n            or len(\n                [\n                    u\n                    for u in self.targets\n                    if cy_distance_to(u.position, position) &lt; radius\n                ]\n            )\n            &gt;= self.min_targets\n        )\n        # check for friendly splash damage\n        if can_cast and self.avoid_own_ground or self.avoid_own_flying:\n            own_in_range = mediator.get_units_in_range(\n                start_points=[position],\n                distances=radius,\n                query_tree=UnitTreeQueryType.AllOwn,\n            )[0]\n            if self.avoid_own_flying and [\n                u for u in own_in_range if UNIT_DATA[u.type_id][\"flying\"]\n            ]:\n                can_cast = False\n            elif self.avoid_own_ground and [\n                u for u in own_in_range if not UNIT_DATA[u.type_id][\"flying\"]\n            ]:\n                can_cast = False\n\n        # check if spell already active in this area\n        if (\n            not self.stack_same_spell\n            and can_cast\n            and (effect_or_buff := AOE_ABILITY_SPELLS_INFO[self.ability_id][\"effect\"])\n        ):\n            if isinstance(effect_or_buff, EffectId):\n                radius: float = AOE_ABILITY_SPELLS_INFO[self.ability_id][\"radius\"]\n                for eff in ai.state.effects:\n                    if eff == effect_or_buff and any(\n                        [\n                            p\n                            for p in eff.positions\n                            if cy_distance_to(position, p) &lt; radius\n                        ]\n                    ):\n                        can_cast = False\n            elif isinstance(effect_or_buff, BuffId):\n                if [u for u in self.targets if u.has_buff(effect_or_buff)]:\n                    can_cast = False\n\n        return can_cast\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.use_transfuse.UseTransfuse","title":"<code>UseTransfuse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Queen tries to transfuse something</p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The queen that should transfuse.</p> <code>targets</code> <code>Union[list[Unit], Units]</code> <p>Our own units to transfuse.</p> <code>extra_range</code> <code>float</code> <p>Look a bit further out of transfuse range? Default is 0.0</p> Source code in <code>src/ares/behaviors/combat/individual/use_transfuse.py</code> <pre><code>@dataclass\nclass UseTransfuse(CombatIndividualBehavior):\n    \"\"\"Queen tries to transfuse something\n\n    Attributes:\n        unit: The queen that should transfuse.\n        targets: Our own units to transfuse.\n        extra_range: Look a bit further out of transfuse range?\n            Default is 0.0\n\n    \"\"\"\n\n    unit: Unit\n    targets: Union[list[Unit], Units]\n    extra_range: float = 0.0\n\n    def execute(\n        self, ai: \"AresBot\", config: dict, mediator: ManagerMediator, **kwargs\n    ) -&gt; bool:\n        if self.unit.is_using_ability(AbilityId.TRANSFUSION_TRANSFUSION):\n            return True\n\n        if AbilityId.TRANSFUSION_TRANSFUSION in self.unit.abilities:\n            transfuse_targets: list[Unit] = [\n                u\n                for u in self.targets\n                if u.health_percentage &lt; 0.4\n                and cy_distance_to(self.unit.position, u.position)\n                &lt; 7.0 + self.unit.radius + u.radius + self.extra_range\n                and u.health_max &gt;= 50.0\n                and u.tag != self.unit.tag\n                and u.tag not in ai.transfused_tags\n            ]\n            if transfuse_targets:\n                ai.transfused_tags.add(transfuse_targets[0].tag)\n                return UseAbility(\n                    AbilityId.TRANSFUSION_TRANSFUSION,\n                    self.unit,\n                    transfuse_targets[0],\n                ).execute(ai, config, mediator)\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/combat_behaviors.html#ares.behaviors.combat.individual.worker_kite_back.WorkerKiteBack","title":"<code>WorkerKiteBack</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatIndividualBehavior</code></p> <p>Shoot at the target if possible, else move back.</p> <p>This is similar to stutter unit back, but takes advantage of mineral walking.</p> <p>Example: <pre><code>from ares.behaviors.combat.individual import WorkerKiteBack\n\nunit: Unit\ntarget: Unit\nself.register_behavior(\n    WorkerKiteBack(\n        unit, target\n    )\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>unit</code> <code>Unit</code> <p>The unit to shoot.</p> <code>target</code> <code>Unit</code> <p>The unit we want to shoot at.</p> Source code in <code>src/ares/behaviors/combat/individual/worker_kite_back.py</code> <pre><code>@dataclass\nclass WorkerKiteBack(CombatIndividualBehavior):\n    \"\"\"Shoot at the target if possible, else move back.\n\n    This is similar to stutter unit back, but takes advantage of\n    mineral walking.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.individual import WorkerKiteBack\n\n    unit: Unit\n    target: Unit\n    self.register_behavior(\n        WorkerKiteBack(\n            unit, target\n        )\n    )\n    ```\n\n    Attributes:\n        unit: The unit to shoot.\n        target: The unit we want to shoot at.\n    \"\"\"\n\n    unit: Unit\n    target: Unit\n\n    def execute(\n        self, ai: \"AresBot\", config: dict, mediator: ManagerMediator, **kwargs\n    ) -&gt; bool:\n        unit = self.unit\n        target = self.target\n        if not target.is_memory and cy_attack_ready(ai, unit, target):\n            return AttackTarget(unit=unit, target=target).execute(ai, config, mediator)\n        elif mfs := ai.mineral_field:\n            unit.gather(cy_closest_to(position=ai.start_location, units=mfs))\n            return True\n</code></pre>"},{"location":"api_reference/behaviors/group_combat_behaviors.html","title":"Group Combat Behaviors","text":""},{"location":"api_reference/behaviors/group_combat_behaviors.html#ares.behaviors.combat.group.a_move_group.AMoveGroup","title":"<code>AMoveGroup</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatGroupBehavior</code></p> <p>A-Move group to a target.</p> <p>Example: <pre><code>from ares.behaviors.combat.group import AMoveGroup\n\nself.register_behavior(AMoveGroup(units, self.game_info.map_center))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>group</code> <code>list[Unit]</code> <p>Units we want to control.</p> <code>group_tags</code> <code>set[int]</code> <p>The group unit tags.</p> <code>target</code> <code>Point2</code> <p>Where the unit is going.</p> Source code in <code>src/ares/behaviors/combat/group/a_move_group.py</code> <pre><code>@dataclass\nclass AMoveGroup(CombatGroupBehavior):\n    \"\"\"A-Move group to a target.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.group import AMoveGroup\n\n    self.register_behavior(AMoveGroup(units, self.game_info.map_center))\n    ```\n\n    Attributes:\n        group (list[Unit]): Units we want to control.\n        group_tags (set[int]): The group unit tags.\n        target (Point2): Where the unit is going.\n    \"\"\"\n\n    group: list[Unit]\n    group_tags: set[int]\n    target: Union[Point2, Unit]\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if len(self.group) == 0:\n            return False\n\n        sorted_units: list[Unit] = cy_sorted_by_distance_to(\n            self.group, self.target.position, reverse=True\n        )\n        if self.duplicate_or_similar_order(\n            sorted_units[0], self.target, AbilityId.ATTACK\n        ):\n            return False\n\n        ai.give_same_action(AbilityId.ATTACK, self.group_tags, self.target)\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/group_combat_behaviors.html#ares.behaviors.combat.group.keep_group_safe.KeepGroupSafe","title":"<code>KeepGroupSafe</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatGroupBehavior</code></p> <p>A-Move group to a target.</p> <p>Example: <pre><code>from ares.behaviors.combat.group import AMoveGroup\n\nself.register_behavior(AMoveGroup(units, self.game_info.map_center))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>group</code> <code>list[Unit]</code> <p>Units we want to control.</p> <code>close_enemy</code> <code>Union[Units, list[Unit]]</code> <p>Nearby enemy.</p> <code>grid</code> <code>ndarray</code> <p>Grid we should check for safety.</p> <code>attack_in_range_enemy</code> <code>bool</code> <p>Whether to attack in range if weapon is ready. Defaults to True.</p> Source code in <code>src/ares/behaviors/combat/group/keep_group_safe.py</code> <pre><code>@dataclass\nclass KeepGroupSafe(CombatGroupBehavior):\n    \"\"\"A-Move group to a target.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.group import AMoveGroup\n\n    self.register_behavior(AMoveGroup(units, self.game_info.map_center))\n    ```\n\n    Attributes:\n        group: Units we want to control.\n        close_enemy: Nearby enemy.\n        grid: Grid we should check for safety.\n        attack_in_range_enemy: Whether to attack in range if weapon is ready.\n            Defaults to True.\n\n    \"\"\"\n\n    group: list[Unit]\n    close_enemy: Union[Units, list[Unit]]\n    grid: np.ndarray\n    attack_in_range_enemy: bool = True\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if len(self.group) == 0:\n            return False\n\n        executed: bool = False\n        for u in self.group:\n            if self.attack_in_range_enemy:\n                if ShootTargetInRange(u, self.close_enemy).execute(\n                    ai, config, mediator\n                ):\n                    continue\n            if KeepUnitSafe(u, self.grid).execute(ai, config, mediator):\n                executed = True\n\n        return executed\n</code></pre>"},{"location":"api_reference/behaviors/group_combat_behaviors.html#ares.behaviors.combat.group.path_group_to_target.PathGroupToTarget","title":"<code>PathGroupToTarget</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatGroupBehavior</code></p> <p>Path a group to its target destination.</p> <p>We issue only one action for the whole group and attempt to filter spammed actions.</p> <p>Example: <pre><code>from ares.behaviors.combat.group import PathGroupToTarget\n\ngroup: list[Unit] = [u for u in self.units]\ngroup_tags: set[int] = {u.tag for u in group}\ngrid: np.ndarray = self.mediator.get_ground_grid\nstart: Point2 = self.ai.start_location\ntarget: Point2 = self.game_info.map_center\n\nself.register_behavior(\n    PathGroupToTarget(start, group, group_tags, grid, target)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>start</code> <code>Point2</code> <p>Where to start the path query.</p> <code>group</code> <code>list[Unit]</code> <p>The actual group units.</p> <code>group_tags</code> <code>set[int]</code> <p>The units to path.</p> <code>grid</code> <code>ndarray</code> <p>2D grid to path on.</p> <code>target</code> <code>Point2</code> <p>Target destination.</p> <code>success_at_distance</code> <code>float</code> <p>If the unit has gotten this close, consider the path behavior complete. Defaults to 0.0.</p> <code>sensitivity</code> <code>int</code> <p>Path precision. Defaults to 5.</p> <code>smoothing</code> <code>bool</code> <p>Whether to smooth out the path. Defaults to False.</p> <code>sense_danger</code> <code>bool</code> <p>Whether to check for dangers. If none are present, the pathing query is skipped. Defaults to False.</p> <code>danger_distance</code> <code>float</code> <p>If <code>sense_danger</code> is True, how far to check for dangers. Defaults to 20.0.</p> <code>danger_threshold</code> <code>float</code> <p>Influence at which a danger is respected. Defaults to 5.0.</p> <code>prevent_duplicate</code> <code>bool</code> <p>Whether to try to prevent spamming actions. Defaults to True.</p> Source code in <code>src/ares/behaviors/combat/group/path_group_to_target.py</code> <pre><code>@dataclass\nclass PathGroupToTarget(CombatGroupBehavior):\n    \"\"\"Path a group to its target destination.\n\n    We issue only one action for the whole group and\n    attempt to filter spammed actions.\n\n\n    Example:\n    ```py\n    from ares.behaviors.combat.group import PathGroupToTarget\n\n    group: list[Unit] = [u for u in self.units]\n    group_tags: set[int] = {u.tag for u in group}\n    grid: np.ndarray = self.mediator.get_ground_grid\n    start: Point2 = self.ai.start_location\n    target: Point2 = self.game_info.map_center\n\n    self.register_behavior(\n        PathGroupToTarget(start, group, group_tags, grid, target)\n    )\n    ```\n\n    Attributes:\n        start: Where to start the path query.\n        group: The actual group units.\n        group_tags: The units to path.\n        grid: 2D grid to path on.\n        target: Target destination.\n        success_at_distance: If the unit has gotten this close,\n            consider the path behavior complete. Defaults to 0.0.\n        sensitivity: Path precision. Defaults to 5.\n        smoothing: Whether to smooth out the path. Defaults to False.\n        sense_danger: Whether to check for dangers. If none are present,\n            the pathing query is skipped. Defaults to False.\n        danger_distance: If `sense_danger` is True, how far to check for dangers.\n            Defaults to 20.0.\n        danger_threshold: Influence at which a danger is respected.\n            Defaults to 5.0.\n        prevent_duplicate: Whether to try to prevent spamming actions.\n            Defaults to True.\n    \"\"\"\n\n    start: Point2\n    group: list[Unit]\n    group_tags: set[int]\n    grid: np.ndarray\n    target: Point2\n    distance_check_squared: float = 26.25\n    success_at_distance: float = 0.0\n    sensitivity: int = 12\n    smoothing: bool = False\n    sense_danger: bool = False\n    danger_distance: float = 20.0\n    danger_threshold: float = 5.0\n    prevent_duplicate: bool = True\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        assert isinstance(\n            self.start, Point2\n        ), f\"{self.start} should be `Point2`, got {type(self.start)}\"\n        assert isinstance(\n            self.target, Point2\n        ), f\"{self.target} should be `Point2`, got {type(self.target)}\"\n\n        if len(self.group) == 0:\n            return False\n\n        distance_to_target: float = cy_distance_to(self.start, self.target)\n        # no action executed\n        if distance_to_target &lt; self.success_at_distance:\n            return False\n\n        move_to: Point2 = mediator.find_path_next_point(\n            start=self.start,\n            target=self.target,\n            grid=self.grid,\n            sensitivity=self.sensitivity,\n            smoothing=self.smoothing,\n            sense_danger=self.sense_danger,\n            danger_distance=self.danger_distance,\n            danger_threshold=self.danger_threshold,\n        )\n\n        if self.prevent_duplicate:\n            sample_unit: Unit = cy_closest_to(self.start, self.group)\n\n            if sample_unit and self.duplicate_or_similar_order(\n                sample_unit,\n                move_to,\n                AbilityId.MOVE,\n                distance_check_squared=self.distance_check_squared,\n            ):\n                return False\n\n        ai.give_same_action(AbilityId.MOVE, self.group_tags, move_to)\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/group_combat_behaviors.html#ares.behaviors.combat.group.stutter_group_back.StutterGroupBack","title":"<code>StutterGroupBack</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatGroupBehavior</code></p> <p>Stutter a group back in unison.</p> <p>Attributes:</p> Name Type Description <code>group</code> <code>list[Unit]</code> <p>The group of units we want to control.</p> <code>group_tags</code> <code>set[int]</code> <p>The group unit tags.</p> <code>group_position</code> <code>Point2</code> <p>The position where this group is situated.</p> <code>target</code> <code>Union[Point2, Unit]</code> <p>Target for the group.</p> <code>grid</code> <code>ndarray</code> <p>Grid this group will use to path on.</p> Source code in <code>src/ares/behaviors/combat/group/stutter_group_back.py</code> <pre><code>@dataclass\nclass StutterGroupBack(CombatGroupBehavior):\n    \"\"\"Stutter a group back in unison.\n\n\n    Attributes:\n        group: The group of units we want to control.\n        group_tags: The group unit tags.\n        group_position: The position where this group is situated.\n        target: Target for the group.\n        grid: Grid this group will use to path on.\n\n    \"\"\"\n\n    group: list[Unit]\n    group_tags: set[int]\n    group_position: Point2\n    target: Union[Point2, Unit]\n    grid: np.ndarray\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if len(self.group) == 0:\n            return False\n\n        sorted_units: list[Unit] = cy_sorted_by_distance_to(\n            self.group, self.target.position, reverse=True\n        )\n        sample_unit: Unit = sorted_units[0]\n\n        if self.group_weapons_on_cooldown(self.group, stutter_forward=False):\n            group_safe: bool = True\n            for unit in self.group:\n                if not mediator.is_position_safe(\n                    grid=self.grid, position=unit.position\n                ):\n                    group_safe = False\n                    break\n            if group_safe:\n                return True\n            if len(self.group) &gt; 1:\n                move_to_target: Point2 = self._calculate_retreat_position(ai)\n                safe_spot: Point2 = mediator.find_closest_safe_spot(\n                    from_pos=move_to_target, grid=self.grid\n                )\n            else:\n                safe_spot: Point2 = mediator.find_closest_safe_spot(\n                    from_pos=self.group_position, grid=self.grid\n                )\n\n            if cy_in_pathing_grid_ma(self.grid, safe_spot):\n                group_move_to: Point2 = mediator.find_path_next_point(\n                    start=self.group_position,\n                    target=safe_spot,\n                    grid=self.grid,\n                    sensitivity=min(len(self.group), 8),\n                )\n                if self.duplicate_or_similar_order(\n                    sample_unit, group_move_to, AbilityId.MOVE\n                ):\n                    return True\n                ai.give_same_action(AbilityId.MOVE, self.group_tags, group_move_to)\n        else:\n            if self.duplicate_or_similar_order(\n                sample_unit, self.target, AbilityId.ATTACK\n            ):\n                return True\n            ai.give_same_action(AbilityId.ATTACK, self.group_tags, self.target.position)\n\n        return True\n\n    def _calculate_retreat_position(self, ai: \"AresBot\") -&gt; Point2:\n        \"\"\"Search 8 directions for somewhere to retreat to.\"\"\"\n        distance = len(self.group) * 1.5\n\n        map_bounds = ai.game_info.map_size\n        best_position: Point2 = self.group_position\n        max_distance_from_target: float = 0.0\n\n        for direction in DIRECTIONS:\n            retreat_position: Point2 = self.group_position + direction * distance\n            retreat_position = Point2(\n                (\n                    max(0, min(map_bounds[0] - 1, retreat_position.x)),\n                    max(0, min(map_bounds[1] - 1, retreat_position.y)),\n                )\n            )\n\n            if cy_in_pathing_grid_ma(self.grid, retreat_position):\n                distance_from_target: float = cy_distance_to_squared(\n                    self.target.position, retreat_position\n                )\n\n                if distance_from_target &gt; max_distance_from_target:\n                    max_distance_from_target = distance_from_target\n                    best_position = retreat_position\n\n        return best_position\n</code></pre>"},{"location":"api_reference/behaviors/group_combat_behaviors.html#ares.behaviors.combat.group.stutter_group_forward.StutterGroupForward","title":"<code>StutterGroupForward</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatGroupBehavior</code></p> <p>Stutter a group forward in unison.</p> <p>Attributes:</p> Name Type Description <code>group</code> <code>list[Unit]</code> <p>The group of units we want to control.</p> <code>group_tags</code> <code>set[int]</code> <p>The group unit tags.</p> <code>group_position</code> <code>Point2</code> <p>The position where this group is situated.</p> <code>target</code> <code>Union[Point2, Unit]</code> <p>Target for the group, used if no enemies are present.</p> <code>enemies</code> <code>Union[Units, list[Unit]]</code> <p>The enemy units we want to stutter towards.</p> Source code in <code>src/ares/behaviors/combat/group/stutter_group_forward.py</code> <pre><code>@dataclass\nclass StutterGroupForward(CombatGroupBehavior):\n    \"\"\"Stutter a group forward in unison.\n\n    Attributes:\n        group: The group of units we want to control.\n        group_tags: The group unit tags.\n        group_position: The position where this group is situated.\n        target: Target for the group, used if no enemies are present.\n        enemies: The enemy units we want to stutter towards.\n\n    \"\"\"\n\n    group: list[Unit]\n    group_tags: set[int]\n    group_position: Point2\n    target: Union[Point2, Unit]\n    enemies: Union[Units, list[Unit]]\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if len(self.group) == 0:\n            return False\n\n        # no enemies, no actions to carry out\n        if not self.enemies:\n            return False\n\n        sorted_units: list[Unit] = cy_sorted_by_distance_to(\n            self.group, self.target.position\n        )\n        sample_unit: Unit = sorted_units[0]\n\n        # if all units are in range of something, don't worry about moving\n        all_in_range: bool = True\n        enemy_center: Point2 = Point2(cy_center(self.enemies))\n        for unit in self.group:\n            in_attack_range: list[Unit] = cy_in_attack_range(unit, self.enemies)\n\n            if not in_attack_range:\n                all_in_range = False\n                break\n\n        # if the whole group are in range of something, then don't bother moving\n        if all_in_range:\n            if not self.duplicate_or_similar_order(\n                sample_unit, self.target, AbilityId.ATTACK\n            ):\n                ai.give_same_action(AbilityId.ATTACK, self.group_tags, enemy_center)\n\n            return True\n\n        if self.group_weapons_on_cooldown(self.group, stutter_forward=True):\n            if self.duplicate_or_similar_order(\n                sample_unit, enemy_center, AbilityId.MOVE\n            ):\n                return True\n            ai.give_same_action(AbilityId.MOVE, self.group_tags, enemy_center)\n        else:\n            if self.duplicate_or_similar_order(\n                sample_unit, enemy_center, AbilityId.ATTACK\n            ):\n                return True\n            ai.give_same_action(AbilityId.ATTACK, self.group_tags, enemy_center)\n\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/group_combat_behaviors.html#ares.behaviors.combat.group.group_use_ability.GroupUseAbility","title":"<code>GroupUseAbility</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CombatGroupBehavior</code></p> <p>Issue a single ability command for a group of units.</p> <p>Example: <pre><code>from ares.behaviors.combat.group import GroupUseAbility\n\nself.register_behavior(\n    GroupUseAbility(\n        AbilityId.MOVE_MOVE,\n        units,\n        {u.tag for u in units}\n        self.game_info.map_center\n    )\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>ability</code> <code>AbilityId</code> <p>Ability we want to use.</p> <code>group</code> <code>list[Unit]</code> <p>Units we want to control.</p> <code>group_tags</code> <code>set[int]</code> <p>The group unit tags.</p> <code>target</code> <code>Union[Point2, Unit, None]</code> <p>The target for this ability.</p> <code>sync_command</code> <code>bool</code> <p>(default=True) If True, wait for all units to be ready before trying ability.</p> Source code in <code>src/ares/behaviors/combat/group/group_use_ability.py</code> <pre><code>@dataclass\nclass GroupUseAbility(CombatGroupBehavior):\n    \"\"\"Issue a single ability command for a group of units.\n\n    Example:\n    ```py\n    from ares.behaviors.combat.group import GroupUseAbility\n\n    self.register_behavior(\n        GroupUseAbility(\n            AbilityId.MOVE_MOVE,\n            units,\n            {u.tag for u in units}\n            self.game_info.map_center\n        )\n    )\n    ```\n\n    Attributes:\n        ability: Ability we want to use.\n        group: Units we want to control.\n        group_tags: The group unit tags.\n        target: The target for this ability.\n        sync_command: (default=True) If True, wait for all units\n            to be ready before trying ability.\n    \"\"\"\n\n    ability: AbilityId\n    group: list[Unit]\n    group_tags: set[int]\n    target: Union[Point2, Unit, None]\n    sync_command: bool = True\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if len(self.group) == 0:\n            return False\n\n        issue_command: bool\n        if self.sync_command:\n            issue_command = all([self.ability in u.abilities for u in self.group])\n        else:\n            issue_command = any([self.ability in u.abilities for u in self.group])\n\n        if not issue_command:\n            return False\n\n        ai.give_same_action(self.ability, self.group_tags, self.target)\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html","title":"Typical Usage","text":"<pre><code>from ares import AresBot\nfrom ares.behaviors.macro.mining import Mining\n\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(MyBot, self).on_step(iteration)\n        self.register_behavior(Mining())\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.macro_plan.MacroPlan","title":"<code>MacroPlan</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Behavior</code></p> <p>Execute macro behaviors sequentially.</p> <p>Idea here is to put macro behaviors in priority order.</p> <p>Example: <pre><code>from ares.behaviors.macro import MacroPlan\nfrom ares.behaviors.macro import (\n    AutoSupply,\n    SpawnController\n)\n\n# initiate a new MacroPlan\nmacro_plan: MacroPlan = MacroPlan()\n\n# then add behaviors in the order they should be executed\nmacro_plan.add(AutoSupply())\nmacro.plan.add(SpawnController(army_composition_dict=self.army_comp))\n\n\n# register the macro plan\nself.ai.register_behavior(macro_plan)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>macros</code> <code>list[Behavior]</code> <p>A list of behaviors that should be executed. Defaults to an empty list.</p> Source code in <code>src/ares/behaviors/macro/macro_plan.py</code> <pre><code>@dataclass\nclass MacroPlan(Behavior):\n    \"\"\"Execute macro behaviors sequentially.\n\n    Idea here is to put macro behaviors in priority order.\n\n    Example:\n    ```py\n    from ares.behaviors.macro import MacroPlan\n    from ares.behaviors.macro import (\n        AutoSupply,\n        SpawnController\n    )\n\n    # initiate a new MacroPlan\n    macro_plan: MacroPlan = MacroPlan()\n\n    # then add behaviors in the order they should be executed\n    macro_plan.add(AutoSupply())\n    macro.plan.add(SpawnController(army_composition_dict=self.army_comp))\n\n\n    # register the macro plan\n    self.ai.register_behavior(macro_plan)\n    ```\n\n    Attributes:\n        macros: A list of behaviors that should be executed. Defaults to an empty list.\n\n    \"\"\"\n\n    macros: list[Behavior] = field(default_factory=list)\n\n    def add(self, behavior: MacroBehavior) -&gt; None:\n        self.macros.append(behavior)\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        for macro in self.macros:\n            if macro.execute(ai, config, mediator):\n                # executed a macro behavior\n                return True\n        # none of the macro behaviors completed, no actions executed\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.addon_swap.AddonSwap","title":"<code>AddonSwap</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>For Terran only, swap 3x3 structures. Pass in two structures and they will swap positions.</p> <p>TODO: Extend this to support an exact swap, ie. swap techlab and reactor</p> <p>Example: <pre><code>from ares.behaviors.macro import AddonSwap\n\n# factory will find a reactor to fly to, any existing\n# structure will fly to the factory's starting position\nself.register_behavior(\n    AddonSwap(factory, UnitID.REACTOR)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>structure_needing_addon</code> <code>Unit | UnitTypeId</code> <p>The structure type we want the addon for.</p> <code>addon_required</code> <code>UnitTypeId</code> <p>Type of addon required.</p> Source code in <code>src/ares/behaviors/macro/addon_swap.py</code> <pre><code>@dataclass\nclass AddonSwap(MacroBehavior):\n    \"\"\"For Terran only, swap 3x3 structures.\n    Pass in two structures and they will swap positions.\n\n    TODO: Extend this to support an exact swap, ie. swap techlab and reactor\n\n\n    Example:\n    ```py\n    from ares.behaviors.macro import AddonSwap\n\n    # factory will find a reactor to fly to, any existing\n    # structure will fly to the factory's starting position\n    self.register_behavior(\n        AddonSwap(factory, UnitID.REACTOR)\n    )\n    ```\n\n    Attributes:\n        structure_needing_addon: The structure type we want the addon for.\n        addon_required: Type of addon required.\n    \"\"\"\n\n    structure_needing_addon: Unit | UnitID\n    addon_required: UnitID\n    precise_addon_structure_id: UnitID | None = None\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        assert ai.race == Race.Terran, \"Can only swap addons with Terran.\"\n        # check if user provided a precise addon into addon_required\n        if self.addon_required not in ADDON_TYPES:\n            assert (\n                self.addon_required in ADD_ONS\n            ), f\"Invalid addon type: {self.addon_required}\"\n            self.precise_addon_structure_id = self.addon_required\n            if self.addon_required in REACTOR_TYPES:\n                self.addon_required = UnitID.REACTOR\n            else:\n                self.addon_required = UnitID.TECHLAB\n        else:\n            assert (\n                self.addon_required in ADDON_TYPES\n            ), f\"`self.addon_required` should be one of {ADDON_TYPES}\"\n\n        if isinstance(self.structure_needing_addon, UnitID):\n            assert (\n                self.structure_needing_addon in ALL_STRUCTURES\n            ), f\"structure_needing_addon should be one of {ALL_STRUCTURES}\"\n            structures: list[Unit] = [\n                s\n                for s in mediator.get_own_structures_dict[self.structure_needing_addon]\n                if s.is_ready and not s.has_add_on\n            ]\n            if len(structures) == 0:\n                return False\n\n            self.structure_needing_addon = structures[0]\n\n        if self.structure_needing_addon.build_progress &lt; 1.0:\n            return False\n\n        search_for_tags: set[int] = (\n            ai.reactor_tags\n            if self.addon_required == UnitID.REACTOR\n            else ai.techlab_tags\n        )\n\n        # search for addon required\n        if self.precise_addon_structure_id:\n            add_ons: list[Unit] = [\n                s\n                for s in ai.structures\n                if s.type_id == self.precise_addon_structure_id\n                and s.tag in search_for_tags\n            ]\n        else:\n            add_ons: list[Unit] = [\n                s\n                for s in ai.structures\n                if s.tag in search_for_tags and s.is_ready and s.is_idle\n            ]\n        if len(add_ons) == 0:\n            return False\n\n        closest_addon: Unit = cy_sorted_by_distance_to(\n            add_ons, self.structure_needing_addon.position\n        )[0]\n\n        # is structure attached to this addon? then move it to `structure_needing_addon`\n        if attached_structures := [\n            s for s in ai.structures if s.add_on_tag == closest_addon.tag\n        ]:\n            mediator.move_structure(\n                structure=attached_structures[0],\n                target=self.structure_needing_addon.position,\n            )\n\n        mediator.move_structure(\n            structure=self.structure_needing_addon,\n            target=closest_addon.add_on_land_position,\n        )\n\n        return True\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.auto_supply.AutoSupply","title":"<code>AutoSupply</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Automatically build supply, works for all races.</p> <p>Example: <pre><code>from ares.behaviors.macro import AutoSupply\n\nself.register_behavior(AutoSupply(self.start_location))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>base_location</code> <code>Point2</code> <p>The base location where supply should be built.</p> <code>return_true_if_supply_required</code> <code>bool</code> <p>If supply can't be afforded but is required, return true. Useful for creating a <code>MacroPlan</code>.</p> Source code in <code>src/ares/behaviors/macro/auto_supply.py</code> <pre><code>@dataclass\nclass AutoSupply(MacroBehavior):\n    \"\"\"Automatically build supply, works for all races.\n\n    Example:\n    ```py\n    from ares.behaviors.macro import AutoSupply\n\n    self.register_behavior(AutoSupply(self.start_location))\n    ```\n\n    Attributes:\n        base_location: The base location where supply should be built.\n        return_true_if_supply_required: If supply can't be afforded but is\n            required, return true. Useful for creating a `MacroPlan`.\n\n    \"\"\"\n\n    base_location: Point2\n    return_true_if_supply_required: bool = True\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if self._num_supply_required(ai, mediator) &gt; 0:\n            supply_type: UnitID = RACE_SUPPLY[ai.race]\n            if ai.race == Race.Zerg:\n                if ai.num_larva_left &gt; 0 and ai.can_afford(supply_type):\n                    ai.train(supply_type)\n                    ai.num_larva_left -= 1\n                    return True\n            else:\n                BuildStructure(self.base_location, supply_type).execute(\n                    ai, config, mediator\n                )\n            return self.return_true_if_supply_required\n\n        return False\n\n    @staticmethod\n    def _num_supply_required(ai: \"AresBot\", mediator: ManagerMediator) -&gt; int:\n        \"\"\"\n        TODO: Improve on this initial version\n            Should calculate based on townhalls for Zerg only?\n            Other races should be calculated based on production available\n        \"\"\"\n        if ai.supply_cap &gt;= 200:\n            return 0\n\n        num_ths: int = len(ai.ready_townhalls)\n        supply_left: float = ai.supply_left\n        supply_used: float = ai.supply_used\n        pending_supply_units: int\n        if ai.race == Race.Zerg:\n            pending_supply_units = cy_unit_pending(ai, UnitID.OVERLORD)\n        else:\n            pending_supply_units = ai.structure_pending(RACE_SUPPLY[ai.race])\n\n        # zerg supply focus around townhalls\n        if ai.race == Race.Zerg:\n            # supply blocked\n            if supply_left &lt;= 0 and pending_supply_units &lt; (num_ths + 1):\n                max_supply: int = num_ths if supply_used &lt; 72 else num_ths + 1\n                return max_supply - pending_supply_units\n\n            # low supply, restrict supply production\n            if 60 &gt; supply_used &gt;= 13:\n                supply_left_threshold: int = 5 if supply_used &lt;= 36 else 6\n                num_building = 1 if supply_left &gt; 0 or supply_used &lt; 29 else 2\n                if (\n                    supply_left &lt;= supply_left_threshold\n                    and pending_supply_units &lt; num_building\n                ):\n                    return num_building - pending_supply_units\n            else:\n                if ai.race == Race.Zerg:\n                    # scale up based on townhalls\n                    if supply_left &lt; 4 * num_ths and pending_supply_units &lt; num_ths:\n                        num: int = num_ths - pending_supply_units\n                        return min(num, 6)\n        # other races supply based on production facilities\n        else:\n            # scale up based on production structures\n            num_production_structures: int = len(\n                ai.structures.filter(\n                    lambda s: s.type_id in ALL_PRODUCTION_STRUCTURES\n                    and s.build_progress == 1.0\n                )\n            )\n            if supply_left &lt;= max(\n                2 * num_production_structures, 5\n            ) and pending_supply_units &lt; math.ceil(num_production_structures / 2):\n                num: int = (\n                    math.ceil(num_production_structures / 2) - pending_supply_units\n                )\n                return min(num, 6)\n\n            # we have no prod structures, just in case\n            elif (\n                num_production_structures == 0\n                and supply_left &lt;= 2\n                and not pending_supply_units\n            ):\n                return 1 - pending_supply_units\n\n        return 0\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.build_structure.BuildStructure","title":"<code>BuildStructure</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Handy behavior for Terran and Protoss. Especially combined with <code>Mining</code> and ares built in placement solver. Finds an ideal mining worker, and an available precalculated placement. Then removes worker from mining records and provides a new role.</p> <p>Example: <pre><code>from ares.behaviors.macro import BuildStructure\n\nself.register_behavior(\n    BuildStructure(self.start_location, UnitTypeId.BARRACKS)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>base_location</code> <code>Point2</code> <p>The base location to build near.</p> <code>structure_id</code> <code>UnitTypeId</code> <p>The structure type we want to build.</p> <code>max_on_route</code> <code>int</code> <p>The max number of workers on route to build this. Defaults to 1.</p> <code>first_pylon</code> <code>bool</code> <p>Will look for the first pylon in placements dict. Defaults to False.</p> <code>static_defence</code> <code>bool</code> <p>Will look for static defense in placements dict. Defaults to False.</p> <code>wall</code> <code>bool</code> <p>Find wall placement if possible. Only the main base is currently supported. Defaults to False.</p> <code>closest_to</code> <code>Optional[Point2]</code> <p>Find placement at this base closest to the given point. Optional.</p> <code>to_count</code> <code>int</code> <p>Prevent going over this amount in total. Defaults to 0, turning this check off.</p> <code>to_count_per_base</code> <code>int</code> <p>Prevent going over this amount at this base location. Defaults to 0, turning this check off.</p> <code>tech_progress_check</code> <code>float</code> <p>Check if tech is ready before trying to build. Defaults to 0.85; setting it to 0.0 turns this check off.</p> Source code in <code>src/ares/behaviors/macro/build_structure.py</code> <pre><code>@dataclass\nclass BuildStructure(MacroBehavior):\n    \"\"\"Handy behavior for Terran and Protoss.\n    Especially combined with `Mining` and ares built in placement solver.\n    Finds an ideal mining worker, and an available precalculated placement.\n    Then removes worker from mining records and provides a new role.\n\n\n    Example:\n    ```py\n    from ares.behaviors.macro import BuildStructure\n\n    self.register_behavior(\n        BuildStructure(self.start_location, UnitTypeId.BARRACKS)\n    )\n    ```\n\n    Attributes:\n        base_location: The base location to build near.\n        structure_id: The structure type we want to build.\n        max_on_route: The max number of workers on route to build this. Defaults to 1.\n        first_pylon: Will look for the first pylon in placements dict.\n            Defaults to False.\n        static_defence: Will look for static defense in placements dict.\n            Defaults to False.\n        wall: Find wall placement if possible. Only the main base is currently\n            supported. Defaults to False.\n        closest_to: Find placement at this base closest to the given point. Optional.\n        to_count: Prevent going over this amount in total.\n            Defaults to 0, turning this check off.\n        to_count_per_base: Prevent going over this amount at this base location.\n            Defaults to 0, turning this check off.\n        tech_progress_check: Check if tech is ready before trying to build.\n            Defaults to 0.85; setting it to 0.0 turns this check off.\n\n    \"\"\"\n\n    base_location: Point2\n    structure_id: UnitID\n    max_on_route: int = 1\n    first_pylon: bool = False\n    static_defence: bool = False\n    wall: bool = False\n    closest_to: Optional[Point2] = None\n    to_count: int = 0\n    to_count_per_base: int = 0\n    tech_progress_check: float = 0.85\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        # already enough workers on route to build this\n        if (\n            ai.not_started_but_in_building_tracker(self.structure_id)\n            &gt;= self.max_on_route\n        ):\n            return False\n        # if `to_count` is set, see if there is already enough\n        if self.to_count and self._enough_existing(ai, mediator):\n            return False\n        # if we have enough at this base\n        if self.to_count_per_base and self._enough_existing_at_this_base(mediator):\n            return False\n\n        # tech progress\n        if (\n            self.tech_progress_check\n            and ai.tech_requirement_progress(self.structure_id)\n            &lt; self.tech_progress_check\n        ):\n            return False\n\n        if ai.race == Race.Zerg:\n            ai.request_zerg_placement(self.base_location, self.structure_id)\n            return True\n\n        within_psionic_matrix: bool = (\n            ai.race == Race.Protoss and self.structure_id != UnitID.PYLON\n        )\n\n        if placement := mediator.request_building_placement(\n            base_location=self.base_location,\n            structure_type=self.structure_id,\n            first_pylon=self.first_pylon,\n            static_defence=self.static_defence,\n            wall=self.wall,\n            within_psionic_matrix=within_psionic_matrix,\n            closest_to=self.closest_to,\n        ):\n            if worker := mediator.select_worker(\n                target_position=placement,\n                force_close=True,\n            ):\n                mediator.build_with_specific_worker(\n                    worker=worker,\n                    structure_type=self.structure_id,\n                    pos=placement,\n                )\n                return True\n        return False\n\n    def _enough_existing(self, ai: \"AresBot\", mediator: ManagerMediator) -&gt; bool:\n        existing_structures = mediator.get_own_structures_dict[self.structure_id]\n        num_existing: int = len(\n            [s for s in existing_structures if s.is_ready]\n        ) + ai.structure_pending(self.structure_id)\n        return num_existing &gt;= self.to_count\n\n    def _enough_existing_at_this_base(self, mediator: ManagerMediator) -&gt; bool:\n        placement_dict: dict = mediator.get_placements_dict\n        size: BuildingSize = STRUCTURE_TO_BUILDING_SIZE[self.structure_id]\n        potential_placements: dict[Point2:dict] = placement_dict[self.base_location][\n            size\n        ]\n        taken: list[Point2] = [\n            placement\n            for placement in potential_placements\n            if not potential_placements[placement][\"available\"]\n        ]\n        num_structures: int = 0\n        for t in taken:\n            if [\n                s\n                for s in mediator.get_own_structures_dict[self.structure_id]\n                if cy_distance_to_squared(s.position, t) &lt; 9.0\n            ]:\n                num_structures += 1\n        return num_structures &gt;= self.to_count_per_base\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.build_workers.BuildWorkers","title":"<code>BuildWorkers</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Finds idle townhalls / larvae and build workers.</p> <p>Example: <pre><code>from ares.behaviors.macro import BuildWorkers\n\nself.register_behavior(\n    BuildWorkers(to_count=80)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>to_count</code> <code>int</code> <p>The target count of workers we want to hit.</p> Source code in <code>src/ares/behaviors/macro/build_workers.py</code> <pre><code>@dataclass\nclass BuildWorkers(MacroBehavior):\n    \"\"\"Finds idle townhalls / larvae and build workers.\n\n    Example:\n    ```py\n    from ares.behaviors.macro import BuildWorkers\n\n    self.register_behavior(\n        BuildWorkers(to_count=80)\n    )\n    ```\n\n    Attributes:\n        to_count: The target count of workers we want to hit.\n\n    \"\"\"\n\n    to_count: int\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        worker_type: UnitID = ai.worker_type\n        if (\n            ai.can_afford(worker_type)\n            and ai.townhalls.idle\n            and ai.supply_workers &lt; self.to_count\n        ):\n            return SpawnController(\n                {\n                    worker_type: {\"proportion\": 1.0, \"priority\": 0},\n                }\n            ).execute(ai, config, mediator)\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.expansion_controller.ExpansionController","title":"<code>ExpansionController</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Manage expanding.</p> <p>Example: <pre><code>from ares.behaviors.macro import ExpansionController\n\nself.register_behavior(\n    ExpansionController(to_count=8, max_pending=2)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>to_count</code> <code>int</code> <p>The target base count.</p> <code>can_afford_check</code> <code>bool</code> <p>Check if we can afford expansion. Setting this to False will allow the worker to move to a location ready to build the expansion. Defaults to True.</p> <code>check_location_is_safe</code> <code>bool</code> <p>Check if we don't knowingly expand at a dangerous location. Defaults to True.</p> <code>max_pending</code> <code>int</code> <p>Maximum pending townhalls at any time. Defaults to 1.</p> <code>prioritize</code> <code>bool</code> <p>If True and there is a CC waiting to upgrade, but we can't afford it yet, this behavior will return True This is useful in a MacroPlan as it will prevent other spending actions occurring. Default is False</p> Source code in <code>src/ares/behaviors/macro/expansion_controller.py</code> <pre><code>@dataclass\nclass ExpansionController(MacroBehavior):\n    \"\"\"Manage expanding.\n\n    Example:\n    ```py\n    from ares.behaviors.macro import ExpansionController\n\n    self.register_behavior(\n        ExpansionController(to_count=8, max_pending=2)\n    )\n    ```\n\n    Attributes:\n        to_count: The target base count.\n        can_afford_check: Check if we can afford expansion. Setting this to False\n            will allow the worker to move to a location ready to build the expansion.\n            Defaults to True.\n        check_location_is_safe: Check if we don't knowingly expand at a dangerous\n            location. Defaults to True.\n        max_pending: Maximum pending townhalls at any time. Defaults to 1.\n        prioritize: If True and there is a CC waiting to upgrade, but\n            we can't afford it yet, this behavior will return True\n            This is useful in a MacroPlan as it will prevent other\n            spending actions occurring.\n            Default is False\n    \"\"\"\n\n    to_count: int\n    can_afford_check: bool = True\n    check_location_is_safe: bool = True\n    max_pending: int = 1\n    prioritize: bool = False\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        # already have enough / or enough pending\n        if (\n            len([th for th in ai.townhalls if th.is_ready])\n            + ai.structure_pending(ai.base_townhall_type)\n            &gt;= self.to_count\n            or ai.structure_pending(ai.base_townhall_type) &gt;= self.max_pending\n            or (\n                self.can_afford_check\n                and not self.prioritize\n                and not ai.can_afford(ai.base_townhall_type)\n            )\n        ):\n            return False\n\n        if location := self._get_next_expansion_location(mediator):\n            if worker := mediator.select_worker(target_position=location):\n                mediator.build_with_specific_worker(\n                    worker=worker, structure_type=ai.base_townhall_type, pos=location\n                )\n                return True\n\n        return False\n\n    def _get_next_expansion_location(\n        self, mediator: ManagerMediator\n    ) -&gt; Optional[Point2]:\n        grid: np.ndarray = mediator.get_ground_grid\n        for el in mediator.get_own_expansions:\n            location: Point2 = el[0]\n            if (\n                self.check_location_is_safe\n                and not mediator.is_position_safe(grid=grid, position=location)\n                or self._location_is_blocked(mediator, location)\n            ):\n                continue\n\n            return location\n\n    @staticmethod\n    def _location_is_blocked(mediator: ManagerMediator, position: Point2) -&gt; bool:\n        \"\"\"\n        Check if enemy or own townhalls are blocking `position`.\n\n        Parameters\n        ----------\n        mediator : ManagerMediator\n        position : Point2\n\n        Returns\n        -------\n        bool : True if location is blocked by something.\n\n        \"\"\"\n        # TODO: Not currently an issue, but maybe we should consider rocks\n        close_enemy: Units = mediator.get_units_in_range(\n            start_points=[position],\n            distances=5.5,\n            query_tree=UnitTreeQueryType.EnemyGround,\n        )[0]\n\n        close_enemy: Units = close_enemy.filter(\n            lambda u: u.type_id != UnitID.AUTOTURRET\n        )\n        if close_enemy:\n            return True\n\n        if mediator.get_units_in_range(\n            start_points=[position],\n            distances=5.5,\n            query_tree=UnitTreeQueryType.AllOwn,\n        )[0].filter(lambda u: u.type_id in TOWNHALL_TYPES):\n            return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.gas_building_controller.GasBuildingController","title":"<code>GasBuildingController</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Maintain gas building count. Finds an ideal mining worker, and an available geyser. Then removes worker from mining records and provides a new role.</p> <p>Example: <pre><code>from ares.behaviors.macro import GasBuildingController\n\nself.register_behavior(\n    GasBuildingController(to_count=len(self.townhalls)*2)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>to_count</code> <code>int</code> <p>How many gas buildings would we like?</p> <code>max_pending</code> <code>int</code> <p>How many gas buildings can be pending at any time? Defaults to 1.</p> <code>closest_to</code> <code>Optional[Point2]</code> <p>Find available geyser closest to this location. Optional, defaults to <code>None</code></p> Source code in <code>src/ares/behaviors/macro/gas_building_controller.py</code> <pre><code>@dataclass\nclass GasBuildingController(MacroBehavior):\n    \"\"\"Maintain gas building count.\n    Finds an ideal mining worker, and an available geyser.\n    Then removes worker from mining records and provides a new role.\n\n\n    Example:\n    ```py\n    from ares.behaviors.macro import GasBuildingController\n\n    self.register_behavior(\n        GasBuildingController(to_count=len(self.townhalls)*2)\n    )\n    ```\n\n    Attributes:\n        to_count: How many gas buildings would we like?\n        max_pending: How many gas buildings can be pending at any time?\n            Defaults to 1.\n        closest_to: Find available geyser closest to this location.\n            Optional, defaults to `None`\n\n    \"\"\"\n\n    to_count: int\n    max_pending: int = 1\n    closest_to: Optional[Point2] = None\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        num_gas: int\n        if ai.race == Race.Terran:\n            num_gas = ai.not_started_but_in_building_tracker(ai.gas_type) + len(\n                ai.gas_buildings\n            )\n        else:\n            num_gas = len(ai.gas_buildings) + mediator.get_building_counter[ai.gas_type]\n        # we have enough gas / building gas then don't attempt behavior\n        if (\n            num_gas &gt;= self.to_count\n            or mediator.get_building_counter[ai.gas_type] &gt;= self.max_pending\n            or ai.minerals &lt; 35\n        ):\n            return False\n\n        existing_gas_buildings: Units = ai.all_gas_buildings\n        if available_geysers := [\n            u\n            for u in ai.vespene_geyser\n            if not [\n                g\n                for g in existing_gas_buildings\n                if cy_distance_to_squared(u.position, g.position) &lt; 25.0\n            ]\n            and [\n                th\n                for th in ai.townhalls\n                if cy_distance_to_squared(u.position, th.position) &lt; 144.0\n                and th.build_progress &gt; 0.7\n            ]\n        ]:\n            if not self.closest_to:\n                self.closest_to = ai.start_location\n\n            available_geysers = cy_sorted_by_distance_to(\n                available_geysers, self.closest_to\n            )\n            if worker := mediator.select_worker(\n                target_position=available_geysers[0], force_close=True\n            ):\n                mediator.build_with_specific_worker(\n                    worker=worker,\n                    structure_type=ai.gas_type,\n                    pos=available_geysers[0],\n                )\n                return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.mining.Mining","title":"<code>Mining</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Handle worker mining control.</p> <p>Note: Could technically be <code>CombatBehavior</code>, but is treated here as a MacroBehavior since many tasks are carried out.</p> <p>Example: <pre><code>from ares.behaviors.macro import Mining\n\nself.register_behavior(Mining())\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>flee_at_health_perc</code> <code>float</code> <p>If worker is in danger, at what health percentage should it flee? Defaults to 0.5.</p> <code>keep_safe</code> <code>bool</code> <p>Should workers flee if they are in danger? Defaults to True.</p> <code>long_distance_mine</code> <code>bool</code> <p>Can the worker long distance mine if it has nothing to do? Defaults to True.</p> <code>mineral_boost</code> <code>bool</code> <p>Turn mineral boosting on or off. Defaults to True.</p> <code>vespene_boost</code> <code>bool</code> <p>Turn vespene boosting on or off (only active when workers_per_gas &lt; 3). WARNING: VESPENE BOOSTING CURRENTLY NOT WORKING. Defaults to True.</p> <code>workers_per_gas</code> <code>int</code> <p>Control how many workers are assigned to each gas. Defaults to 3.</p> <code>self_defence_active</code> <code>bool</code> <p>If set to True, workers will have some basic defence. Certain workers will attack enemy in range. Defaults to True.</p> <code>safe_long_distance_mineral_fields</code> <code>Optional[Units]</code> <p>Used internally, set when a worker starts long distance mining. Defaults to None.</p> <code>weight_safety_limit</code> <code>float</code> <p>Workers will flee if enemy influence is above this number. Defaults to 12.0</p> Source code in <code>src/ares/behaviors/macro/mining.py</code> <pre><code>@dataclass\nclass Mining(MacroBehavior):\n    \"\"\"Handle worker mining control.\n\n    Note: Could technically be `CombatBehavior`, but is treated here as a\n    MacroBehavior since many tasks are carried out.\n\n    Example:\n    ```py\n    from ares.behaviors.macro import Mining\n\n    self.register_behavior(Mining())\n    ```\n\n    Attributes:\n        flee_at_health_perc: If worker is in danger, at what\n            health percentage should it flee? Defaults to 0.5.\n        keep_safe: Should workers flee if they are in danger?\n            Defaults to True.\n        long_distance_mine: Can the worker long distance mine if it has nothing to do?\n            Defaults to True.\n        mineral_boost: Turn mineral boosting on or off. Defaults to True.\n        vespene_boost: Turn vespene boosting on or off\n            (only active when workers_per_gas &lt; 3).\n            WARNING: VESPENE BOOSTING CURRENTLY NOT WORKING.\n            Defaults to True.\n        workers_per_gas: Control how many workers are assigned to each gas.\n            Defaults to 3.\n        self_defence_active: If set to True, workers will have some basic defence.\n            Certain workers will attack enemy in range. Defaults to True.\n        safe_long_distance_mineral_fields: Used internally, set when a worker starts\n            long distance mining. Defaults to None.\n        weight_safety_limit: Workers will flee if enemy influence is above this number.\n            Defaults to 12.0\n\n    \"\"\"\n\n    flee_at_health_perc: float = 0.5\n    keep_safe: bool = True\n    long_distance_mine: bool = True\n    mineral_boost: bool = True\n    vespene_boost: bool = False\n    workers_per_gas: int = 3\n    self_defence_active: bool = True\n    safe_long_distance_mineral_fields: Optional[Units] = None\n    locked_action_tags: dict[int, float] = field(default_factory=dict)\n    weight_safety_limit: float = 12.0\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        workers: Units = mediator.get_units_from_role(\n            role=UnitRole.GATHERING,\n            unit_type=ai.worker_type,\n        )\n        if not workers:\n            return False\n\n        resources_dict: dict[int, Unit] = ai.unit_tag_dict\n        health_perc: float = self.flee_at_health_perc\n        avoidance_grid: np.ndarray = mediator.get_ground_avoidance_grid\n        grid: np.ndarray = mediator.get_ground_grid\n        mineral_patch_to_list_of_workers: dict[\n            int, set[int]\n        ] = mediator.get_mineral_patch_to_list_of_workers\n        path_find: Callable = mediator.find_path_next_point\n        pos_safe: Callable = mediator.is_position_safe\n        th_dist_factor: float = config[MINING][TOWNHALL_DISTANCE_FACTOR]\n        worker_to_geyser_dict: dict[int, int] = mediator.get_worker_to_vespene_dict\n        worker_to_mineral_patch_dict: dict[\n            int, int\n        ] = mediator.get_worker_to_mineral_patch_dict\n        worker_to_th: dict[int, int] = mediator.get_worker_tag_to_townhall_tag\n        # for each mineral tag, get the position in front of the mineral\n        min_target: dict[int, Point2] = mediator.get_mineral_target_dict\n        main_enemy_ground_threats: Optional[Units] = None\n        race: Race = ai.race\n        if self.self_defence_active:\n            main_enemy_ground_threats = mediator.get_main_ground_threats_near_townhall\n\n        for worker in workers:\n            worker_position: Point2 = worker.position\n            worker_tag: int = worker.tag\n            resource: Optional[Unit] = None\n            resource_position: Optional[Point2] = None\n            resource_tag: int = -1\n\n            assigned_mineral_patch: bool = worker_tag in worker_to_mineral_patch_dict\n            assigned_gas_building: bool = worker_tag in worker_to_geyser_dict\n            dist_to_resource: float = 15.0\n            if assigned_mineral_patch or assigned_gas_building:\n                resource_tag: int = (\n                    worker_to_mineral_patch_dict[worker_tag]\n                    if assigned_mineral_patch\n                    else worker_to_geyser_dict[worker_tag]\n                )\n                # using try except is faster than dict.get()\n                try:\n                    _resource = resources_dict[resource_tag]\n                    resource_position = _resource.position\n                    resource_tag = _resource.tag\n                    resource = _resource\n                    dist_to_resource = cy_distance_to(\n                        worker_position, resource_position\n                    )\n                    if (\n                        resource.type_id in GAS_BUILDINGS\n                        and resource.vespene_contents == 0\n                    ):\n                        mediator.remove_gas_building(gas_building_tag=resource_tag)\n\n                except KeyError:\n                    # Mined out or no vision? Remove it\n                    if assigned_mineral_patch:\n                        mediator.remove_mineral_field(mineral_field_tag=resource_tag)\n                    else:\n                        mediator.remove_gas_building(gas_building_tag=resource_tag)\n                    continue\n\n            perc_health: float = (\n                worker.health_percentage\n                if race != Race.Protoss\n                else worker.shield_health_percentage\n            )\n            worker_safe: bool = pos_safe(grid=grid, position=worker_position)\n            # keeping worker safe is first priority\n            if self.keep_safe and (\n                # lib zone / nukes etc\n                not pos_safe(grid=avoidance_grid, position=worker_position)\n                # retreat based on self.flee_at_health_perc value\n                or (perc_health &lt;= health_perc and not worker_safe)\n                or not pos_safe(\n                    grid=grid,\n                    position=worker_position,\n                    weight_safety_limit=self.weight_safety_limit,\n                )\n            ):\n                self._keep_worker_safe(mediator, grid, worker)\n\n            elif (\n                not worker_safe\n                and main_enemy_ground_threats\n                and self._worker_attacking_enemy(ai, dist_to_resource, worker)\n            ):\n                pass\n\n            # do we have record of this worker? If so mine from the relevant resource\n            elif ai.townhalls and (assigned_mineral_patch or assigned_gas_building):\n                # we are far away, path to min field to avoid enemies\n                if dist_to_resource &gt; 6.0 and not worker.is_carrying_resource:\n                    worker.move(\n                        path_find(\n                            start=worker_position,\n                            target=resource_position,\n                            grid=grid,\n                        )\n                    )\n\n                # fix realtime bug where worker is stuck with a move command\n                # but already returned minerals\n                elif (\n                    len(worker.orders) == 1\n                    and worker.orders[0].ability.id == AbilityId.MOVE\n                    and ai.ready_townhalls\n                    and worker.order_target\n                    == cy_closest_to(worker_position, ai.ready_townhalls).tag\n                    # shift worker to correct resource if it ends up on wrong one\n                ) or (worker.is_gathering and worker.order_target != resource_tag):\n                    # target being the mineral\n                    worker(AbilityId.SMART, resource)\n\n                elif (self.mineral_boost and assigned_mineral_patch) or (\n                    self.vespene_boost and self.workers_per_gas &lt; 3\n                ):\n                    self._do_mining_boost(\n                        ai,\n                        th_dist_factor,\n                        min_target,\n                        resource,\n                        worker,\n                        worker_to_th,\n                        worker_position,\n                        resource_position,\n                    )\n                else:\n                    self._do_standard_mining(ai, worker, resource)\n\n            # nowhere for this worker to go, long distance mining\n            elif self.long_distance_mine and ai.minerals and ai.townhalls:\n                self._long_distance_mining(\n                    ai,\n                    mediator,\n                    grid,\n                    worker,\n                    mineral_patch_to_list_of_workers,\n                    worker_position,\n                )\n\n            # this worker really has nothing to do, keep it safe at least\n            # don't mine from anywhere since user requested no `long_distance_mine`\n            elif not pos_safe(grid=grid, position=worker_position):\n                self._keep_worker_safe(mediator, grid, worker)\n\n        mediator.set_workers_per_gas(amount=self.workers_per_gas)\n        return True\n\n    @staticmethod\n    def _keep_worker_safe(\n        mediator: ManagerMediator, grid: np.ndarray, worker: Unit\n    ) -&gt; None:\n        \"\"\"Logic for keeping workers in danger safe.\n\n        Parameters:\n            mediator: ManagerMediator used for getting information from\n                other managers.\n            grid: Ground grid with enemy influence.\n            worker: Worker to keep safe.\n        \"\"\"\n        worker.move(\n            mediator.find_closest_safe_spot(from_pos=worker.position, grid=grid)\n        )\n\n    def _do_standard_mining(self, ai: \"AresBot\", worker: Unit, resource: Unit) -&gt; None:\n        worker_tag: int = worker.tag\n        # prevent spam clicking workers on patch to reduce APM\n        if worker_tag in self.locked_action_tags:\n            if ai.time &gt; self.locked_action_tags[worker_tag] + 0.5:\n                self.locked_action_tags.pop(worker_tag)\n            return\n        # moved worker from gas\n        if worker.is_carrying_vespene and resource.is_mineral_field:\n            worker.return_resource()\n            self.locked_action_tags[worker_tag] = ai.time\n        else:\n            # leave worker alone\n            if len(worker.orders) &gt; 0:\n                current_order = worker.orders[0]\n                if current_order.ability.id == AbilityId.HARVEST_RETURN:\n                    return\n\n            # work out when we need to issue command to mine resource\n            if worker.is_idle or (\n                cy_distance_to_squared(worker.position, resource.position) &gt; 81.0\n                and worker.order_target\n                and worker.order_target != resource\n            ):\n                worker.gather(resource)\n                self.locked_action_tags[worker_tag] = ai.time\n                return\n\n            # force worker to stay on correct resource\n            # in game auto mining will sometimes shift worker\n            if (\n                not worker.is_carrying_minerals\n                and not worker.is_carrying_vespene\n                and worker.order_target != resource.tag\n            ):\n                worker.gather(resource)\n                # to reduce apm we prevent spam clicking on same mineral\n                self.locked_action_tags[worker_tag] = ai.time\n\n    def _long_distance_mining(\n        self,\n        ai: \"AresBot\",\n        mediator: ManagerMediator,\n        grid: np.ndarray,\n        worker: Unit,\n        mineral_patch_to_list_of_workers: dict[int, set[int]],\n        worker_position: Point2,\n    ) -&gt; None:\n        \"\"\"Logic for long distance mining.\n\n        Parameters\n        ----------\n        ai : AresBot\n            Bot object that will be running the game.\n        mediator : ManagerMediator\n            Used for getting information from other managers.\n        grid : np.ndarray\n            Ground grid with enemy influence.\n        worker: Unit\n            Worker we want to issue actions to.\n        mineral_patch_to_list_of_workers: dict\n            Record of assigned mineral patches, so we know which ones to avoid.\n        worker_position :\n            Pass this in for optimization purposes.\n        Returns\n        -------\n\n        \"\"\"\n        if (\n            worker.is_gathering\n            and worker.order_target not in mediator.get_mineral_patch_to_list_of_workers\n        ):\n            return\n\n        completed_bases: Units = ai.townhalls.ready\n        # there is nowhere to return resources!\n        if not completed_bases:\n            return\n\n        if not self.safe_long_distance_mineral_fields:\n            self.safe_long_distance_mineral_fields = (\n                self._safe_long_distance_mineral_fields(ai, mediator)\n            )\n\n        target_mineral: Optional[Unit] = None\n\n        # on route to a far mineral patch\n        if (\n            (not worker.is_gathering and not worker.is_carrying_resource)\n            # mining somewhere we manage ourselves\n            or (\n                worker.order_target\n                and worker.order_target in mineral_patch_to_list_of_workers\n            )\n        ):\n            # if there is a pending base, we should mine from there\n            pending_bases: Units = ai.townhalls.filter(lambda th: not th.is_ready)\n            if pending_bases and ai.mineral_field:\n                target_base: Unit = cy_closest_to(worker_position, pending_bases)\n                target_mineral = cy_closest_to(target_base.position, ai.mineral_field)\n            # no pending base, find a mineral field\n            elif self.safe_long_distance_mineral_fields:\n                # early game, get closest to natural\n                if ai.time &lt; 260.0:\n                    target_mineral = cy_closest_to(\n                        mediator.get_own_nat, self.safe_long_distance_mineral_fields\n                    )\n                else:\n                    target_mineral = cy_closest_to(\n                        worker.position, self.safe_long_distance_mineral_fields\n                    )\n\n            if target_mineral:\n                target_mineral_position: Point2 = target_mineral.position\n                if (\n                    not mediator.is_position_safe(\n                        grid=grid,\n                        position=worker_position,\n                    )\n                    and cy_distance_to_squared(worker_position, target_mineral_position)\n                    &gt; 25.0\n                ):\n                    move_to: Point2 = mediator.find_path_next_point(\n                        start=worker_position,\n                        target=target_mineral_position,\n                        grid=grid,\n                        sense_danger=False,\n                    )\n                    worker.move(move_to)\n                elif ai.mineral_field:\n                    if worker.order_target and worker.order_target == target_mineral:\n                        return\n                    worker.gather(target_mineral)\n        # worker is travelling back to a ready townhall\n        else:\n            if worker.is_returning:\n                return\n            return_base: Unit = cy_closest_to(worker_position, completed_bases)\n            return_base_position: Point2 = return_base.position\n            if (\n                not mediator.is_position_safe(grid=grid, position=worker_position)\n                and cy_distance_to_squared(worker_position, return_base_position) &gt; 64.0\n            ):\n                move_to: Point2 = mediator.find_path_next_point(\n                    start=worker_position,\n                    target=return_base_position,\n                    grid=grid,\n                    sense_danger=False,\n                )\n                worker.move(move_to)\n            else:\n                worker.return_resource()\n\n    @staticmethod\n    def _do_mining_boost(\n        ai,\n        distance_to_townhall_factor,\n        mineral_target_dict,\n        target,\n        worker,\n        worker_tag_to_townhall_tag,\n        worker_position: Point2,\n        target_position: Point2,\n    ) -&gt; bool:\n        \"\"\"Perform the trick so that worker does not decelerate.\n\n        This avoids worker deceleration when mining by issuing a Move command near a\n        mineral patch/townhall and then issuing a Gather or Return command once the\n        worker is close enough to immediately perform the action instead of issuing a\n        Gather command and letting the SC2 engine manage the worker.\n\n        Parameters:\n            ai: Main AresBot object\n            distance_to_townhall_factor: Multiplier used for finding the target\n                of the Move command when returning resources.\n            target: Mineral field or Townhall that the worker should be\n                moving toward/performing an action on.\n            worker: The worker being boosted.\n            worker_tag_to_townhall_tag: The townhall this worker belongs to,\n                or where resources will be returned.\n            worker_position: Pass in for optimization purposes.\n            target_position: Pass in for optimization purposes.\n\n        Returns:\n            Whether this method carries out an action\n        \"\"\"\n\n        if target.is_mineral_field or target.is_vespene_geyser:\n            try:\n                resource_target_pos: Point2 = mineral_target_dict[target_position]\n            except KeyError:\n                logger.warning(\n                    f\"{target_position} not found in resource_target_pos, \"\n                    f\"no action will be provided for f{worker.tag}\"\n                )\n                return False\n        else:\n            resource_target_pos: Point2 = Point2(\n                cy_towards(target_position, worker_position, TOWNHALL_TARGET)\n            )\n\n        if not target:\n            ai.mediator.remove_mineral_field(mineral_field_tag=target.tag)\n            ai.mediator.remove_worker_from_mineral(worker_tag=worker.tag)\n        elif not target.is_mineral_field and not target.vespene_contents:\n            ai.mediator.remove_gas_building(gas_building_tag=target.tag)\n\n        try:\n            townhall: Unit = ai.unit_tag_dict[worker_tag_to_townhall_tag[worker.tag]]\n        except KeyError:\n            townhall: Unit = cy_closest_to(worker_position, ai.townhalls)\n\n        return SpeedMining(\n            worker,\n            target,\n            worker_position,\n            resource_target_pos,\n            distance_to_townhall_factor,\n            townhall,\n        ).execute(ai, ai.mediator, ai.config)\n\n    @staticmethod\n    def _safe_long_distance_mineral_fields(\n        ai: \"AresBot\", mediator: ManagerMediator\n    ) -&gt; list[Unit]:\n        \"\"\"Find mineral fields for long distance miners.\n\n        Parameters:\n            ai: Main AresBot object\n            mediator: Manager mediator to interact with the managers\n\n        Returns:\n            Units object of safe mineral patches if mineral patches still exist\n        \"\"\"\n        if not ai.mineral_field:\n            return\n\n        assigned_patches: dict[int, set] = mediator.get_mineral_patch_to_list_of_workers\n        grid: np.ndarray = mediator.get_ground_grid\n        mfs: list[Unit] = cy_sorted_by_distance_to(ai.mineral_field, ai.start_location)\n        weight_safety_limit: float = 6.0\n        if ai.state.score.collection_rate_minerals &lt; 300:\n            weight_safety_limit = 100.0\n        safe_mfs: list[Unit] = []\n        for mf in mfs:\n            if mf in assigned_patches or not mediator.is_position_safe(\n                grid=grid, position=mf.position, weight_safety_limit=weight_safety_limit\n            ):\n                continue\n            safe_mfs.append(mf)\n\n        return safe_mfs\n\n    @staticmethod\n    def _worker_attacking_enemy(\n        ai: \"AresBot\", dist_to_resource: float, worker: Unit\n    ) -&gt; bool:\n        if not worker.is_collecting or dist_to_resource &gt; 1.0:\n            if enemies := cy_in_attack_range(worker, ai.enemy_units):\n                target: Unit = cy_pick_enemy_target(enemies)\n\n                if cy_attack_ready(ai, worker, target):\n                    worker.attack(target)\n                    return True\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.production_controller.ProductionController","title":"<code>ProductionController</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Handle creating extra production facilities based on an army composition dictionary. This dictionary should be structured the same as the one passed into SpawnController</p> <p>Terran / Protoss only</p> <p>Example bot code: <pre><code>from ares.behaviors.production_controller import ProductionController\n\n# Note: This does not try to build production facilities and\n# will ignore units that are impossible to currently spawn.\narmy_composition: dict[UnitID: {float, bool}] = {\n    UnitID.MARINE: {\"proportion\": 0.6, \"priority\": 2}, # lowest priority\n    UnitID.MEDIVAC: {\"proportion\": 0.25, \"priority\": 1},\n    UnitID.SIEGETANK: {\"proportion\": 0.15, \"priority\": 0}, # highest priority\n}\n# where `self` is an `AresBot` object\nself.register_behavior(ProductionController(\n    army_composition, self.ai.start_location))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>army_composition_dict</code> <code>dict[UnitTypeId, dict[str, float | int]]</code> <p>A dictionary detailing how an army composition should be made up. The proportional values should all add up to 1.0, with a priority integer for unit emphasis.</p> <code>base_location</code> <code>Point2</code> <p>The location where production should be built.</p> <code>add_production_at_bank</code> <code>tuple[int, int]</code> <p>When the bank reaches this size, calculate what extra production would be useful. Tuple where the first value is minerals and the second is vespene. Defaults to <code>(300, 300)</code>.</p> <code>alpha</code> <code>float</code> <p>Controls how much production to add when the bank is higher than <code>add_production_at_bank</code>. Defaults to <code>0.9</code>.</p> <code>unit_pending_progress</code> <code>float</code> <p>Check for production structures almost ready. For example, a marine might almost be ready, meaning we don't need to add extra production just yet. Defaults to <code>0.8</code>.</p> <code>ignore_below_proportion</code> <code>float</code> <p>If we don't want many of a unit, there's no point adding production. Checks if it's possible to build a unit first. Defaults to <code>0.05</code>.</p> <code>should_repower_structures</code> <code>bool</code> <p>Search for unpowered structures and build a new pylon if needed. Defaults to <code>True</code>.</p> <code>max_production_structures</code> <code>int</code> <p>Stop adding production at this number Defaults to 12</p> Source code in <code>src/ares/behaviors/macro/production_controller.py</code> <pre><code>@dataclass\nclass ProductionController(MacroBehavior):\n    \"\"\"Handle creating extra production facilities based\n    on an army composition dictionary.\n    This dictionary should be structured the same as the one\n    passed into SpawnController\n\n    Terran / Protoss only\n\n    Example bot code:\n    ```py\n    from ares.behaviors.production_controller import ProductionController\n\n    # Note: This does not try to build production facilities and\n    # will ignore units that are impossible to currently spawn.\n    army_composition: dict[UnitID: {float, bool}] = {\n        UnitID.MARINE: {\"proportion\": 0.6, \"priority\": 2}, # lowest priority\n        UnitID.MEDIVAC: {\"proportion\": 0.25, \"priority\": 1},\n        UnitID.SIEGETANK: {\"proportion\": 0.15, \"priority\": 0}, # highest priority\n    }\n    # where `self` is an `AresBot` object\n    self.register_behavior(ProductionController(\n        army_composition, self.ai.start_location))\n\n    ```\n\n    Attributes:\n        army_composition_dict: A dictionary detailing how an army composition\n            should be made up. The proportional values should all add up to 1.0,\n            with a priority integer for unit emphasis.\n        base_location: The location where production should be built.\n        add_production_at_bank: When the bank reaches this size, calculate what\n            extra production would be useful. Tuple where the first value is\n            minerals and the second is vespene. Defaults to `(300, 300)`.\n        alpha: Controls how much production to add when the bank is higher than\n            `add_production_at_bank`. Defaults to `0.9`.\n        unit_pending_progress: Check for production structures almost ready.\n            For example, a marine might almost be ready, meaning we don't need to\n            add extra production just yet. Defaults to `0.8`.\n        ignore_below_proportion: If we don't want many of a unit, there's no point\n            adding production. Checks if it's possible to build a unit first.\n            Defaults to `0.05`.\n        should_repower_structures: Search for unpowered structures and build a\n            new pylon if needed. Defaults to `True`.\n        max_production_structures: Stop adding production at this number\n            Defaults to 12\n\n    \"\"\"\n\n    army_composition_dict: dict[UnitID, dict[str, float | int]]\n    base_location: Point2\n    add_production_at_bank: tuple[int, int] = (400, 400)\n    alpha: float = 0.9\n    unit_pending_progress: float = 0.75\n    ignore_below_proportion: float = 0.05\n    should_repower_structures: bool = True\n    max_production_structures: int = 12\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if ai.race == Race.Protoss and self.should_repower_structures:\n            if RestorePower().execute(ai, config, mediator):\n                return True\n\n        army_comp_dict: dict = self.army_composition_dict\n        assert isinstance(\n            army_comp_dict, dict\n        ), f\"self.army_composition_dict should be dict type, got {type(army_comp_dict)}\"\n\n        # get the current standing army based on the army comp dict\n        # note we don't consider units outside the army comp dict\n        unit_types: list[UnitID] = [*army_comp_dict]\n\n        num_total_units: int = sum(\n            [\n                mediator.get_own_unit_count(unit_type_id=unit_type)\n                for unit_type in unit_types\n            ]\n        )\n        proportion_sum: float = 0.0\n        structure_dict: dict[UnitID, Units] = mediator.get_own_structures_dict\n        flying_structures: dict[int, dict] = mediator.get_flying_structure_tracker\n        # +1 to avoid division by zero\n        collection_rate_minerals: int = ai.state.score.collection_rate_minerals + 1\n        collection_rate_vespene: int = ai.state.score.collection_rate_vespene + 1\n\n        # iterate through desired army comp starting with the highest priority unit\n        for unit_type_id, army_comp_info in sorted(\n            army_comp_dict.items(), key=lambda x: x[1].get(\"priority\", int(0))\n        ):\n            assert isinstance(unit_type_id, UnitID), (\n                f\"army_composition_dict expects UnitTypeId type as keys, \"\n                f\"got {type(unit_type_id)}\"\n            )\n\n            num_this_unit: int = mediator.get_own_unit_count(unit_type_id=unit_type_id)\n            current_proportion: float = num_this_unit / (num_total_units + 1e-16)\n            target_proportion: float = army_comp_info[\"proportion\"]\n            proportion_sum += target_proportion\n            train_from: set[UnitID] = UNIT_TRAINED_FROM[unit_type_id]\n            trained_from: UnitID = next(iter(UNIT_TRAINED_FROM[unit_type_id]))\n            if unit_type_id in GATEWAY_UNITS:\n                trained_from = UnitID.GATEWAY\n\n            existing_structures: list[Unit] = []\n            for structure_type in train_from:\n                existing_structures.extend(structure_dict[structure_type])\n\n            # we need to tech up, no further action is required\n            if TechUp(\n                unit_type_id,\n                base_location=self.base_location,\n                ignore_existing_techlabs=current_proportion &lt; target_proportion,\n            ).execute(ai, config, mediator):\n                return True\n\n            try:\n                if ai.tech_requirement_progress(trained_from) &lt; 0.95:\n                    continue\n            except AttributeError as e:\n                # Handle the case where unit has no creation_ability defined\n                logger.warning(\n                    f\"{ai.time_formatted}: Tech requirement check failed for \"\n                    f\"{trained_from}: {e}\"\n                )\n                continue\n\n            # we have a worker on route to build this production\n            # leave alone for now\n            if ai.not_started_but_in_building_tracker(trained_from):\n                continue\n\n            if len(existing_structures) &gt;= self.max_production_structures:\n                continue\n\n            # we can afford prod, work out how much prod to support\n            # based on income\n            if (\n                ai.minerals &gt; self.add_production_at_bank[0]\n                and ai.vespene &gt; self.add_production_at_bank[1]\n            ):\n                if self._building_production_due_to_bank(\n                    ai,\n                    unit_type_id,\n                    collection_rate_minerals,\n                    collection_rate_vespene,\n                    existing_structures,\n                    trained_from,\n                    target_proportion,\n                ):\n                    return True\n\n            # target proportion is low and something is pending, don't add extra yet\n            if target_proportion &lt;= 0.15 and (\n                any([ai.structure_pending(type_id) for type_id in train_from])\n            ):\n                continue\n\n            # existing production is enough for our income?\n            cost: Cost = ai.calculate_cost(unit_type_id)\n            total_cost = cost.minerals + cost.vespene\n            divide_by: float = total_cost * 4.5\n            if len(existing_structures) &gt;= int(\n                (collection_rate_minerals + collection_rate_vespene) / divide_by\n            ):\n                continue\n\n            # if Terran has a production building floating, wait\n            if self.is_flying_production(ai, flying_structures, train_from):\n                continue\n\n            # already have enough of this unit type, don't need production\n            if current_proportion * 1.05 &gt;= target_proportion:\n                continue\n\n            # already could build this unit if we wanted to?\n            if self._can_already_produce(train_from, structure_dict):\n                continue\n\n            # add max depending on income\n            max_pending = int(\n                (collection_rate_minerals + collection_rate_vespene) / 1000\n            )\n\n            if ai.structure_pending(trained_from) &gt;= max_pending:\n                continue\n\n            built = BuildStructure(self.base_location, trained_from).execute(\n                ai, ai.config, ai.mediator\n            )\n            if built:\n                logger.info(\n                    f\"{ai.time_formatted} Adding {trained_from} so that we can build \"\n                    f\"more {unit_type_id}. Current proportion: {current_proportion}\"\n                    f\" Target proportion: {target_proportion}\"\n                )\n                return built\n\n        # we checked everything and no action is required\n        return False\n\n    def _building_production_due_to_bank(\n        self,\n        ai: \"AresBot\",\n        unit_type_id: UnitID,\n        collection_rate_minerals: int,\n        collection_rate_vespene: int,\n        existing_structures: list[Unit],\n        trained_from: UnitID,\n        target_proportion: float,\n    ) -&gt; bool:\n        # work out how many units we could afford at once\n        cost_of_unit: Cost = ai.calculate_cost(unit_type_id)\n        simul_afford_min: int = int(\n            (collection_rate_minerals / (cost_of_unit.minerals + 1))\n            * self.alpha\n            * target_proportion\n        )\n        simul_afford_ves: int = int(\n            (collection_rate_vespene / (cost_of_unit.vespene + 1))\n            * self.alpha\n            * target_proportion\n        )\n        num_existing: int = len([s for s in existing_structures if s.is_ready])\n        num_production: int = num_existing + ai.structure_pending(trained_from)\n\n        if num_production &lt; simul_afford_min and num_production &lt; simul_afford_ves:\n            if BuildStructure(self.base_location, trained_from).execute(\n                ai, ai.config, ai.mediator\n            ):\n                logger.info(f\"Adding {trained_from} as income level will support this.\")\n                return True\n        return False\n\n    def _can_already_produce(self, train_from, structure_dict) -&gt; bool:\n        for structure_type in train_from:\n            if structure_type == UnitID.WARPGATE and [\n                s for s in structure_dict[structure_type] if not s.is_ready\n            ]:\n                return True\n\n            for s in structure_dict[structure_type]:\n                if s.is_ready and s.is_idle:\n                    return True\n                if s.orders:\n                    if s.orders[0].progress &gt;= self.unit_pending_progress:\n                        return True\n                # structure about to come online\n                if 1.0 &gt; s.build_progress &gt;= 0.9:\n                    return True\n\n        return False\n\n    def is_flying_production(\n        self, ai: \"AresBot\", flying_structures: dict, train_from: set[UnitID]\n    ) -&gt; bool:\n        if ai.race == Race.Terran:\n            prod_flying: bool = False\n            # might have this structure flying\n            for tag in flying_structures:\n                if unit := ai.unit_tag_dict.get(tag, None):\n                    # make sure flying structure is nearby\n                    if (\n                        unit.type_id in UNIT_UNIT_ALIAS\n                        and cy_distance_to_squared(unit.position, self.base_location)\n                        &lt; 360.0\n                    ):\n                        for s_id in train_from:\n                            if UNIT_UNIT_ALIAS[unit.type_id] == s_id:\n                                prod_flying = True\n                                break\n            if prod_flying:\n                return True\n        return False\n\n    def _add_techlab_to_existing(\n        self, ai: \"AresBot\", unit_type_id: UnitID, researched_from_id\n    ) -&gt; bool:\n        structures_dict: dict = ai.mediator.get_own_structures_dict\n        build_techlab_from: UnitID = BUILD_TECHLAB_FROM[researched_from_id]\n        _build_techlab_from_structures: list[Unit] = structures_dict[\n            build_techlab_from\n        ].copy()\n        if without_techlabs := [\n            s\n            for s in _build_techlab_from_structures\n            if s.is_ready and s.is_idle and not s.has_add_on\n        ]:\n            without_techlabs[0].build(researched_from_id)\n            logger.info(\n                f\"{ai.time_formatted} Adding {researched_from_id} so that we can \"\n                f\"build more {unit_type_id}\"\n            )\n            return True\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.restore_power.RestorePower","title":"<code>RestorePower</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Restore power for protoss structures.</p> <p>Note: <code>ProductionController</code> is set to call this automatically configured via <code>should_repower_structures</code> parameter. Though this behavior may also be used separately.</p> <p>Example: <pre><code>from ares.behaviors.restore_power import RestorePower\n\nself.register_behavior(RestorePower())\n</code></pre></p> Source code in <code>src/ares/behaviors/macro/restore_power.py</code> <pre><code>@dataclass\nclass RestorePower(MacroBehavior):\n    \"\"\"Restore power for protoss structures.\n\n    Note: `ProductionController` is set to call this automatically\n    configured via `should_repower_structures` parameter.\n    Though this behavior may also be used separately.\n\n    Example:\n    ```py\n    from ares.behaviors.restore_power import RestorePower\n\n    self.register_behavior(RestorePower())\n    ```\n    \"\"\"\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        if structures_no_power := [\n            s\n            for s in ai.structures\n            if s.type_id in REQUIRE_POWER_STRUCTURE_TYPES\n            and not cy_pylon_matrix_covers(\n                s.position,\n                mediator.get_own_structures_dict[UnitID.PYLON],\n                ai.game_info.terrain_height.data_numpy,\n                pylon_build_progress=1e-16,\n            )\n        ]:\n            for structure in structures_no_power:\n                if self._already_restoring(structure, mediator):\n                    continue\n\n                if self._restoring_power(structure, ai, config, mediator):\n                    return True\n\n        return False\n\n    @staticmethod\n    def _already_restoring(structure: Unit, mediator: ManagerMediator) -&gt; bool:\n        \"\"\"\n        Check if unpowered `structure` is currently being restored.\n        Potentially probe already on the way?\n\n        Parameters\n        ----------\n        structure\n        mediator\n\n        Returns\n        -------\n\n        \"\"\"\n        building_tracker: dict = mediator.get_building_tracker_dict\n        for tag, building_info in building_tracker.items():\n            type_id: UnitID = building_info[ID]\n            if type_id == UnitID.PYLON:\n                pos: Point2 = building_info[TARGET]\n                if (\n                    cy_distance_to_squared(structure.position, pos)\n                    &lt; PYLON_POWERED_DISTANCE_SQUARED\n                ):\n                    return True\n\n        return False\n\n    @staticmethod\n    def _restoring_power(\n        structure: Unit, ai: \"AresBot\", config: dict, mediator: ManagerMediator\n    ) -&gt; bool:\n        \"\"\"Given an unpowered structure, find a pylon position.\n\n        Parameters\n        ----------\n        structure\n        ai\n        mediator\n\n        Returns\n        -------\n\n        \"\"\"\n        placements_dict: dict = mediator.get_placements_dict\n        position: Point2 = structure.position\n        size: BuildingSize = BuildingSize.TWO_BY_TWO\n        offset: float = 1.0\n\n        for base_loc, placements_info in placements_dict.items():\n            two_by_twos = placements_info[size]\n            if available := [\n                placement\n                for placement in two_by_twos\n                if two_by_twos[placement][\"available\"]\n                and cy_distance_to_squared(placement, position)\n                &lt; PYLON_POWERED_DISTANCE_SQUARED\n                and not two_by_twos[placement][\"worker_on_route\"]\n                and cy_can_place_structure(\n                    (placement[0] - offset, placement[1] - offset),\n                    (2, 2),\n                    ai.state.creep.data_numpy,\n                    ai.game_info.placement_grid.data_numpy,\n                    mediator.get_ground_grid.astype(np.uint8).T,\n                    avoid_creep=True,\n                    include_addon=False,\n                )\n            ]:\n                return BuildStructure(\n                    base_loc, UnitID.PYLON, closest_to=available[0], wall=True\n                ).execute(ai, config, mediator)\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.spawn_controller.SpawnController","title":"<code>SpawnController</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Handle spawning army compositions.</p> <p>Example bot code: <pre><code>from ares.behaviors.spawn_controller import SpawnController\n\n# Note: This does not try to build production facilities and\n# will ignore units that are impossible to currently spawn.\narmy_composition: dict[UnitID: {float, bool}] = {\n    UnitID.MARINE: {\"proportion\": 0.6, \"priority\": 2},  # lowest priority\n    UnitID.MEDIVAC: {\"proportion\": 0.25, \"priority\": 1},\n    UnitID.SIEGETANK: {\"proportion\": 0.15, \"priority\": 0},  # highest priority\n}\n# where `self` is an `AresBot` object\nself.register_behavior(SpawnController(army_composition))\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>army_composition_dict</code> <code>dict[UnitTypeId, dict[str, float | int]]</code> <p>A dictionary detailing how an army composition should be made up. The proportional values should all add up to 1.0, with a priority integer for unit emphasis.</p> <code>freeflow_mode</code> <code>bool</code> <p>If set to True, army composition proportions are ignored, and resources will be spent freely. Defaults to <code>False</code>.</p> <code>ignore_proportions_below_unit_count</code> <code>int</code> <p>In early game, units affect the army proportions significantly. This allows some units to be freely built before proportions are respected. Defaults to <code>0</code>.</p> <code>over_produce_on_low_tech</code> <code>bool</code> <p>If only one tech is available for a unit, this allows that unit to be constantly produced. Defaults to <code>True</code>.</p> <code>ignored_build_from_tags</code> <code>set[int]</code> <p>A set of tags to prevent the spawn controller from morphing from these tags. Example: Prevent selecting barracks that need to build an addon.</p> <code>maximum</code> <code>int</code> <p>The maximum number of a unit type that can be produced in a single step. Defaults to <code>20</code>.</p> <code>spawn_target</code> <code>Point2 | None</code> <p>A location to prioritize spawning units near. Defaults to <code>None</code>.</p> Source code in <code>src/ares/behaviors/macro/spawn_controller.py</code> <pre><code>@dataclass\nclass SpawnController(MacroBehavior):\n    \"\"\"Handle spawning army compositions.\n\n    Example bot code:\n    ```py\n    from ares.behaviors.spawn_controller import SpawnController\n\n    # Note: This does not try to build production facilities and\n    # will ignore units that are impossible to currently spawn.\n    army_composition: dict[UnitID: {float, bool}] = {\n        UnitID.MARINE: {\"proportion\": 0.6, \"priority\": 2},  # lowest priority\n        UnitID.MEDIVAC: {\"proportion\": 0.25, \"priority\": 1},\n        UnitID.SIEGETANK: {\"proportion\": 0.15, \"priority\": 0},  # highest priority\n    }\n    # where `self` is an `AresBot` object\n    self.register_behavior(SpawnController(army_composition))\n\n    ```\n\n    Attributes:\n        army_composition_dict: A dictionary detailing how an army\n            composition should be made up. The proportional values should\n            all add up to 1.0, with a priority integer for unit emphasis.\n        freeflow_mode: If set to True, army composition proportions are ignored,\n            and resources will be spent freely.\n            Defaults to `False`.\n        ignore_proportions_below_unit_count: In early game, units affect the\n            army proportions significantly. This allows some units to be freely\n            built before proportions are respected. Defaults to `0`.\n        over_produce_on_low_tech: If only one tech is available for a unit,\n            this allows that unit to be constantly produced.\n            Defaults to `True`.\n        ignored_build_from_tags: A set of tags to prevent the spawn controller\n            from morphing from these tags.\n            Example: Prevent selecting barracks that need to build an addon.\n        maximum: The maximum number of a unit type that can be produced\n            in a single step. Defaults to `20`.\n        spawn_target: A location to prioritize spawning units near.\n            Defaults to `None`.\n\n\n    \"\"\"\n\n    army_composition_dict: dict[UnitID, dict[str, float | int]]\n    freeflow_mode: bool = False\n    ignore_proportions_below_unit_count: int = 0\n    over_produce_on_low_tech: bool = True\n    ignored_build_from_tags: set[int] = field(default_factory=set)\n    maximum: int = 20\n    spawn_target: Point2 | None = None\n\n    # key: Unit that should get a build order, value: what UnitID to build\n    __build_dict: dict[Unit, UnitID] = field(default_factory=dict)\n    # already used tags\n    __excluded_structure_tags: set[int] = field(default_factory=set)\n    __supply_available: float = 0.0\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        # allow gateways to morph before issuing commands\n        if UpgradeId.WARPGATERESEARCH in ai.state.upgrades and [\n            g\n            for g in mediator.get_own_structures_dict[UnitID.GATEWAY]\n            if g.is_ready and g.is_idle\n        ]:\n            return False\n\n        self.__supply_available = ai.supply_left\n\n        army_comp_dict: dict = self.army_composition_dict\n        assert isinstance(\n            army_comp_dict, dict\n        ), f\"self.army_composition_dict should be dict type, got {type(army_comp_dict)}\"\n\n        # get the current standing army based on the army comp dict\n        # note we don't consider units outside the army comp dict\n        unit_types: list[UnitID] = [*army_comp_dict]\n        num_total_units: int = 0\n        for unit_type in unit_types:\n            num_total_units += mediator.get_own_unit_count(unit_type_id=unit_type)\n\n        check_proportion: bool = True\n        proportion_sum: float = 0.0\n        # remember units that meet tech requirement\n        units_ready_to_build: list[UnitID] = []\n        # keep track of what units we have tech for\n        tech_ready_for: list[UnitID] = []\n        # iterate through desired army comp starting with the highest priority unit\n        for unit_type_id, army_comp_info in sorted(\n            army_comp_dict.items(), key=lambda x: x[1].get(\"priority\", int(0))\n        ):\n            assert isinstance(unit_type_id, UnitID), (\n                f\"army_composition_dict expects UnitTypeId type as keys, \"\n                f\"got {type(unit_type_id)}\"\n            )\n            priority: int = army_comp_info[\"priority\"]\n            assert 0 &lt;= priority &lt; 11, (\n                f\"Priority for {unit_type_id} is set to {priority},\"\n                f\"it should be an integer between 0 - 10.\"\n                f\"Where 0 has highest priority.\"\n            )\n\n            target_proportion: float = army_comp_info[\"proportion\"]\n            proportion_sum += target_proportion\n\n            # work out if we are able to produce this unit\n            if not ai.tech_ready_for_unit(unit_type_id):\n                continue\n\n            tech_ready_for.append(unit_type_id)\n\n            trained_from: set[UnitID]\n            if unit_type_id == UnitID.ARCHON:\n                trained_from = {UnitID.HIGHTEMPLAR, UnitID.DARKTEMPLAR}\n            else:\n                trained_from = UNIT_TRAINED_FROM[unit_type_id]\n\n            # get all idle build structures/units we can create this unit from\n            build_structures: list[Unit] = ai.get_build_structures(\n                trained_from,\n                unit_type_id,\n                self.__build_dict,\n                self.ignored_build_from_tags,\n            )\n            # there is no possible way to build this unit, skip even if higher priority\n            if len(build_structures) == 0:\n                continue\n\n            # archon is a special case that can't be handled generically\n            if unit_type_id == UnitID.ARCHON:\n                self._handle_archon_morph(ai, build_structures, mediator)\n                continue\n\n            # prioritize spawning close to spawn target\n            if self.spawn_target:\n                build_structures = cy_sorted_by_distance_to(\n                    build_structures, self.spawn_target\n                )\n\n            # can't afford unit?\n            # then we might want to break out loop till we can afford\n            if not self._can_afford(ai, unit_type_id):\n                if (\n                    self.freeflow_mode\n                    or num_total_units &lt; self.ignore_proportions_below_unit_count\n                ):\n                    continue\n                # break out the loop, don't spend resources on lower priority units\n                else:\n                    check_proportion = False\n                    break\n\n            # keep track of which unit types the build_structures/ tech is ready for\n            units_ready_to_build.append(unit_type_id)\n\n            num_this_unit: int = mediator.get_own_unit_count(unit_type_id=unit_type_id)\n            current_proportion: float = num_this_unit / (num_total_units + 1e-16)\n            # already have enough of this unit type,\n            # but we could add it if:\n            # freeflow mode or we don't have much army yet\n            if (\n                current_proportion &gt;= target_proportion\n                and not self.freeflow_mode\n                and num_total_units &gt;= self.ignore_proportions_below_unit_count\n            ):\n                continue\n\n            amount, supply, cost = self._calculate_build_amount(\n                ai,\n                unit_type_id,\n                build_structures,\n                self.__supply_available,\n                self.maximum,\n            )\n            self._add_to_build_dict(\n                ai, unit_type_id, build_structures, amount, supply, cost\n            )\n        # if we can only build one type of unit, keep adding them\n        if (\n            len(tech_ready_for) == 1\n            and self.over_produce_on_low_tech\n            and len(units_ready_to_build) &gt; 0\n            and self.maximum &gt; 1\n        ):\n            build_structures = ai.get_build_structures(\n                UNIT_TRAINED_FROM[units_ready_to_build[0]],\n                units_ready_to_build[0],\n                self.__build_dict,\n                self.ignored_build_from_tags,\n            )\n            amount, supply, cost = self._calculate_build_amount(\n                ai, units_ready_to_build[0], build_structures, self.__supply_available\n            )\n            # prioritize spawning close to spawn target\n            if self.spawn_target:\n                build_structures = cy_sorted_by_distance_to(\n                    build_structures, self.spawn_target\n                )\n            self._add_to_build_dict(\n                ai, units_ready_to_build[0], build_structures, amount, supply, cost\n            )\n\n        if check_proportion and not self.freeflow_mode:\n            assert isclose(\n                proportion_sum, 1.0\n            ), f\"The army comp proportions should equal 1.0, got {proportion_sum}\"\n\n        return self._morph_units(ai, mediator)\n\n    def _add_to_build_dict(\n        self,\n        ai: \"AresBot\",\n        type_id: UnitID,\n        base_unit: list[Unit],\n        amount: int,\n        supply_cost: float,\n        cost_per_unit: Cost,\n    ) -&gt; None:\n        \"\"\"Execute the spawn controller task (Called from `behavior_executioner.py`).\n\n        Handle unit production as per the .........\n\n        Parameters\n        ----------\n        ai :\n            Bot object that will be running the game\n        type_id :\n            Type of unit we want to spawn.\n        base_unit :\n            Unit objects we can spawn this unit from.\n        amount :\n            How many type_id we intend to spawn.\n        supply_cost :\n            Supply cost of spawning type_id amount.\n        cost_per_unit :\n            Minerals and vespene cost.\n        \"\"\"\n        # min check to make sure we don't pop from empty lists\n        for _ in range(min(len(base_unit), amount)):\n            self.__build_dict[base_unit.pop(0)] = type_id\n            ai.minerals -= cost_per_unit.minerals\n            ai.vespene -= cost_per_unit.vespene\n            self.__supply_available -= supply_cost\n\n    @staticmethod\n    def _calculate_build_amount(\n        ai: \"AresBot\",\n        unit_type: UnitID,\n        base_units: list[Unit],\n        supply_left: float,\n        maximum: int = 20,\n    ) -&gt; tuple[int, float, Cost]:\n        \"\"\"Execute the spawn controller task (Called from `behavior_executioner.py`).\n\n        Handle unit production as per the .........\n\n        Parameters\n        ----------\n        ai :\n            Bot object that will be running the game\n        unit_type :\n            Type of unit we want to spawn.\n        base_units :\n            Unit objects we can spawn this unit from.\n        supply_left :\n            How much total supply we have available.\n        maximum :\n            A limit on how many units can be spawned in one go.\n        \"\"\"\n        cost = ai.cost_dict[unit_type]\n        supply_cost = ai.calculate_supply_cost(unit_type)\n        amount = min(\n            int(ai.minerals / cost.minerals) if cost.minerals else 9999999,\n            int(ai.vespene / cost.vespene) if cost.vespene else 9999999,\n            int(supply_left / supply_cost) if supply_cost else 9999999,\n            len(base_units),\n            maximum,\n        )\n        return amount, supply_cost, cost\n\n    @staticmethod\n    def _can_afford(ai: \"AresBot\", unit_type_id: UnitID) -&gt; bool:\n        if unit_type_id == UnitID.ARCHON:\n            return True\n        return ai.can_afford(unit_type_id)\n\n    @staticmethod\n    def _handle_archon_morph(\n        ai: \"AresBot\", build_structures: list[Unit], mediator: ManagerMediator\n    ) -&gt; None:\n        unit_role_dict: dict[UnitRole, set] = mediator.get_unit_role_dict\n        build_structures = [\n            b\n            for b in build_structures\n            if b.tag not in unit_role_dict[UnitRole.MORPHING] and b.is_ready\n        ]\n        if len(build_structures) &lt; 2:\n            return\n\n        templar: list[Unit] = build_structures[:2]\n        ai.request_archon_morph(templar)\n\n    def _morph_units(self, ai: \"AresBot\", mediator: ManagerMediator) -&gt; bool:\n        did_action: bool = False\n        for unit, value in self.__build_dict.items():\n            did_action = True\n            mediator.clear_role(tag=unit.tag)\n            if value == UnitID.BANELING:\n                unit(AbilityId.MORPHTOBANELING_BANELING)\n            elif value == UnitID.RAVAGER:\n                unit(AbilityId.MORPHTORAVAGER_RAVAGER)\n            # prod building is warp gate, but we really\n            # want to spawn from psionic field\n            elif unit.type_id == UnitID.WARPGATE:\n                mediator.request_warp_in(\n                    build_from=unit, unit_type=value, target=self.spawn_target\n                )\n            else:\n                unit.train(value)\n                ai.num_larva_left -= 1\n\n        return did_action\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.tech_up.TechUp","title":"<code>TechUp</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Automatically tech up so desired upgrade/unit can be built.</p> <p>Example: <pre><code>from ares.behaviors.macro import TechUp\nfrom sc2.ids.upgrade_id import UpgradeId\n\nself.register_behavior(\n    TechUp(UpgradeId.BANSHEECLOAK, base_location=self.start_location)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>desired_tech</code> <code>Union[UpgradeId, UnitTypeId]</code> <p>The desired upgrade or unit type.</p> <code>base_location</code> <code>Point2</code> <p>The main building location to make tech.</p> <code>ignore_existing_techlabs</code> <code>bool</code> <p>If set to <code>True</code>, will keep building techlabs even if others exist. Defaults to <code>False</code>.</p> Source code in <code>src/ares/behaviors/macro/tech_up.py</code> <pre><code>@dataclass\nclass TechUp(MacroBehavior):\n    \"\"\"Automatically tech up so desired upgrade/unit can be built.\n\n    Example:\n    ```py\n    from ares.behaviors.macro import TechUp\n    from sc2.ids.upgrade_id import UpgradeId\n\n    self.register_behavior(\n        TechUp(UpgradeId.BANSHEECLOAK, base_location=self.start_location)\n    )\n    ```\n\n    Attributes:\n        desired_tech: The desired upgrade or unit type.\n        base_location: The main building location to make tech.\n        ignore_existing_techlabs: If set to `True`, will\n            keep building techlabs even if others exist.\n            Defaults to `False`.\n\n    \"\"\"\n\n    desired_tech: Union[UpgradeId, UnitID]\n    base_location: Point2\n    ignore_existing_techlabs: bool = False\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        assert isinstance(\n            self.desired_tech, (UpgradeId, UnitID)\n        ), f\"Wrong type provided for `desired_tech`, got {type(self.desired_tech)}\"\n\n        # figure out where we research this unit / upgrade from\n        researched_from_id: UnitID\n        tech_required: list[UnitID]\n        if isinstance(self.desired_tech, UpgradeId):\n            researched_from_id = UPGRADE_RESEARCHED_FROM[self.desired_tech]\n            tech_required = UNIT_TECH_REQUIREMENT[researched_from_id]\n        else:\n            if self.desired_tech in ALL_STRUCTURES:\n                researched_from_id = self.desired_tech\n                tech_required = UNIT_TECH_REQUIREMENT[researched_from_id]\n            else:\n                researched_from_id = next(iter(UNIT_TRAINED_FROM[self.desired_tech]))\n                if self.desired_tech in GATEWAY_UNITS:\n                    researched_from_id = UnitID.GATEWAY\n                tech_required = UNIT_TECH_REQUIREMENT[self.desired_tech]\n\n        # special handling of teching to techlabs\n        if researched_from_id in TECHLAB_TYPES:\n            if ai.can_afford(researched_from_id) and self._adding_techlab(\n                ai,\n                self.base_location,\n                researched_from_id,\n                tech_required,\n                self.desired_tech,\n                self.ignore_existing_techlabs,\n            ):\n                return True\n            return False\n\n        # can we build this tech building right away?\n        # 1.0 = Yes, &lt; 1.0 = No\n        try:\n            tech_progress: float = ai.tech_requirement_progress(researched_from_id)\n        except AttributeError as e:\n            logger.warning(\n                f\"{ai.time_formatted} Error checking tech progress for \"\n                f\"{researched_from_id}: {e}\"\n            )\n            return False\n\n        # we have the tech ready to build this upgrade building right away :)\n        if tech_progress == 1.0 and not ai.structure_present_or_pending(\n            researched_from_id\n        ):\n            if researched_from_id in {UnitID.LAIR, UnitID.HIVE}:\n                upgrading: bool = self._upgrade_zerg_townhall(researched_from_id, ai)\n                if upgrading:\n                    logger.info(\n                        f\"{ai.time_formatted} Adding {researched_from_id} to\"\n                        f\" tech towards {self.desired_tech}\"\n                    )\n                return upgrading\n            # need a gateway, but we have a warpgate already\n            if (\n                researched_from_id == UnitID.GATEWAY\n                and mediator.get_own_structures_dict[UnitID.WARPGATE]\n            ):\n                return False\n            logger.info(\n                f\"{ai.time_formatted} Building {researched_from_id} \"\n                f\"for {self.desired_tech}\"\n            )\n            return BuildStructure(ai.start_location, researched_from_id).execute(\n                ai, config, mediator\n            )\n\n        # we can't even build the upgrade building :(\n        # figure out what to build to get there\n        else:\n            for structure_type in tech_required:\n                checks: list[UnitID] = [structure_type]\n                if structure_type == UnitID.GATEWAY:\n                    checks.append(UnitID.WARPGATE)\n\n                if structure_type in TECHLAB_TYPES:\n                    if self._adding_techlab(\n                        ai,\n                        self.base_location,\n                        structure_type,\n                        tech_required,\n                        self.desired_tech,\n                        self.ignore_existing_techlabs,\n                    ):\n                        return True\n                    continue\n\n                if any(ai.structure_present_or_pending(check) for check in checks):\n                    continue\n\n                # found something to build?\n                try:\n                    tech_ready = ai.tech_requirement_progress(structure_type) == 1.0\n                except AttributeError as e:\n                    logger.warning(\n                        f\"{ai.time_formatted} Error checking tech progress \"\n                        f\"for {structure_type}: {e}\"\n                    )\n                    continue\n\n                if tech_ready:\n                    if structure_type in {UnitID.LAIR, UnitID.HIVE}:\n                        upgrading: bool = self._upgrade_zerg_townhall(\n                            structure_type, ai\n                        )\n                        if upgrading:\n                            logger.info(\n                                f\"{ai.time_formatted} Adding {structure_type} to\"\n                                f\" tech towards {self.desired_tech}\"\n                            )\n                        return upgrading\n\n                    building: bool = BuildStructure(\n                        self.base_location, structure_type\n                    ).execute(ai, ai.config, ai.mediator)\n                    if building:\n                        logger.info(\n                            f\"{ai.time_formatted} Adding {structure_type} to\"\n                            f\" tech towards {self.desired_tech}\"\n                        )\n                    return building\n\n        return False\n\n    def _adding_techlab(\n        self,\n        ai: \"AresBot\",\n        base_location: Point2,\n        researched_from_id: UnitID,\n        tech_required: list[UnitID],\n        desired_tech: Union[UnitID, UpgradeId],\n        ignore_existing_techlabs: bool = False,\n    ) -&gt; bool:\n        \"\"\"\n        ai :\n        base_location :\n        researched_from_id :\n            The building we require\n        tech_required :\n            The list of tech buildings we would need to build this\n        desired_tech :\n            The thing we are actually trying to research / build\n        \"\"\"\n        structures_dict: dict = ai.mediator.get_own_structures_dict\n        build_techlab_from: UnitID = BUILD_TECHLAB_FROM[researched_from_id]\n        _build_techlab_from_structures: list[Unit] = structures_dict[\n            build_techlab_from\n        ].copy()\n        # looks like we already have what we are looking for?\n        if (\n            not ignore_existing_techlabs\n            and len(\n                [\n                    s\n                    for s in _build_techlab_from_structures\n                    if s.has_techlab and s.is_idle\n                ]\n            )\n            &gt; 0\n        ):\n            return False\n\n        # no possible way of building this techlab, tech towards it\n        if not ai.structure_present_or_pending(build_techlab_from):\n            for s in tech_required:\n                if ai.structure_present_or_pending(s):\n                    continue\n                if ai.can_afford(s) and TechUp(s, base_location).execute(\n                    ai, ai.config, ai.mediator\n                ):\n                    logger.info(\n                        f\"{ai.time_formatted} Adding {s} so that we can \"\n                        f\"tech towards {desired_tech}\"\n                    )\n                    return True\n            # no point continuing\n            return False\n\n        if ai.can_afford(researched_from_id) and (\n            not structures_dict[researched_from_id] or ignore_existing_techlabs\n        ):\n            without_techlabs: list[Unit] = [\n                s\n                for s in _build_techlab_from_structures\n                if s.is_ready and s.is_idle and not s.has_add_on\n            ]\n            with_techlabs_idle: list[Unit] = [\n                s for s in _build_techlab_from_structures if s.is_idle and s.has_add_on\n            ]\n            if without_techlabs and not with_techlabs_idle:\n                without_techlabs[0].build(researched_from_id)\n                logger.info(\n                    f\"{ai.time_formatted} Adding {researched_from_id} so that we can \"\n                    f\"tech towards {desired_tech}. \"\n                    f\"Ignore existing techlabs: {ignore_existing_techlabs}\"\n                )\n                return True\n        return False\n\n    def _upgrade_zerg_townhall(self, structure_type: UnitID, ai: \"AresBot\") -&gt; bool:\n        structures_dict = ai.mediator.get_own_structures_dict\n        if (\n            not ai.can_afford(structure_type)\n            or ai.already_pending(structure_type)\n            or structures_dict[structure_type]\n        ):\n            return False\n\n        # lair\n        if (\n            structure_type == UnitID.LAIR\n            and not structures_dict[UnitID.HIVE]\n            and (\n                idle_townhalls := [\n                    th for th in ai.townhalls if th.is_idle and th.is_ready\n                ]\n            )\n        ):\n            # all townhalls will be a hatchery if got to here\n            th: Unit = idle_townhalls[0]\n            th(AbilityId.UPGRADETOLAIR_LAIR)\n            return True\n\n        # hive\n        if (\n            structure_type == UnitID.HIVE\n            and not structures_dict[UnitID.HIVE]\n            and (\n                idle_lair := [\n                    th\n                    for th in structures_dict[UnitID.LAIR]\n                    if th.is_idle and th.is_ready\n                ]\n            )\n        ):\n            # all townhalls will be a hatchery if got to here\n            th: Unit = idle_lair[0]\n            th(AbilityId.UPGRADETOHIVE_HIVE)\n            return True\n\n        return False\n</code></pre>"},{"location":"api_reference/behaviors/macro_behaviors.html#ares.behaviors.macro.upgrade_controller.UpgradeController","title":"<code>UpgradeController</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MacroBehavior</code></p> <p>Research upgrades, if the upgrade is not currently researchable this behavior will automatically make the tech buildings required.</p> <p>Example: <pre><code>from ares.behaviors.macro import UpgradeController\nfrom sc2.ids.upgrade_id import UpgradeId\n\ndesired_upgrades: list[UpgradeId] = [\n    UpgradeId.TERRANINFANTRYWEAPONSLEVEL1,\n    UpgradeId.TERRANINFANTRYWEAPONSLEVEL2,\n    UpgradeId.BANSHEECLOAK,\n    UpgradeId.PERSONALCLOAKING\n]\n\nself.register_behavior(\n    UpgradeController(desired_upgrades, base_location=self.start_location)\n)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>upgrade_list</code> <code>list[UpgradeId]</code> <p>List of desired upgrades.</p> <code>base_location</code> <code>Point2</code> <p>Location to build upgrade buildings.</p> <code>auto_tech_up_enabled</code> <code>bool</code> <p>bool</p> <code>prioritize</code> <code>bool</code> <p>If True and there is an Upgrade ready to go, but we can't afford it yet, this behavior will return True. This is useful in a MacroPlan as it will prevent other spending actions occurring. Default is False</p> Source code in <code>src/ares/behaviors/macro/upgrade_controller.py</code> <pre><code>@dataclass\nclass UpgradeController(MacroBehavior):\n    \"\"\"Research upgrades, if the upgrade is not\n    currently researchable this behavior will automatically\n    make the tech buildings required.\n\n\n    Example:\n    ```py\n    from ares.behaviors.macro import UpgradeController\n    from sc2.ids.upgrade_id import UpgradeId\n\n    desired_upgrades: list[UpgradeId] = [\n        UpgradeId.TERRANINFANTRYWEAPONSLEVEL1,\n        UpgradeId.TERRANINFANTRYWEAPONSLEVEL2,\n        UpgradeId.BANSHEECLOAK,\n        UpgradeId.PERSONALCLOAKING\n    ]\n\n    self.register_behavior(\n        UpgradeController(desired_upgrades, base_location=self.start_location)\n    )\n    ```\n\n    Attributes:\n        upgrade_list: List of desired upgrades.\n        base_location: Location to build upgrade buildings.\n        auto_tech_up_enabled: bool\n        prioritize: If True and there is an Upgrade ready to go, but\n            we can't afford it yet, this behavior will return True.\n            This is useful in a MacroPlan as it will prevent other\n            spending actions occurring.\n            Default is False\n\n    \"\"\"\n\n    upgrade_list: list[UpgradeId]\n    base_location: Point2\n    auto_tech_up_enabled: bool = True\n    prioritize: bool = False\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        for upgrade in self.upgrade_list:\n            if ai.pending_or_complete_upgrade(upgrade):\n                continue\n\n            researched_from_id: UnitID = UPGRADE_RESEARCHED_FROM[upgrade]\n            researched_from: list[Unit] = [\n                s for s in mediator.get_own_structures_dict[researched_from_id]\n            ]\n\n            # there is nowhere to research this from, tech up to it\n            # but only if auto_tech_up_enabled is True\n            if not researched_from:\n                if not self.auto_tech_up_enabled:\n                    return False\n\n                teching: bool = TechUp(\n                    desired_tech=upgrade, base_location=self.base_location\n                ).execute(ai, config, mediator)\n                # we've carried out an action, return True\n                if teching:\n                    return True\n\n            # we have somewhere to research from, if it's possible\n            # carry out the action\n            else:\n                idle: list[Unit] = [\n                    s\n                    for s in researched_from\n                    if s.is_ready\n                    and s.is_idle\n                    and (not ai.race == Race.Protoss or s.is_powered)\n                ]\n                if idle:\n                    building: Unit = idle[0]\n                    research_info: dict = RESEARCH_INFO[researched_from_id][upgrade]\n                    ability: AbilityId = research_info[\"ability\"]\n                    if ability in building.abilities:\n                        if ai.can_afford(upgrade):\n                            building.research(upgrade)\n                            logger.info(f\"{ai.time_formatted}: Researching {upgrade}\")\n                            return True\n                        # can't afford it yet, but we want to prioritize\n                        # the upgrade, so return True\n                        elif self.prioritize:\n                            return True\n                    # there is a structure to upgrade from, but:\n                    # we can't do the upgrade, might need something like:\n                    # hive for 3/3? twilight council for 2/2?\n                    elif required_building := research_info.get(\n                        \"required_building\", None\n                    ):\n                        if not self.auto_tech_up_enabled:\n                            return False\n\n                        return TechUp(\n                            desired_tech=required_building,\n                            base_location=self.base_location,\n                        ).execute(ai, config, mediator)\n\n        # found nothing to do\n        return False\n</code></pre>"},{"location":"contributing/index.html","title":"Contributors guidance","text":"<p> Rough notes for now, this section of the docs needs work </p>"},{"location":"contributing/index.html#random-bits-explaining-some-decisions","title":"Random bits explaining some decisions","text":"<ul> <li>Application layout - Python Packaging Authority recommend the <code>src</code> layout</li> <li>Standard to store version number in the package's <code>__init__.py</code> PEP8</li> <li>Also store the version in <code>pyproject.toml</code></li> <li><code>Makefile</code> contains most of the commonly used commands from this write-up. This file is used by GitHub workflow</li> <li>Follow semantic versioning <code>MAJOR.MINOR.PATCH</code> </li> </ul>"},{"location":"contributing/index.html#setting-up-dev-environment","title":"Setting up dev environment","text":"<ul> <li>install <code>poetry</code></li> <li>clone repo </li> <li>run <code>poetry install --with docs lint test semver notebook</code></li> </ul>"},{"location":"contributing/index.html#linting-and-autoformatting","title":"Linting and autoformatting","text":"<ul> <li>black for main autoformatting</li> <li>isort for import formatting</li> <li>flake8 for checking code base against coding style (PEP8)</li> <li>mypy for checking type annotations </li> </ul> <p>isort and black don't agree on some things, add following to <code>pyproject.toml</code> <pre><code>[tool.isort]\nprofile = \"black\"\n</code></pre></p> <p>flake8 also needs to use black settings, we do this with a <code>.flake8</code> settings file</p> <p>For mypy we configure via <code>pyproject.toml</code>, see  docs See more here</p>"},{"location":"contributing/index.html#using-these-tools-on-command-line","title":"Using these tools on command line","text":"<p>Can pass in <code>--check</code> for some of these</p> <p><code>isort .</code> <code>black.</code> <code>flake8 .</code> <code>mypy .</code></p> <p>We put all these into a <code>makefile</code>, which allows us to do: <code>make format</code> <code>make lint</code></p> <p>However, using makefiles on Windows requires a bit more setup</p>"},{"location":"contributing/index.html#configure-pycharm-to-run-these-automatically","title":"Configure PyCharm to run these automatically","text":"<p>TODO: Put own guide here as link might die</p> <p>black, isort and flake8  See guide here</p> <p>mypy - PyCharm will help with type annotations, just ensure they are being used, and run <code>mypy .</code> before committing to ensure the github lint workflow tests pass</p>"},{"location":"contributing/index.html#git-commit-guidelines","title":"Git commit guidelines","text":"<p>See conventional commits, all commits and PR's should follow these guidelines</p> <p>A github workflow is setup to enforce this, see here</p> <p>Layout: <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n&lt;BLANK LINE&gt;\n&lt;body&gt;\n&lt;BLANK LINE&gt;\n&lt;footer&gt;\n</code></pre></p> <p>Commit message no longer than 100 characters (scope is optional)</p> <p> text This is a very short description of the change.  - use imperative, present tense: \u201cchange\u201d not \u201cchanged\u201d nor \u201cchanges\u201d  - don't capitalize first letter  - no dot (.) at the end <p>Python Semantic Release will recognise the types of commits to automatically determine a new version</p> <ul> <li><code>fix:</code> commit is a PATCH</li> <li><code>feat:</code> commit is a MINOR</li> <li><code>BREAKING CHANGE</code> or <code>!</code> is a MAJOR</li> <li><code>build:</code>, <code>chore:</code>, <code>ci:</code>, <code>docs:</code>, <code>style:</code>, <code>refactor:</code>, <code>perf:</code>, <code>test:</code> do not increase version</li> </ul> <p>A scope can also be added in parentheses. For example: <code>feat(combat): add kiting behavior</code></p> <p>Example of breaking change commit message <code>feat(api)!: send an email to the customer when a product is shipped</code></p>"},{"location":"contributing/index.html#github-workflow","title":"Github workflow","text":"<p>All formatters and linters are run in a github workflow, we use the <code>makefile</code> here.</p>"},{"location":"contributing/index.html#unit-tests","title":"Unit tests","text":"<p>Read this, no point repeating it here <code>poetry add --group test pytest</code></p> <p>Each test should be small and self-contained</p>"},{"location":"contributing/index.html#coverage","title":"Coverage","text":"<p>Indicates how much code is covered by tests</p> <p>Run coverage through <code>pytest</code>: <code>pytest --cov=src --cov-report term-missing --cov-report=html</code></p> <p>Run specific tests <code>pytest -v -s tests/managers/test_building_manager.py::TestBuildingManager::test_construct_gas</code></p> <p>Offical docs</p>"},{"location":"contributing/index.html#automatic-documentation","title":"Automatic documentation","text":"<p>Using mkdocs for no particular reason other than found a good tutorial using it</p> <p><code>poetry add --group docs mkdocs mkdocs-material</code></p> <p>Sphinx is another alternative</p> <p>To build docs locally: <code>mkdocs build</code></p> <p>Push to github pages: (shouldn't need to use this) <code>mkdocs gh-deploy -m \"docs: update documentation\" -v --force</code></p>"},{"location":"contributing/index.html#docstrings","title":"Docstrings","text":"<p>Using numpy docstrings style</p> <p><code>poetry add --group docs \"mkdocstrings[python]\"</code></p> <p>At the relevant place in a markdown file add for example: <pre><code>::: ares.example_docstrings\n    options:\n        show_root_heading: true\n</code></pre> Where <code>ares.example_docstrings</code> is the python file containing numpy style docstrings</p> <p>Pytest will run tests on any Examples in docstrings in Github workflow <code>pytest --doctest-modules</code></p>"},{"location":"contributing/index.html#versioning-and-automatic-releases","title":"Versioning and automatic releases","text":"<p>Use Python Semantic Release to create automatic releases based on the commits, therefore git commits should follow the Angular commit style</p> <p><code>poetry add --group semver python-semantic-release</code></p>"},{"location":"contributing/index.html#python-semantic-release-commands","title":"Python Semantic Release commands","text":"<p>In general if Github actions is working, these shouldn't need to be manually called.</p> <p>Get current version: <code>semantic-release print-version --current</code></p> <p>Compute a version bump: <code>semantic-release print-version --next</code></p> <p>Get current changelog: <code>semantic-release changelog --released</code></p> <p>Generate a new changelog: <code>semantic-release changelog --unreleased</code></p> <p>Publish a release: <code>semantic-release publish --noop</code></p>"},{"location":"contributing/index.html#poetry","title":"Poetry","text":"<p>Takes care of env, dependency, building and publishing</p>"},{"location":"contributing/index.html#useful-commands","title":"Useful commands","text":"<p>See Basic usage</p> <p>Init new project, generates <code>pyproject.toml</code> that contains the entire package configuration. Fine to edit this</p> <p><code>poetry init --name ares-sc2 --no-interaction</code></p> <p>Run in virtual env (poetry uses venv) Managing poetry environments:</p> <p><code>poetry run python src/ares/main.py</code></p> <p>Run tests</p> <p><code>poetry run pytest</code></p> <p>Create and activate an environment (can also use PyCharm to create new env):</p> <p><code>poetry env use python</code></p> <p>On Linux possibly: <code>poetry env use python3.10</code></p> <p>Find environment in file system:</p> <p><code>poetry env list --full-path</code></p> <p>Use this path to add existing env in PyCharm</p> <p>Can get a shell into the environment:</p> <p><code>poetry shell</code></p> <p>Install dependencies:</p> <p><code>poetry add burnysc2</code></p> <p>Create a <code>lock</code> file. Should be added to git. Ensures all people working on project using the same library versions. Automatically generated and shouldn't be edited</p> <p><code>poetry lock</code></p> <p>Install all dependencies based on the lock file</p> <p>This command will read the TOML file, resolve all the dependencies and finally install them in a virtual environment  that poetry will create by default under {cache-dir}/virtualenvs/. </p> <p><code>poetry install</code></p> <p>Install without dev tools</p> <p><code>poetry install --without lint</code></p> <p>List all installed dependencies:</p> <p><code>poetry show</code></p> <p>List current and latest available version</p> <p><code>poetry show -l</code></p> <p>Same as above, but only show outdated</p> <p><code>poetry show -o</code></p> <p>Update dependencies:</p> <p><code>poetry update</code></p> <p>Poetry can organise dependencies by groups, since dev tools etc are not required in the package release, eg:</p> <p><code>poetry add --group lint isort black flake8 mypy</code></p>"},{"location":"contributing/index.html#notes-about-pyprojecttoml","title":"Notes about <code>pyproject.toml</code>","text":"<ul> <li>what backend to build the package: build-system (Instead of setup.py/setup.cfg or others, the backend to build the package is poetry)</li> <li>some metadata for the project: tool.poetry (the initial version of the package*, description etc.)</li> <li>the dependencies for the app: tool.poetry.dependencies</li> <li>gotcha - The name in <code>pyproject.toml</code> should be the same as the package</li> </ul>"},{"location":"contributing/index.html#working-with-jupyter-notebook","title":"Working with jupyter notebook","text":"<p>It's possible to run jupyter notebook using an existing poetry environment. Install the following package at the global or user level:</p> <p><code>pip install --user poetry-kernel</code></p> <p>As long as <code>ares-sc2</code> was installed with the <code>notebook</code> dependencies, then when launching jupyter notebook there should be an option to open a notebook with the poetry kernel</p>"},{"location":"tutorials/index.html","title":"Tutorials","text":"<p>In this section you'll find tutorials of how to accomplish certain tasks in <code>ares-sc2</code></p>"},{"location":"tutorials/assigning_unit_roles.html","title":"Assigning Unit Roles","text":"<p>When it comes to elevating your bot's strategic capabilities, leveraging the unit role management  system in <code>ares-sc2</code> becomes an invaluable asset.</p> <p>Let's consider a simple yet effective example: orchestrating ling harassment.</p> <p>The Scenario: Picture an early-game offensive with 2 roaches and 12 zerglings.  However, the enemy has left their third base unguarded.  What if, amidst the distraction caused by our main force, we could dispatch  half of our zerglings to assail the vulnerable third base?</p>"},{"location":"tutorials/assigning_unit_roles.html#basic-a-move","title":"Basic A-Move","text":"<p>Initially, let's implement a straightforward a-move bot using only <code>python-sc2</code>, devoid of any <code>ares-sc2</code> logic.</p> <pre><code>from ares import AresBot\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.units import Units\n\nclass MyBot(AresBot):\n    LING_ROACH_TYPES: set[UnitTypeId] = {\n        UnitTypeId.ZERGLING, UnitTypeId.ROACH\n    }\n\n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(MyBot, self).on_step(iteration)\n\n        if ling_roach_force := self.units(self.LING_ROACH_TYPES):\n            attack_target = self.enemy_start_locations[0]\n            self._micro_ling_and_roaches(\n                ling_roach_force, attack_target\n            )\n\n\n    def _micro_ling_and_roaches(\n        self, ling_roach_force: Units, target: Point2\n    ) -&gt; None:\n        for unit in ling_roach_force:\n            unit.attack(target)\n</code></pre> <p>This basic strategy involves a simple attack-move command, lacking any intricate logic.  Now, let's introduce unit roles and assign them dynamically using the <code>on_unit_created</code> hook.</p> <pre><code>from ares import AresBot\n\n# ADD IMPORT\nfrom ares.consts import UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.units import Units\nfrom sc2.unit import Unit\n\nclass MyBot(AresBot):\n    LING_ROACH_TYPES: set[UnitTypeId] = {\n        UnitTypeId.ZERGLING, UnitTypeId.ROACH\n    }\n\n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(MyBot, self).on_step(iteration)\n\n        ling_roach_force: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n        if ling_roach_force:\n            attack_target = self.enemy_start_locations[0]\n            self._micro_ling_and_roaches(\n                ling_roach_force, attack_target\n            )\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        await super(MyBot, self).on_unit_created(unit)\n\n        # assign all units to ATTACKING role by default\n        if unit.type_id in self.LING_ROACH_TYPES:\n            self.mediator.assign_role(\n                tag=unit.tag, role=UnitRole.ATTACKING\n            )\n\n\n    def _micro_ling_and_roaches(\n        self, ling_roach_force: Units, target: Point2\n    ) -&gt; None:\n        for unit in ling_roach_force:\n            unit.attack(target)\n</code></pre> <p>This enhancement allows us to categorize units into roles upon creation,  enabling us to later retrieve our attacking force using:</p> <pre><code>ling_roach_force: Units = self.mediator.get_units_from_role(\n    role=UnitRole.ATTACKING\n)\n</code></pre>"},{"location":"tutorials/assigning_unit_roles.html#implementing-ling-harassment","title":"Implementing Ling Harassment","text":"<p>Now, let's add a layer of complexity by selectively assigning half of the zerglings to a harassment role.</p> <pre><code>from ares import AresBot\n\nfrom ares.consts import UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.units import Units\nfrom sc2.unit import Unit\n\nclass MyBot(AresBot):\n    LING_ROACH_TYPES: set[UnitTypeId] = {\n        UnitTypeId.ZERGLING, UnitTypeId.ROACH\n    }\n\n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n\n        # Add attribute to remember assigning ling harass\n        self._assigned_ling_harass: bool = False\n\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(MyBot, self).on_step(iteration)\n\n        # we can now retrieve our units based on roles\n        ling_roach_force: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n        ling_harassers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.HARASSING\n        )\n\n        if ling_roach_force:\n            if not self._assigned_ling_harass:\n                self._assign_ling_harass(ling_roach_force)\n                self._assigned_ling_harass = True\n\n            attack_target = self.enemy_start_locations[0]\n            self._micro_ling_and_roaches(\n                ling_roach_force, attack_target\n            )\n\n        if ling_harassers:\n            self._micro_ling_harassers(ling_harassers)\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        await super(MyBot, self).on_unit_created(unit)\n\n        # assign all units to ATTACKING role by default\n        if unit.type_id in self.LING_ROACH_TYPES:\n            self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n\n    def _assign_ling_harass(self, ling_roach_force: Units) -&gt; None:\n        # get all lings from our force\n        lings: list[Unit] = [\n            u for u in ling_roach_force if u.type_id == UnitTypeId.ZERGLING\n        ]\n\n        # iterate through lings\n        for i, ling in enumerate(lings):\n            # if current iteration is an even number, assign ling to harass\n            # this should select half lings\n            if i % 2 == 0:\n                # actually assign the role\n                self.mediator.assign_role(\n                    tag=ling.tag, role=UnitRole.HARASSING\n                )\n\n    def _micro_ling_and_roaches(\n        self, ling_roach_force: Units, target: Point2\n    ) -&gt; None:\n        # Here we micro the main force\n        for unit in ling_roach_force:\n            unit.attack(target)\n\n    def _micro_ling_harassers(self, ling_harassers: Units) -&gt; None:\n        # Here we micro the harass force\n        for unit in ling_harassers:\n            # now do whatever you want with these harassing units!\n            # here we ask ares for a potential enemy third location\n            unit.attack(self.mediator.get_enemy_third)\n</code></pre> <p>In this improved version, we assign ling harassment  role to every second zergling in our attacking force. We can then retrieve units based on their role and micro them accordingly.</p> <p>Please note this is an  example that assumes 12 zerglings already exist. In your own bot, the logic should flow accordingly for your scenario, like ensuring you already have army units!  Also, you may want to dynamically assign harass throughout the game based on intel rather than as a one-off task.</p>"},{"location":"tutorials/assigning_unit_roles.html#unit-role-tips-and-tricks","title":"Unit Role tips and tricks","text":""},{"location":"tutorials/assigning_unit_roles.html#switching-roles","title":"Switching roles","text":"<p>For example, switching units from <code>ATTACKING</code> to <code>DEFENDING</code></p> <pre><code>self.mediator.switch_roles(\n    from_role=UnitRole.ATTACKING, to_role=UnitRole.DEFENDING\n)\n</code></pre>"},{"location":"tutorials/assigning_unit_roles.html#selecting-unit-types-from-role","title":"Selecting unit types from role","text":"<p>For example, you have many harasser unit types assigned such as banshee, hellions and reapers, but you only want the banshees:</p> <pre><code>self.mediator.get_units_from_role(\n    role=UnitRole.HARASSING, unit_type={UnitTypeId.BANSHEE}\n)\n</code></pre>"},{"location":"tutorials/assigning_unit_roles.html#getting-units-from-multiple-roles","title":"Getting units from multiple roles","text":"<pre><code>self.mediator.get_units_from_roles(\n    roles={UnitRole.HARASSING, UnitRole.DROP_UNITS_ATTACKING}\n)\n</code></pre>"},{"location":"tutorials/assigning_unit_roles.html#clear-a-role","title":"Clear a role","text":"<p>Removes a unit from the unit role system completely. <pre><code>self.mediator.clear_role(tag=unit.tag)\n</code></pre></p>"},{"location":"tutorials/assigning_unit_roles.html#aress-role-dictionary","title":"Ares's role dictionary","text":"<p>Might be useful for debugging <pre><code>self.mediator.get_unit_role_dict\n</code></pre></p>"},{"location":"tutorials/build_runner.html","title":"Build Runner","text":""},{"location":"tutorials/build_runner.html#build-runner-system","title":"Build Runner System","text":"<p>The Build Runner System is a tool that enables swift build prototyping through a configuration file.  Optional data usage can be incorporated to maintain build history. IMPORTANT: The build runner system is designed only for curating optimized build orders in the first few minutes of the game. Your bot  should switch to dynamic behavior after completion, checked via <code>self.build_order_runner.build_completed</code>.</p>"},{"location":"tutorials/build_runner.html#declaring-openings","title":"Declaring openings","text":"<p>To initiate the Build Runner, a <code>&lt;my_race_lowercase&gt;_builds.yml</code> file should be included in the root directory of  your bot project. Check starter-bot for example If you are playing as the Random race, then a yml file must be declared for each race that you wish ares to handle  openings and/or data management for.</p> <p>Below is an example of a valid yml file. (<code>protoss_builds.yml</code>) <pre><code># Save the game opening and result to disk?\n# Setting to `True` allows Ares to select a new opening after defeat\nUseData: True\n# How should we choose a build?\n# Cycle simply switches on defeat\n# WinrateBased uses winrates to select a build\nBuildSelection: Cycle\n# if chosen by WinrateBased, how many games must be played\n# will use Cycle method while building data\nMinGamesWinrateBased: 3\n# For each Race / Opponent ID choose a build selection\nBuildChoices:\n    # test_123 is active if Debug: True (set via a `config.yml` file)\n    test_123:\n        BotName: Test\n        Cycle:\n            - FastExpand\n\n    Protoss:\n        BotName: ProtossRace\n        Cycle:\n            - FastExpand\n            - WorkerBuild\n\n    Random:\n        BotName: RandomRace\n        Cycle:\n            - FastExpand\n\n    Terran:\n        BotName: TerranRace\n        Cycle:\n            - FastExpand\n\n    Zerg:\n        BotName: ZergRace\n        Cycle:\n            - FastExpand\n            - WorkerBuild\n\n    # Can also use specific opponent ids (overrides race options above)\n    a_bot_opponent_id_from_aiarena:\n        BotName: QueenBot\n        Cycle:\n            - FastExpand\n\nBuilds:\n    WorkerBuild:\n        ConstantWorkerProductionTill: 22\n        OpeningBuildOrder:\n            - 12 chrono @ nexus\n            - 14 pylon @ ramp\n            - 16 gateway\n    FastExpand:\n        ConstantWorkerProductionTill: 0\n        OpeningBuildOrder:\n            ['12 worker', '13 worker', '14 supply', '14 worker', '14 chrono @ nexus',\n             '15 worker', '15 gateway', '16 worker', '17 expand', '17 worker', '17 zealot']\n</code></pre></p> <p>Note the two different ways of declaring builds. Turning <code>ConstantWorkerProductionTill</code> on allows a readable build order but may be undesirable in a fine-tuned build. (setting to 0 disables) Each build order statement should begin with a supply count, the step will not commence till the supply is equal or greater than this supply. Therefore, if this is not important, or you're not sure put a low value. ie. <code>[\"14 pylon\", \"1 gateway\"]</code> will work just as well.</p> <p>Under the BuildChoices key, you should include keys for each enemy race. You may also use opponent IDs instead of races  to select specific openings for opponents. Under the Cycle key, declare the opening build names for that opponent or  race. For each build name, ensure that there is a corresponding build name under Builds.</p> <p>WARNING: The build runner is dumb by nature, and expected to be told exactly what to do. Please be careful adding build steps that are impossible to commence. Such as adding a barracks before a  supply depot or a gateway before pylon.</p> <p>Further to this, be careful adding steps where units require morphing from other units. If you want banelings then it's up to the author to ensure zerglings are around. If you require an Archon then two templar should exist to ensure the morph is successful. The build runner will not fill in the gaps for you.</p>"},{"location":"tutorials/build_runner.html#valid-build-order-options","title":"Valid build order options","text":"<p>Each item in the build order should contain a string, with the first word being the command.  This supports any <code>UnitTypeID</code>  or <code>UpgradeId</code> type from python-sc2.</p> <p>A few extra options are also supported: <pre><code>class BuildOrderOptions(str, Enum):\n    ADDONSWAP = \"ADDONSWAP\"\n    CANCEL_GAS = \"CANCEL_GAS\"\n    CHRONO = \"CHRONO\"\n    CORE = \"CORE\"\n    GAS = \"GAS\"\n    GATE = \"GATE\"\n    EXPAND = \"EXPAND\"\n    ORBITAL = \"ORBITAL\"\n    OVERLORD_SCOUT = \"OVERLORD_SCOUT\"\n    SUPPLY = \"SUPPLY\"\n    WORKER = \"WORKER\"\n    WORKER_SCOUT = \"WORKER_SCOUT\"\n</code></pre></p> <p>Additionally, strings may contain targets such as <code>14 pylon @ ramp</code>, where the last word should contain the target  command. The following targets are currently supported: <pre><code>class BuildOrderTargetOptions(str, Enum):\n    ENEMY_FOURTH = \"ENEMY_FOURTH\"\n    ENEMY_NAT = \"ENEMY_NAT\"\n    ENEMY_NAT_HG_SPOT = \"ENEMY_NAT_HG_SPOT\"\n    ENEMY_NAT_VISION = \"ENEMY_NAT_VISION\"\n    ENEMY_RAMP = \"ENEMY_RAMP\"\n    ENEMY_SPAWN = \"ENEMY_SPAWN\"\n    ENEMY_THIRD = \"ENEMY_THIRD\"\n    FIFTH = \"FIFTH\"\n    FOURTH = \"FOURTH\"\n    MAP_CENTER = \"MAP_CENTER\"\n    NAT = \"NAT\"\n    NAT_WALL = \"NAT_WALL\"\n    RAMP = \"RAMP\"\n    SIXTH = \"SIXTH\"\n    SPAWN = \"SPAWN\"\n    THIRD = \"THIRD\"\n</code></pre></p>"},{"location":"tutorials/build_runner.html#addonswap","title":"AddOnSwap","text":"<p>AddOnSwap is a special command that allows you to swap out structures so you can steal another structure's addon. The last two words of the command should contain two UnitTypeID's. The first is the structure that requires an addon, and the second is the target addon structure.</p> <p>Examples:</p> <p>Classic case of the factory swapping with the barracks that has a reactor so we can mass hellions: <pre><code>- 22 addonswap factory barracksreactor\n</code></pre></p> <p>Starport steals the factory techlab so we can make banshees and research cloak: <pre><code>- 22 addonswap starport factorytechlab\n</code></pre></p> <p>WARNING: Please ensure you have both the structure and the addon in your build order leading up to this build order step.</p> <p>Full example build order with an addonswap: <pre><code>    OneOneOneReaperHellion:\n        ConstantWorkerProductionTill: 30\n        OpeningBuildOrder:\n            - 14 supply @ ramp\n            - 16 barracks @ ramp\n            - 16 gas\n            - 0 orbital\n            - 0 reaper\n            - 19 expand\n            - 20 marine\n            - 21 factory @ ramp\n            - 21 gas\n            - 21 barracksreactor\n            - 21 supply *2\n            - 21 orbital\n            - 21 starport\n            - 21 addonswap factory barracksreactor\n</code></pre></p>"},{"location":"tutorials/build_runner.html#autosupply-optional","title":"AutoSupply (optional)","text":"<p>Automatically handle building supply structures after the supply set. Enable AutoSupply in your build order at a specific supply count.  This example turns on AutoSupply after 17 supply so you no longer need to declare supply structures in your build: <pre><code>Builds:\n    DummyBuild:\n        # After 17 supply turn AutoSupply on\n        AutoSupplyAtSupply: 17\n        ConstantWorkerProductionTill: 50\n        OpeningBuildOrder:\n            - 14 pylon @ ramp\n            - 15 worker_scout:\n                [spawn, nat, enemy_spawn, third, fourth, map_center, enemy_nat]\n            - 16 gate\n            - 16 gas\n            - 17 gas\n            - 19 gate\n            - 20 core\n            - 22 adept x2\n            - 25 stargate\n</code></pre></p>"},{"location":"tutorials/build_runner.html#automatic-worker-production-optional","title":"Automatic worker production (optional)","text":"<p>Like AutoSupply, this cleans up your build order. Use <code>ConstantWorkerProductionTill</code> to set an integer value:</p> <pre><code>Builds:\n    ProbeMaxout:\n        # After 0 supply turn AutoSupply on\n        AutoSupplyAtSupply: 0\n        ConstantWorkerProductionTill: 200\n        OpeningBuildOrder:\n            - 200 gateway\n</code></pre>"},{"location":"tutorials/build_runner.html#build-complete","title":"Build complete","text":"<p>Upon completion of the build, a typical bot workflow should allow for dynamic production. To check whether the opening  has been completed or not, you can use the following method call:</p> <pre><code>self.build_order_runner.build_completed\n</code></pre>"},{"location":"tutorials/build_runner.html#set-build-complete","title":"Set build complete","text":"<p>You can set the build to be complete at any time using the following: <pre><code>self.build_order_runner.set_build_completed()\n</code></pre></p>"},{"location":"tutorials/build_runner.html#chronoboost","title":"Chronoboost","text":"<p>For chrono, target structures using UnitTypeID, e.g.:</p> <pre><code>- 13 chrono @ nexus\n- 16 chrono @ gateway\n- 20 chrono @ cyberneticscore\n</code></pre>"},{"location":"tutorials/build_runner.html#duplicate-commands","title":"Duplicate commands","text":"<p>Use <code>x</code>, <code>X</code>, or <code>*</code> followed by an integer to duplicate commands. Ensure sufficient supply. And consider turning <code>AutoSupply</code> option on if using duplicate commands.</p> <p>Examples: <pre><code>- 12 worker x3\n</code></pre></p> <pre><code>- 12 pylon @ ramp *5\n</code></pre> <pre><code>- 15 barracks ramp *2\n</code></pre> <pre><code>- 42 roach *16\n</code></pre>"},{"location":"tutorials/build_runner.html#retrieve-the-opening-build-name","title":"Retrieve the opening build name","text":"<p>Retrieve the opening build name using the following method call:</p> <p><code>self.build_order_runner.chosen_opening</code></p> <p>This method will return a string value containing the name of the currently selected build from the  <code>&lt;my_race_lowercase&gt;_builds.yml</code> file.</p>"},{"location":"tutorials/build_runner.html#scouting","title":"Scouting","text":"<p><code>worker_scout</code> and <code>overlord_scout</code> options are currently available.</p>"},{"location":"tutorials/build_runner.html#simple-worker-scout","title":"Simple worker scout","text":"<p>Use <code>worker_scout</code> to scout the enemy base: <pre><code>Builds:\n    DummyBuild:\n        OpeningBuildOrder:\n            - 12 worker_scout\n</code></pre></p>"},{"location":"tutorials/build_runner.html#advanced-worker-scout","title":"Advanced worker scout","text":"<p>Provide locations via a list for the worker to scout: <pre><code>Builds:\n    DummyBuild:\n        OpeningBuildOrder:\n            - 12 worker_scout:\n                  [spawn, nat, enemy_spawn, third, fourth, map_center, enemy_nat]\n</code></pre></p> <p>See <code>BuildOrderTargetOptions</code> above for all valid options.</p>"},{"location":"tutorials/build_runner.html#overlord-scout","title":"Overlord scout","text":"<p>Use <code>overlord_scout</code> command to send overlord to scout. Unlike the worker scout there is no default behavior so please provide locations. See example below, overlord checks enemy natural, then finds a close high ground spot. <pre><code>Builds:\n    DummyBuild:\n        OpeningBuildOrder:\n            - 12 overlord_scout:\n                  [enemy_nat_vision, enemy_nat_hg_spot]\n</code></pre></p> <p>See <code>BuildOrderTargetOptions</code> above for all valid options.</p>"},{"location":"tutorials/build_runner.html#taking-control-of-scouts","title":"Taking control of scouts","text":"<p>Take the following scenario: Your worker scout has found a proxy, and you want to harass the enemy scv. The build runner takes no opinion how your scout should handle this scenario, but you can grab control of the worker and issue your own commands. Internally <code>ares-sc2</code> assigns scouts to the <code>BUILD_RUNNER_SCOUT</code> <code>UnitRole</code>, so we can grab the scout via the mediator like so:</p> <pre><code>worker_scouts: Units = self.mediator.get_units_from_role(\n    role=UnitRole.BUILD_RUNNER_SCOUT, unit_type=self.worker_type\n)\nfor scout in worker_scouts:\n    # issue custom commands\n    pass\n</code></pre> <p>You can retrieve overlord scouts in a similar manner.</p>"},{"location":"tutorials/build_runner.html#spawning-units","title":"Spawning units","text":"<p>Targets may be used to target warp ins, for example: <pre><code>- 36 adept @ enemy_nat\n</code></pre> Will warp in an adept at a power field closest to the enemy natural. <pre><code>- 36 marine @ enemy_nat\n</code></pre> Will prioritize using barracks closest to the enemy natural.</p> <p>If omitted the default spawn target is our start location. <pre><code># this is perfectly fine\n- 36 adept\n</code></pre></p>"},{"location":"tutorials/build_runner.html#switch-openings-on-the-fly","title":"Switch openings on the fly","text":"<p>It's possible to switch openings on the fly, <code>ares</code> will attempt to work out which build steps have already completed and find a reasonable point in the new build order to resume from.</p> <p>You should pass a valid opening name from your builds yaml file, something like: <pre><code>if self.opponent_is_cheesing:\n    self.build_order_runner.switch_opening(\"DefensiveOpening\")\n</code></pre> Note that if an incorrect opening name is passed here the bot will terminate.</p>"},{"location":"tutorials/build_runner.html#switching-off-gas-steal-logic","title":"Switching off gas steal logic","text":"<p>The build runner will automatically attempt to prevent the enemy stealing your gas buildings, turn this off via the <code>ShouldHandleGasSteal</code> like so:</p> <pre><code>Builds:\n    DummyBuild:\n        ShouldHandleGasSteal: False\n        OpeningBuildOrder:\n            - 12 worker_scout\n</code></pre>"},{"location":"tutorials/chat_debug.html","title":"Chat Debug","text":"<p><code>ares</code> features an in game chat debug system, this is especially handy for quickly testing different scenarios.</p>"},{"location":"tutorials/chat_debug.html#activating-chat-debug","title":"Activating chat debug","text":"<p>In your <code>config.yml</code> set the following options to <code>True</code>:</p> <ul> <li><code>Debug: True</code></li> <li><code>ChatDebug: True</code> (found under <code>DebugOptions</code>)</li> </ul>"},{"location":"tutorials/chat_debug.html#using-chat-debug","title":"Using chat debug","text":"<p>The chat debug feature should be used in the SC2 game window only. The chat debug service in <code>ares</code> will parse chat messages and check for valid debug commands.</p>"},{"location":"tutorials/chat_debug.html#spawning-units","title":"Spawning units","text":"<p>Spawn new units directly where the in game camera is. To trigger the first word should be <code>make</code> or <code>create</code>, the second word is the amount of units/structures  to create, the third is a valid <code>UnitTypeId</code> type, and the fourth should be the player for which units should be spawned  (there is a default value of <code>1</code> for this, so omit if spawning for player 1).</p> <p>Here are some valid commands you can try:</p> <p><code>make 4 marine</code> - Spawns 4 marines for player 1 at camera location.</p> <p><code>make 3 mothership 1</code> - Spawns 3 motherships for player 1 at camera location. </p> <p><code>make 1 hive 2</code> - Spawn a hive for the enemy at camera location. Note the 2 in the chat command, this spawns units for the enemy. </p> <p><code>create 4 banshee 2</code> - Spawn four banshees for the enemy at camera location. </p> <p><code>create 2 ultralisk 1</code> - Spawn two ultralisks for player one at camera location. Specifying player one in this command even though it's not required.</p> <p></p>"},{"location":"tutorials/chat_debug.html#destroying-units","title":"Destroying units","text":"<p>Destroy units using the same syntax for creating units, but for the first word use <code>kill</code> or <code>destroy</code>. The destroy commands do not take into account camera location and will kill units off camera if needed.</p> <p>Here are some valid commands you can try:</p> <p><code>kill 4 marine</code> - Destroys 4 marines for player 1.</p> <p><code>kill 125 mothership 2</code> - Destroys 125 motherships. Note the 2 in the chat command, this kills units for the enemy. </p> <p><code>kill 1 hive</code> - Destroys a hive for player one. </p> <p><code>destroy 4 banshee</code> - Destroys three banshees for player one. </p> <p><code>destroy 2 ultralisk 1</code> - Destroys two ultralisks for player one. Specifying player one in this command even though it's not required.</p>"},{"location":"tutorials/chat_debug.html#additional-options","title":"Additional options","text":"<p>You can toggle cheats with the following chat commands:</p> <ul> <li><code>cooldown</code> - Disables cooldowns of unit abilities for the bot</li> <li><code>food</code> - Disable food usage (not sure this one works)</li> <li><code>god</code> - Units and structures no longer take damage</li> <li><code>resources</code> - Get 5000 minerals and 5000 vespene</li> <li><code>show</code> - Reveal map</li> <li><code>tech</code> - Remove all tech requirements</li> <li><code>upgrades</code> - Research all currently available upgrades</li> </ul>"},{"location":"tutorials/combat_maneuver_example.html","title":"Combat Maneuver Example","text":"<p>Combat Behaviors serve as essential components for constructing intricate unit and group control strategies.  These behaviors act as modular elements that can be combined to create bespoke combat maneuvers.  To facilitate the process of creating army behaviors, a practical aid called the <code>CombatManeuver</code> helper  class is made available.</p> <p>To illustrate the concept, consider the following example that demonstrates the execution of a mine drop: <pre><code>from ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.individual import (\n    DropCargo,\n    KeepUnitSafe,\n    PathUnitToTarget,\n    PickUpCargo,\n)\nfrom sc2.unit import Unit\nfrom sc2.units import Units\nimport numpy as np\n\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -&gt; None:\n        # retrieve medivac and mines_to_pickup and pass to method\n        # left out here for clarity\n        # mines would require their own behavior\n        self.do_medivac_mine_drop(medivac, mines_to_pickup)\n\n    def do_medivac_mine_drop(\n            self, \n            medivac: Unit, \n            mines_to_pickup: Units\n    ) -&gt; None:\n        # initialize a new CombatManeuver\n        mine_drop: CombatManeuver = CombatManeuver()\n        # get a grid for the medivac to path on\n        air_grid: np.ndarray = self.mediator.get_air_grid\n        # first priority is picking up units\n        mine_drop.add(\n            PickUpCargo(\n                unit=medivac, \n                grid=air_grid, \n                pickup_targets=mines_to_pickup)\n        )\n        # if there is cargo, path to target and drop them off\n        if medivac.has_cargo:\n            # path\n            mine_drop.add(\n                PathUnitToTarget(\n                    unit=medivac,\n                    grid=air_grid,\n                    target=self.enemy_start_locations[0],\n                )\n            )\n            # drop off the mines\n            mine_drop.add(\n                DropCargo(unit=medivac, target=medivac.position)\n            )\n        # no cargo and no units to pick up, stay safe\n        else:\n            mine_drop.add(\n                KeepUnitSafe(unit=medivac, grid=air_grid)\n            )\n\n        # finally register this maneuver to be executed\n        self.register_behavior(mine_drop)\n</code></pre></p> <p>Combat Behaviors can also be executed individually if required: <pre><code>self.register_behavior(KeepUnitSafe(unit=medivac, grid=air_grid))\n</code></pre></p>"},{"location":"tutorials/config_file.html","title":"Config File","text":"<p>Coming soon \u2122</p>"},{"location":"tutorials/custom_behaviors.html","title":"Creating Custom Behaviors","text":"<p>Recommended reading: How to curate Combat Maneuver's using existing <code>Behavior</code>'s in <code>ares-sc2</code>. Before curating custom behaviors, take a look at some of the  core behaviors in ares-sc2, to get an idea how one should be structured.</p> <p>Let's start with a simple example, we have a group of marines and tanks we would like to micro. Let's use the <code>CombatManeuver</code> functionality in <code>ares-sc2</code> to orchestrate a simple a-move across the map.</p> <pre><code>from ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.individual import AMove\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.units import Units\nfrom sc2.position import Point2\n\n\nclass MyBot(AresBot):\n    MARINE_TANK_TYPES: set[UnitTypeId] = {\n        UnitTypeId.MARINE, UnitTypeId.SIEGETANKSIEGED, UnitTypeId.SIEGETANK\n    }\n\n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(MyBot, self).on_step(iteration)\n\n        if marine_tank_force := self.units(self.MARINE_TANK_TYPES):\n            attack_target = self.enemy_start_locations[0]\n            self._micro_marine_tank(marine_tank_force, attack_target)\n\n    def _micro_marine_tank(self, units: Units, target: Point2) -&gt; None:\n        for unit in units:\n            # set up a new CombatManeuver for this unit\n            offensive_attack: CombatManeuver = CombatManeuver()\n            # add AMove to this maneuver\n            offensive_attack.add(AMove(unit, target))\n            # register the maneuver so it gets executed\n            self.register_behavior(offensive_attack)\n</code></pre> <p>This is all working great, how about now we add decision-making to siege or unsiege our tanks?</p> <p>The problem: there isn't an existing combat behavior in <code>ares-sc2</code> to do this. This is partly intentional since sieging/unsieging tanks is a strategic decision personal to your bot.</p> <p>We propose a solution: create a reusable custom combat behavior that <code>ares-sc2</code> understands and can be executed.</p> <p>As long as our behavior class follows the <code>CombatIndividualBehavior</code> Protocol, we can add it to our existing <code>offensive_attack</code> <code>CombatManeuver</code>.  - <code>CombatIndividualBehavior</code> Protocol says we should implement an <code>execute</code> method with the following signature:</p> <p><code>def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:</code></p> <p>Notice this method should return a <code>booleon</code>, this should return <code>True</code> if this implemented <code>CombatIndividualBehavior</code> carried out an action, and <code>False</code> otherwise.</p> <p>With this is mind let's implement a <code>SiegeTankDecision</code> custom behavior, you could save this in a new <code>siege_tank_decision.py</code> file:</p> <pre><code># siege_tank_decision.py`\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING\n\nfrom ares.behaviors.combat.individual import CombatIndividualBehavior\nfrom ares.cython_extensions.geometry import cy_distance_to\nfrom ares.managers.manager_mediator import ManagerMediator\nfrom ares.consts import UnitTreeQueryType\nfrom sc2.ids.ability_id import AbilityId\nfrom sc2.ids.unit_typeid import UnitTypeId as UnitID\nfrom sc2.position import Point2\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nif TYPE_CHECKING:\n    from ares import AresBot\n\n@dataclass\nclass SiegeTankDecision(CombatIndividualBehavior):\n    \"\"\"Decide if a tank should either siege or unsiege.\n\n    Attributes\n    ----------\n    unit : Unit\n        The siege tank unit.\n    \"\"\"\n\n    unit: Unit\n\n    def execute(self, ai: \"AresBot\", config: dict, mediator: ManagerMediator) -&gt; bool:\n        unit_pos: Point2 = self.unit.position\n        type_id: UnitID = self.unit.type_id\n\n        # get near enemy ground\n        # ares uses `KDTree` algorithm for faster distance queries\n        # let's make use of that\n        near_enemy_ground: Units = mediator.get_units_in_range(\n            start_points=[self.unit.position],\n            distances=14,\n            query_tree=UnitTreeQueryType.EnemyGround,\n        )[0]\n\n        if type_id == UnitID.SIEGETANK:\n            # if enemies are not too close, and enough ground enemy around then siege\n            close_to_tank: list[Unit] = [\n                e for e in near_enemy_ground if cy_distance_to(e.position, unit_pos) &lt; 6.5\n            ]\n            if len(close_to_tank) == 0 and (\n                (ai.get_total_supply(near_enemy_ground) &gt;= 4.0 and len(near_enemy_ground) &gt; 3)\n            ):\n                self.unit(AbilityId.SIEGEMODE_SIEGEMODE)\n                return True\n\n        elif type_id == UnitID.SIEGETANKSIEGED:\n            # just a general if nothing around then unsiege\n            if len(near_enemy_ground) == 0:\n                self.unit(AbilityId.UNSIEGE_UNSIEGE)\n                return True\n\n        # no action was carried out\n        return False\n</code></pre> <p>This is an example, this could be tweaked and extended as required. Meanwhile, this custom <code>Behavior</code> can be reused in other scenarios!</p> <p>Let's update our original code to import this <code>Behavior</code> and include it in our <code>offensive_attack</code> maneuver:</p> <pre><code>from ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.individual import AMove\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.units import Units\nfrom sc2.position import Point2\n\n# IMPORT SiegeTankDecision, modify import based on where you saved it\nfrom bot.siege_tank_decision import SiegeTankDecision\n\n\nclass MyBot(AresBot):\n    MARINE_TANK_TYPES: set[UnitTypeId] = {\n        UnitTypeId.MARINE, UnitTypeId.SIEGETANKSIEGED, UnitTypeId.SIEGETANK\n    }\n\n    def __init__(self, game_step_override=None):\n        \"\"\"Initiate custom bot\"\"\"\n        super().__init__(game_step_override)\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(MyBot, self).on_step(iteration)\n\n        if marine_tank_force := self.units(self.MARINE_TANK_TYPES):\n            attack_target = self.enemy_start_locations[0]\n            self._micro_marine_tank(marine_tank_force, attack_target)\n\n    def _micro_marine_tank(self, units: Units, target: Point2) -&gt; None:\n        for unit in units:\n            # set up a new CombatManeuver for this unit\n            offensive_attack: CombatManeuver = CombatManeuver()\n\n            # ADD OUR CUSTOM SIEGE BEHAVIOR HERE\n            # Maneuvers should be set up so that higher priority tasks are added first.\n            # If this returns False for a tank, then the \n            # AMove behavior will try to execute an action instead\n            offensive_attack.add(SiegeTankDecision(unit))\n\n            # add AMove to this maneuver\n            # AMove always returns True so should typically be added at the end\n            offensive_attack.add(AMove(unit, target))\n            # register the maneuver so it gets executed\n            self.register_behavior(offensive_attack)\n</code></pre>"},{"location":"tutorials/custom_building_placements.html","title":"Custom Building Placements","text":"<p>Although ares-sc2 automatically calculates building formations for all base locations,  there are situations where precise placement is critical, and custom-building layouts  are preferred. To address this, ares-sc2 allows users to specify custom-building positions,  which are seamlessly integrated into its placement calculations. These custom placements  are fully compatible with core <code>ares-sc2</code> features, such as the Build Runner, <code>BuildStructure</code> behavior, and direct interactions with the building tracker via the <code>ManagerMediator</code>.  Additionally, the system ensures that standard placements within a base location adapt  to account for user-defined custom positions.</p> <p>At present, custom placements are supported exclusively for Protoss vs. Zerg natural wall setups.  Support for additional scenarios will be introduced in future updates.</p>"},{"location":"tutorials/custom_building_placements.html#defining-custom-placements","title":"Defining custom placements","text":"<p>Create a file in the root of your bot folder names <code>building_placements.yml</code>, you should enter placements into this file like below.</p> <pre><code>Protoss:\n    AbyssalReef:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [[64., 105.]]\n                Pylons: [[63., 112.]]\n                ThreeByThrees: [[68.5, 109.5], [66.5, 106.5], [60.5, 106.5]]\n                StaticDefences: [[64., 110.]]\n                GateKeeper: [[62.25, 105.86]]\n            LowerSpawn:\n                FirstPylon: [[136., 39.]]\n                Pylons: [[137., 32.]]\n                ThreeByThrees: [[131.5, 34.5], [133.5, 37.5], [139.5, 37.5]]\n                StaticDefences: [[136., 36.]]\n                GateKeeper: [[137.25, 38.6]]\n    Acropolis:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 35., 109. ] ]\n                Pylons: [ [ 32., 109. ] ]\n                ThreeByThrees: [ [ 38.5, 106.5 ], [ 34.5, 105.5 ], [ 31.5, 105.5 ] ]\n                StaticDefences: [ [ 39., 109. ] ]\n                GateKeeper: [ [ 36.6, 105.6 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 141., 63. ] ]\n                Pylons: [ [ 144., 63. ] ]\n                ThreeByThrees: [ [ 137.5, 66.5 ], [ 141.5, 66.5 ], [ 144.5, 66.5 ] ]\n                StaticDefences: [ [ 137., 63. ] ]\n                GateKeeper: [ [ 139.3, 67.4 ] ]\n    Automaton:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 141., 139. ] ]\n                Pylons: [ [ 140., 142. ] ]\n                ThreeByThrees: [ [ 138.5, 133.5 ], [ 136.5, 137.5 ], [ 136.5, 140.5 ] ]\n                StaticDefences: [ [ 142., 136. ] ]\n                GateKeeper: [ [ 136.9, 135.6 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 43., 42. ] ]\n                Pylons: [ [ 44., 39. ] ]\n                ThreeByThrees: [ [ 45.5, 46.5 ], [ 47.5, 42.5 ], [ 47.5, 39.5 ] ]\n                StaticDefences: [ [ 42., 45. ] ]\n                GateKeeper: [ [ 47.15, 45.3 ] ]\n    Ephemeron:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 37., 112. ] ]\n                Pylons: [ [ 37., 109. ] ]\n                ThreeByThrees: [ [ 42.5, 114.5 ], [ 42.5, 110.5 ], [ 41.5, 107.5 ] ]\n                StaticDefences: [ [ 38., 115. ] ]\n                GateKeeper: [ [ 43.1, 112.58 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 125., 49. ] ]\n                Pylons: [ [ 125., 52. ] ]\n                ThreeByThrees: [ [ 120.5, 45.5 ], [ 120.5, 49.5 ], [ 120.5, 52.5 ] ]\n                StaticDefences: [ [ 125., 46. ] ]\n                GateKeeper: [ [ 119.7, 47.4 ] ]\n    Interloper:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 31., 112. ] ]\n                Pylons: [ [ 31., 109. ] ]\n                ThreeByThrees: [ [ 35.5, 114.5 ], [ 35.5, 110.5 ], [ 35.5, 107.5 ] ]\n                StaticDefences: [ [ 31., 115. ] ]\n                GateKeeper: [ [ 36.16, 112.68 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 121., 56. ] ]\n                Pylons: [ [ 121., 59. ] ]\n                ThreeByThrees: [ [ 116.5, 53.5 ], [ 116.5, 57.5 ], [ 116.5, 60.5 ] ]\n                StaticDefences: [ [ 121., 53. ] ]\n                GateKeeper: [ [ 115.78, 55.75 ] ]\n    Thunderbird:\n        VsZergNatWall:\n            AvailableVsRaces: [\"Zerg\", \"Random\"]\n            UpperSpawn:\n                FirstPylon: [ [ 46., 106. ] ]\n                Pylons: [ [ 46., 103. ] ]\n                ThreeByThrees: [ [ 50.5, 109.5 ], [ 50.5, 105.5 ], [ 50.5, 102.5 ] ]\n                StaticDefences: [ [ 46., 109. ] ]\n                GateKeeper: [ [ 51.18, 107.67 ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 144., 51 ] ]\n                Pylons: [ [ 144., 54. ] ]\n                ThreeByThrees: [ [ 139.5, 46.5 ], [ 139.5, 50.5 ], [ 139.5, 53.5 ] ]\n                StaticDefences: [ [ 144., 48. ] ]\n                GateKeeper: [ [ 138.64, 48.49 ] ]\n</code></pre> <p>The values shown above are the default settings in ares, so there's no need to  create your own file if you're satisfied with them. However, you can customize  these settings by creating your own building_placements.yml file and specifying  only the elements you wish to change. ares-sc2 will automatically prioritize  your custom placements and fill in any missing elements with the default values.</p> <p>This is an example contents of a <code>building_placements.yml</code> file where the first pylon position on Thunderbird is tweaked. <pre><code>    Thunderbird:\n        VsZergNatWall:\n            UpperSpawn:\n                FirstPylon: [ [ 47., 107. ] ]\n            LowerSpawn:\n                FirstPylon: [ [ 143., 52 ] ]\n</code></pre></p> <p>When creating your building placements file, ensure the keys are spelled correctly and match the example above. Internally <code>ares-sc2</code> checks an <code>Enum</code> similar to this when parsing the file: <pre><code>class BuildingPlacementOptions(str, Enum):\n    LOWER_SPAWN = \"LowerSpawn\"\n    UPPER_SPAWN = \"UpperSpawn\"\n    VS_ZERG_NAT_WALL = \"VsZergNatWall\"\n    FIRST_PYLON = \"FirstPylon\"\n    PYLONS = \"Pylons\"\n    THREE_BY_THREES = \"ThreeByThrees\"\n    STATIC_DEFENCES = \"StaticDefences\"\n    GATE_KEEPER = \"GateKeeper\"\n</code></pre></p>"},{"location":"tutorials/custom_building_placements.html#providing-impossible-placements","title":"Providing impossible placements","text":"<p><code>ares-sc2</code> validates your placements before adding them internally. If an invalid placement is detected,  an error message will be logged, but your bot will continue running as normal. If your placements  aren\u2019t working as expected, be sure to check the logs for more details.</p>"},{"location":"tutorials/custom_building_placements.html#retrieve-the-gate-keeper-placement","title":"Retrieve the gate keeper placement","text":"<p>In Protoss vs Zerg this is the gap in the natural wall that is usually blocked by a  gateway unit. Keep in mind this could be <code>None</code> if no position is provided for the current map.</p> <pre><code>nat_wall_gatekeeper_pos: Union[Point2, None] = self.mediator.get_pvz_nat_gatekeeping_pos\n</code></pre>"},{"location":"tutorials/custom_building_placements.html#using-custom-placements-with-ares","title":"Using custom placements with ares","text":"<p>There are several ways these placements can be utilized.</p>"},{"location":"tutorials/custom_building_placements.html#via-the-buildrunner","title":"Via the BuildRunner","text":"<p>See build Runner tutorial if you're unfamiliar.</p> <p>Below is an example of a valid build order that places structures at the natural wall.  To specify that a structure should use your custom natural wall placements, simply  add <code>@ nat_wall</code> when declaring a build step. If the map has no custom placements or  all available positions are already taken, the build runner will automatically find a  suitable alternative nearby.</p> <pre><code>UseData: True\n# How should we choose a build? Cycle is the only option for now\nBuildSelection: Cycle\n# For each Race / Opponent ID choose a build selection\nBuildChoices:\n    # test_123 is active if Debug: True (set via a `config.yml` file)\n    test_123:\n        BotName: Test\n        Cycle:\n            - NatWall\n\n    Protoss:\n        BotName: ProtossRace\n        Cycle:\n            - NatWall\n\n    Random:\n        BotName: RandomRace\n        Cycle:\n            - NatWall\n\n    Terran:\n        BotName: TerranRace\n        Cycle:\n            - NatWall\n\n    Zerg:\n        BotName: ZergRace\n        Cycle:\n            - NatWall\n\n\nBuilds:\n    NatWall:\n        ConstantWorkerProductionTill: 44\n        AutoSupplyAtSupply: 23\n        OpeningBuildOrder:\n            - 14 pylon @ nat_wall\n            - 15 gate @ nat_wall\n            - 16 gate @ nat_wall\n            - 16 core @ nat_wall\n            - 16 pylon @ nat_wall\n            - 16 shieldbattery @ nat_wall\n</code></pre>"},{"location":"tutorials/custom_building_placements.html#buildstructure-behavior","title":"<code>BuildStructure</code> behavior","text":"<p>You can build wall structures within your own bot logic via the  <code>BuildStructure</code> behavior. If wall placements are not available this will look for a closely alternative. Ensure <code>base_location=self.mediator.get_own_nat</code> to ensure natural wall is found. See example code:</p> <pre><code>from sc2.ids.unit_typeid import UnitTypeId\n\nself.register_behavior(\n    BuildStructure(\n        base_location=self.mediator.get_own_nat,\n        structure_id=UnitTypeId.GATEWAY,\n        wall=True,\n        to_count_per_base=2\n    )\n)\nself.register_behavior(\n    BuildStructure(\n        base_location=self.mediator.get_own_nat,\n        structure_id=UnitTypeId.CYBERNETICSCORE,\n        wall=True,\n        to_count_per_base=1\n    )\n)\nself.register_behavior(\n    BuildStructure(\n        base_location=self.mediator.get_own_nat,\n        structure_id=UnitTypeId.PYLON,\n        wall=True,\n        to_count_per_base=2\n    )\n)\nself.register_behavior(\n    BuildStructure(\n        base_location=self.mediator.get_own_nat,\n        structure_id=UnitTypeId.SHIELDBATTERY,\n        wall=True,\n        to_count_per_base=1\n    )\n)\n</code></pre>"},{"location":"tutorials/custom_building_placements.html#via-the-managermediator","title":"Via the <code>ManagerMediator</code>","text":"<p>For more customized control you can interact with the wall placements via the <code>mediator</code>. See some examples below.</p> <p>Get the first pylon placement without reserving placement in the building tracker:</p> <pre><code>from sc2.ids.unit_typeid import UnitTypeId\n\nif placement := mediator.request_building_placement(\n        base_location=self.mediator.get_own_nat,\n        structure_type=UnitTypeId.PYLON,\n        first_pylon=self.first_pylon,\n        reserve_placement=False\n    ):\n    pass\n</code></pre> <p>Work directly with the raw data, example here gets the natural wall placements.</p> <pre><code>from ares.consts import BuildingSize\nfrom sc2.position import Point2\n\nplacements_dict: dict[Point2, dict[BuildingSize, dict]] = self.mediator.get_placements_dict\nnatural_placements: dict[BuildingSize, dict] = placements_dict[self.mediator.get_own_nat]\n\ntwo_by_twos_at_wall: list[Point2] = [\n            placement\n            for placement in natural_placements[BuildingSize.TWO_BY_TWO]\n            if natural_placements[BuildingSize.TWO_BY_TWO][placement][\"is_wall\"]\n        ]\n\nthree_by_threes_at_wall: list[Point2] = [\n            placement\n            for placement in natural_placements[BuildingSize.TWO_BY_TWO]\n            if natural_placements[BuildingSize.THREE_BY_THREE][placement][\"is_wall\"]\n        ]\n</code></pre>"},{"location":"tutorials/gotchas.html","title":"Gotchas","text":""},{"location":"tutorials/gotchas.html#selecting-a-worker","title":"Selecting a worker","text":"<p>If you're using the Mining behavior  and need to select workers to perform tasks, then you should request <code>ares</code> to release workers from mining.</p>"},{"location":"tutorials/gotchas.html#problem","title":"Problem","text":"<p>Behind the scenes, Ares designates workers to <code>UnitRole.GATHERING</code> and automatically assigns  specific resources to each worker. If you try to steal these workers without informing <code>ares</code> the <code>Mining</code> task will send the worker back to mining again.</p>"},{"location":"tutorials/gotchas.html#solution","title":"Solution","text":"<p>Opting to  select a worker through the mediator is recommended.  This not only simplifies internal bookkeeping by removing the worker from mining and assigned resource but also prioritizes a worker  that isn't currently involved in mining or holding resources. The selection process even extends to workers at  distant mineral patches whenever possible.  Additionally, it's worth considering assigning a fresh role to the worker to preempt potential  reassignment by the Mining task. Here's an example: <pre><code>from ares.consts import UnitRole\n\nif worker := self.mediator.select_worker(\n        target_position=self.start_location\n    ):\n    self.mediator.assign_role(tag=worker.tag, role=UnitRole.DEFENDING)\n</code></pre> And to retrieve workers with a <code>DEFENDING</code> role:  <pre><code>from sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.units import Units\n\ndefending_workers: Units = self.mediator.get_units_from_role(\n    role=UnitRole.DEFENDING, unit_type=UnitTypeId.SCV\n)\n</code></pre></p>"},{"location":"tutorials/gotchas.html#mixing-python-sc2-and-ares-sc2","title":"Mixing <code>python-sc2</code> and <code>ares-sc2</code>","text":"<p>If starting with a blank ares bot, all <code>python-sc2</code> logic will work as intended. However, you may start working with <code>ares</code> behaviors or methods that may interfere with common <code>python-sc2</code> convenience methods or functions.</p>"},{"location":"tutorials/gotchas.html#mining-behavior","title":"Mining behavior","text":"<p>If you're using the <code>ares</code> Mining behavior, then this breaks the functionality of the following <code>python-sc2</code> convenience methods.</p> <ul> <li> <p><code>self.build()</code> Problem  Since the <code>Mining</code> behavior takes control of all spare workers by default it does not relinquish control of the worker this method is trying to select.  Solution  There are two solutions:</p> <ul> <li>Avoid <code>python-sc2</code> methods and use <code>ares-sc2</code> build structure functionalities. See:  <code>BuildStructure</code> behavior and  <code>self.mediator.build_with_specific_worker</code>  Additionally the build runner uses <code>ares</code> build functionality if you're using that.</li> <li>If you want to stay with <code>python-sc2</code> for now, the <code>self.build()</code> accepts a <code>build_worker</code> argument, we can ask <code>ares</code> to select a worker and then pass that into the method: <pre><code># building_pos is the area you want to build in\nbuilding_pos: Point2 = self.start_location\n\nif worker := self.mediator.select_worker(target_position=building_pos):\n    # ares has given us a worker, assign it a role so ares doesn't\n    # steal it for mining\n    self.mediator.assign_role(tag=worker.tag, role=UnitRole.BUILDING)\n    # now we are free to use this worker with `self.build())\n    await self.build(\n        building=UnitTypeId.BARRACKS, \n        near=building_pos, \n        build_worker=worker\n    )\n</code></pre></li> </ul> </li> <li> <p><code>self.expand_now()</code> Problem  Same scenario as <code>self.build()</code> but we do not have the same option to pass the worker into the <code>expand_now()</code> as we did with <code>self.build()</code>. Solution  However, we can combine <code>python-sc2</code> and <code>ares-sc2</code> alternative convenience methods for a similar effect. Example:  <pre><code># Use `python-sc2` get_next_expansion to get a new base location\nif next_expand_loc := await self.get_next_expansion():\n    # ask ares for a worker\n    if worker := self.mediator.select_worker(\n            target_position=next_expand_loc,\n            force_close=True,\n    ):\n        # use ares build_with_specific_worker worker to build base\n        # this will assign worker a new role\n        # additionally by using this method, you get some extra functionality!\n        # Such as replacing dead building workers and pathing control or worker\n        self.mediator.build_with_specific_worker(\n            worker=worker,\n            structure_type=UnitTypeId.NEXUS,\n            pos=next_expand_loc,\n        )\n</code></pre> Note, you could use this solution for other buildings too, if you already calculated exactly where you will place the structure.</p> </li> <li> <p><code>self.distribute_workers()</code> - This one is obviously broken if you're using <code>Mining</code> behavior but added for completion\u2019s sake!</p> </li> <li> <p><code>self.select_build_worker()</code> Problem  Similar to previous problems, <code>python-sc2</code> will not be able to select a  worker without <code>ares-sc2</code> trying to steal it back.   Solution Ask <code>ares</code> for a worker  <pre><code>from ares.consts import UnitRole\n\nif worker := self.mediator.select_worker(\n        target_position=self.start_location\n    ):\n    self.mediator.assign_role(tag=worker.tag, role=UnitRole.BUILDING)\n</code></pre></p> </li> </ul>"},{"location":"tutorials/gotchas.html#building-structures","title":"Building structures","text":"<p>This section covers breaking <code>python-sc2</code> functionality if you interact with <code>ares</code> custom build tracker in any way. You're maybe using the building tracker if you use the following <code>ares</code> features:</p> <ul> <li> <p><code>BuildStructure</code> macro behavior</p> </li> <li> <p><code>self.mediator.request_building_placement()</code></p> </li> <li> <p>Using the <code>ares</code> <code>BuildRunner</code> system in your bot</p> </li> </ul>"},{"location":"tutorials/gotchas.html#selfalready_pending-breaks-for-pending-structures","title":"<code>self.already_pending()</code> breaks for pending structures","text":""},{"location":"tutorials/gotchas.html#problem_1","title":"Problem","text":"<p>Due to the custom tracking of workers that are currently on route to construct structures, the <code>already_pending()</code> method in <code>python-sc2</code> has no knowledge of these pending structures.</p>"},{"location":"tutorials/gotchas.html#solution_1","title":"Solution","text":"<p><code>ares</code> has an alternative function for pending structures: <pre><code># checks workers on route and in progress structures\nnum_pending_barracks: int = self.structure_pending(UnitTypeId.BARRACKS)\n</code></pre> You could also check how many workers are on route to build a structure if desired. For Terran this will return same value as <code>structure_pending</code> as worker is always present. For Protoss or Zerg this will only count workers on route. <pre><code># checks workers on route, doesn't include gateways in construction\nnum_on_route_to_build_gateways: int = self.mediator.get_building_counter[UnitTypeId.GATEWAY]\n</code></pre></p>"},{"location":"tutorials/gotchas.html#mixing-ares-sc2-and-python-sc2-build-methods","title":"Mixing <code>ares-sc2</code> and <code>python-sc2</code> build methods","text":"<p>There are no known breakages here, but a word of warning that mixing building structures via <code>ares</code> building methods and <code>python-sc2</code> find placement queries could have unintended consequences. If possible try to stick with one system or the other, or limit mixing. <code>ares</code> in the background will check if position is available before building so mixing may be fine in most cases.</p> <p>Example <code>ares-sc2</code> functions and methods that may interfere with <code>python-sc2</code> convenience methods:</p> <ul> <li><code>BuildStructure</code> behavior </li> <li><code>self.mediator.request_building_placement()</code></li> <li>Using <code>ares</code> <code>BuildRunner</code> system in your bot</li> </ul> <p>These could interfere with following <code>python-sc2</code> methods:</p> <ul> <li><code>self.build()</code></li> <li><code>self.find_placement()</code></li> <li>Your own calculated placements</li> </ul>"},{"location":"tutorials/gotchas.html#selecting-a-unit-already-assigned-to-a-unitsquad","title":"Selecting a unit already assigned to a <code>UnitSquad</code>","text":"<p>If you are using <code>ares-sc2</code> unit squad system, and you want to select a unit already assigned to a squad then you should take care to remove the unit to ensure accurate squad calculations. You can do so by making the following mediator request:</p> <pre><code>from sc2.unit import Unit\n\n# pretend this unit is already assigned to a unit squad\nunit: Unit = self.units[0]\nself.mediator.remove_tag_from_squads(tag=unit.tag)\n</code></pre> <p>Note if you're using the <code>ares</code> role system, when assigning a unit a new role, units are removed from squads automatically. So this should work too: <pre><code>from ares.consts import UnitRole\nfrom sc2.unit import Unit\n\n# pretend this unit is already assigned to a unit squad\nunit: Unit = self.units[0]\n# switches unit to new role, and removes from any squad\nself.mediator.assign_role(tag=unit.tag, role=UnitRole.DEFENDING)\n</code></pre></p>"},{"location":"tutorials/gotchas.html#other-gotchas","title":"Other gotchas?","text":"<p>Found something not listed here? Please feel free to contribute to the docs or raise an issue in the <code>ares-sc2</code> github repo.</p>"},{"location":"tutorials/influence_and_pathing.html","title":"Influence and Pathing","text":"<p>The ares framework comes with the SC2MapAnalysis library already integrated. This integration  provides access to the library's grid and pathing features, enabling ares to offer a variety of  preconfigured grids and pathing functions right out of the box. This also enables users to create their own custom grids which they can use with existing ares pathing and behavior methods.</p>"},{"location":"tutorials/influence_and_pathing.html#what-is-a-grid","title":"What is a grid?","text":"<p>A grid is essentially a two-dimensional array, where each element represents an x,y coordinate in the game,  and the value of that element will contain some numerical value. A basic ground grid might contain zeroes for unpathable tiles and ones for pathable. See a visual example below of a simple pathing ground grid the Blizzard API provides.</p> <p></p> <p>A basic grid can be used for all kinds of purposes, but in the context of combat we would like to add cost (sometimes known as influence) to this map. For example in pathable cells that contain enemy dangers we might increase the value from the default of <code>1.0</code> to some value that represents the danger level. With this information we can enhance our micro opportunities, and any pathing queries in <code>ares</code> (via the SC2MapAnalysis library) will take into account cost when calculating paths.</p>"},{"location":"tutorials/influence_and_pathing.html#existing-grids-in-ares","title":"Existing grids in ares","text":"<p><code>ares</code> has several grids with relevant enemy cost added, they are opinionated but are intended to help a user quickly get up and running with pathfinding and enemy influence. At the end of this tutorial we describe how to create your own grids.</p>"},{"location":"tutorials/influence_and_pathing.html#grids","title":"Grids","text":"<p>The following grids are already setup ready to use out of the box.</p> <ul> <li><code>self.mediator.get_air_avoidance_grid</code> an air grid containing dangerous effects to avoid. For example storms, ravager biles, parasitic bombs, nukes etc.</li> <li><code>self.mediator.get_air_grid</code> an air grid containing all enemy units and effects dangerous to air.</li> <li><code>self.mediator.get_air_vs_ground_grid</code> a specialised air grid where ground pathable tiles have increased cost. The idea behind this one is for air units will favour high ground areas when  using pathing queries.</li> <li><code>self.mediator.get_climber_grid</code> - Same as <code>get_ground_grid</code> but areas where reapers can jump, or colossus can climb are pathable.</li> <li><code>self.mediator.get_ground_grid</code> - A ground grid that contains all enemy units and effects dangerous to ground.</li> <li><code>self.mediator.get_ground_to_air_grid</code> - A air grid that contains only cost from ground enemies that are dangerous to air.</li> </ul>"},{"location":"tutorials/influence_and_pathing.html#example-grid-usage","title":"Example grid usage","text":"<p>This section contains practical uses for influence and pathing.</p>"},{"location":"tutorials/influence_and_pathing.html#pathing","title":"Pathing","text":"<p><code>ares</code> contains several ways to use pathing:</p> <ul> <li> <p><code>self.mediator.find_path_next_point</code> Where you have a unit, but you just need the next point to move along a path. <pre><code>move_to: Point2 = self.mediator.find_path_next_point(\n    start=self.start_location,\n    target=self.enemy_start_locations[0],\n    grid=self.mediator.get_air_grid\n)\n</code></pre></p> </li> <li> <p><code>self.mediator.find_raw_path</code> Get the entire queried path. <pre><code>path: list[Point2] = self.mediator.find_raw_path(\n    start=self.start_location,\n    target=self.enemy_start_locations[0],\n    grid=self.mediator.get_air_grid\n)\n</code></pre></p> </li> <li> <p><code>self.mediator.find_low_priority_path</code> This will calculate an entire path but then only return several points along this path.  Useful for queuing up commands, for example an overlord going to a spotting position. <pre><code>path: list[Point2] = self.mediator.find_low_priority_path(\n    start=self.start_location,\n    target=self.enemy_start_locations[0],\n    grid=self.mediator.get_air_grid\n)\n</code></pre></p> </li> <li> <p><code>PathUnitToTarget</code> A <code>CombatBehavior</code> that takes care of pathing and moving the unit. <pre><code>from ares.behaviors.combat.individual import PathUnitToTarget\nfrom ares.behaviors.behavior import Behavior\n\nunit: Unit = self.workers[0]\n\n\npath_unit: Behavior = PathUnitToTarget(\n    unit=unit,\n    grid=self.mediator.get_ground_grid,\n    target=self.game_info.map_center\n)\nself.register_behavior(path_unit)\n</code></pre></p> </li> <li> <p><code>PathGroupToTarget</code> A <code>CombatBehavior</code> that takes care of pathing and moving an entire group. <pre><code>from ares.behaviors.combat.group import PathGroupToTarget\nfrom ares.behaviors.behavior import Behavior\n\ngroup: Units = self.workers\n\n\npath_group: Behavior = PathGroupToTarget(\n    start=group.center,\n    group=group,\n    group_tags={u.tag for u in group},\n    grid=self.mediator.get_ground_grid,\n    target=self.game_info.map_center\n)\nself.register_behavior(path_group)\n</code></pre></p> </li> </ul>"},{"location":"tutorials/influence_and_pathing.html#keeping-units-safe","title":"Keeping units safe","text":"<ul> <li> <p><code>self.mediator.find_closest_safe_spot</code> Given a position, find a nearby safe spot. Most useful for working out where to retreat to. <pre><code>safe_spot: Point2 = self.mediator.find_closest_safe_spot(\n    from_pos=self.start_location,\n    grid=self.mediator.get_air_avoidance_grid,\n    radius=8\n)\n</code></pre></p> </li> <li> <p><code>KeepUnitSafe</code> A <code>CombatBehavior</code> that takes care of finding a safe position and moving the unit. <pre><code>from ares.behaviors.combat.individual import KeepUnitSafe\nfrom ares.behaviors.behavior import Behavior\n\nunit: Unit = self.workers[0]\n\n\nkeep_safe: Behavior = KeepUnitSafe(\n    unit=unit,\n    grid=self.mediator.get_ground_grid,\n)\nself.register_behavior(keep_safe)\n</code></pre></p> </li> <li> <p><code>KeepGroupSafe</code> A <code>CombatBehavior</code> that keeps an entire group safe. <pre><code>from ares.behaviors.combat.group import KeepGroupSafe \nfrom ares.behaviors.behavior import Behavior\n\ngroup: Units = self.workers\n\n\nkeep_group_safe: Behavior = KeepGroupSafe(\n    group=group,\n    grid=self.mediator.get_ground_grid,\n)\nself.register_behavior(keep_group_safe)\n</code></pre></p> </li> </ul>"},{"location":"tutorials/influence_and_pathing.html#checking-cost","title":"Checking cost","text":"<p>Grids are <code>numpy</code> arrays, and each cell matches the in game position:</p> <pre><code>import numpy as np\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\n\ngrid: np.ndarray = self.mediator.get_climber_grid\n\nif reapers := self.mediator.get_own_army_dict[UnitTypeId.REAPER]:\n    for reaper in reapers:\n        pos: Point2 = reaper.position\n        reaper_danger_level: float = grid[pos[0], pos[1]]\n</code></pre> <p>Included with <code>ares</code> is the <code>cython_extensions-sc2 library</code>, which includes some helper functions for checking numpy grids. <pre><code>import numpy as np\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom cython_extensions import cy_point_below_value\n\ngrid: np.ndarray = self.mediator.get_climber_grid\n\nif reapers := self.mediator.get_own_army_dict[UnitTypeId.REAPER]:\n    for reaper in reapers:\n        pos: Point2 = reaper.position\n        reaper_is_safe: float = cy_point_below_value(\n            grid=grid, \n            position=pos.rounded,\n            weight_safety_limit=1.0 # default pathing cell with no danger is 1.0\n        )\n</code></pre></p> <p>Have a check on the <code>cython_extensions-sc2</code> repo docs for other functions including: </p> <ul> <li><code>cy_all_points_below_max_value</code></li> <li><code>cy_all_points_have_value</code></li> <li><code>cy_last_index_with_value</code></li> <li><code>cy_points_with_value</code></li> </ul>"},{"location":"tutorials/influence_and_pathing.html#create-your-own-grids","title":"Create your own grids","text":"<p>The available grids in ares are pre-filled with enemy cost based on the developers' perspectives.  However, you have the flexibility to create your own custom grids. Even better, you can integrate  these custom grids into existing ares functions and behaviors!</p> <p>As the SC2MapAnalysis library in integrated into <code>ares</code> let's use that to get a blank grid, then we add cost to the map. See the example below:</p> <pre><code>from map_analyzer import MapData\nfrom ares import AresBot\nimport numpy as np\nfrom sc2.position import Point2\n\nclass MyBot(AresBot):\n    async def on_step(self, iteration: int) -&gt; None:\n        # get access to the SC2MapAnalysis library\n        map_data: MapData = self.mediator.get_map_data_object\n\n        # get a clean ground grid\n        my_ground_grid: np.ndarray = map_data.get_pyastar_grid()\n        # or an air grid if needed\n        my_air_grid: np.ndarray = map_data.get_clean_air_grid()\n\n        \"\"\"\n        Add cost to this grid\n        For this example, let's make the enemy spawn location\n        really dangerous!\n        In effect this will draw a circle (20 radius) around the enemy spawn,\n        and add 100 cost to all tiles in this circle.\n        \"\"\"\n        my_ground_grid = map_data.add_cost(\n            position=self.enemy_start_locations[0],\n            radius=20,\n            grid=my_ground_grid,\n            weight=100.5\n        )\n\n\n        \"\"\"\n        In a real world bot, you probably add cost for enemy units,\n        structures and effects, something like:\n        \"\"\"\n        radius_buffer: float = 2.0\n        for unit in self.all_enemy_units:\n            if unit.can_attack_ground:\n                my_ground_grid = map_data.add_cost(\n                    position=unit.position,\n                    radius=unit.ground_range + radius_buffer,\n                    grid=my_ground_grid,\n                    weight=unit.ground_dps\n                )\n            if unit.can_attack_air:\n                my_air_grid = map_data.add_cost(\n                    position=self.enemy_start_locations[0],\n                    radius=unit.air_range + radius_buffer,\n                    grid=my_air_grid,\n                    weight=unit.ground_dps\n                )\n\n        # now my_ground_grid, my_ground_grid are ready to use\n\n        # will find the best path to enemy spawn, factoring in enemy cost\n        move_to: Point2 = self.mediator.find_path_next_point(\n            start=self.start_location,\n            target=self.enemy_start_locations[0],\n            grid=my_ground_grid\n        )\n\n        \"\"\"\n        Use custom grids with any ares method, behavior etc\n        \"\"\"\n</code></pre>"},{"location":"tutorials/managing_production.html","title":"Managing Production","text":"<p>Dealing with production logic for a bot often means wrestling with the same old repetitive code headaches.  Imagine starting off with a bot geared towards a stalker and immortal combo, finely tuning your logic around that. Now, say you want to shake things up and switch to a late-game skytoss setup \u2013 suddenly, you're  stuck adding more code for production facilities, tech structures, and handling those late-game units.</p> <p>We get it, this kind of redundancy is a pain. We didn't just  want to make transitioning between army compositions smoother; we wanted to kick out all that extra,  unnecessary code clutter. Whether you're rocking a stalker and immortal crew or going all-in on a late-game  skytoss spectacle, our approach offers a more straightforward and adaptable development process.</p> <p>Furthermore, this system is split into two main behaviors, the <code>SpawnController</code> to manage army production, and <code>ProductionController</code> to add production and tech up. Depending on your needs you can use one, both or none at all!</p>"},{"location":"tutorials/managing_production.html#defining-army-compositions","title":"Defining army compositions","text":"<p>Both controllers rely on an army composition dictionary, for example: <pre><code>from sc2.ids.unit_typeid import UnitTypeId as UnitID\n\n@property\ndef viking_tank(self) -&gt; dict:\n    return {\n        UnitID.MARINE: {\"proportion\": 0.69, \"priority\": 4},\n        UnitID.SIEGETANK: {\"proportion\": 0.13, \"priority\": 0},\n        UnitID.VIKINGFIGHTER: {\"proportion\": 0.16, \"priority\": 3},\n        UnitID.RAVEN: {\"proportion\": 0.02, \"priority\": 1},\n    }\n</code></pre> Things to note:</p> <ul> <li><code>SpawnController</code> will not produce build structures for you. Please be especially careful of this fact when morphing units. For example Archons, Banelings, Ravagers, Lurkers or Brood Lords.</li> <li>The <code>proportion</code> values should add up to 1.0 (0.69 + 0.13 + 0.16 + 0.02 = 1.0)</li> <li>Each declared unit should be given a priority, where 0 is the highest. This allows resources to be saved for important units.</li> </ul>"},{"location":"tutorials/managing_production.html#running-the-controllers","title":"Running the controllers","text":"<p>Let's create a simple bot, demonstrating how to run these controllers. <pre><code>from ares import AresBot\nfrom ares.behaviors.macro import ProductionController, SpawnController\n\nfrom sc2.ids.unit_typeid import UnitTypeId as UnitID\n\nclass TestBot(AresBot):\n\n    @property\n    def viking_tank(self) -&gt; dict:\n        return {\n            UnitID.MARINE: {\"proportion\": 0.69, \"priority\": 4},\n            UnitID.SIEGETANK: {\"proportion\": 0.13, \"priority\": 0},\n            UnitID.VIKINGFIGHTER: {\"proportion\": 0.16, \"priority\": 3},\n            UnitID.RAVEN: {\"proportion\": 0.02, \"priority\": 1},\n        }\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(TestBot, self).on_step(iteration)\n\n        production_location = self.start_location\n\n        # production controller\n        self.register_behavior(\n            ProductionController(self.viking_tank, production_location)\n        )\n\n        # spawn controller\n        self.register_behavior(\n            SpawnController(self.viking_tank)\n        )\n</code></pre></p> <p>These behaviors can be further customized through arguments,  please refer to the API docs</p>"},{"location":"tutorials/managing_production.html#setting-up-a-macroplan","title":"Setting up a <code>MacroPlan</code>","text":"<p>With a <code>MacroPlan</code> you may add several macro behaviors to a single plan, by defining them in priority order you gain more control over how your macro tasks are executed versus littering your code with <code>self.register_behavior(...)</code> for several macro behaviors.</p> <p>Let's enhance our above example, we would like our bot to prioritize building supply. Followed by workers, maintaining gas structures, spawning units, then lastly adding production:</p> <pre><code>from ares import AresBot\nfrom ares.behaviors.macro import (\n    AutoSupply, \n    BuildWorkers,\n    GasBuildingController,\n    MacroPlan, \n    ProductionController, \n    SpawnController,\n)\n\nfrom sc2.ids.unit_typeid import UnitTypeId as UnitID\n\nclass TestBot(AresBot):\n\n    @property\n    def viking_tank(self) -&gt; dict:\n        return {\n            UnitID.MARINE: {\"proportion\": 0.69, \"priority\": 4},\n            UnitID.SIEGETANK: {\"proportion\": 0.13, \"priority\": 0},\n            UnitID.VIKINGFIGHTER: {\"proportion\": 0.16, \"priority\": 3},\n            UnitID.RAVEN: {\"proportion\": 0.02, \"priority\": 1},\n        }\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(TestBot, self).on_step(iteration)\n\n        production_location = self.start_location\n\n        macro_plan: MacroPlan = MacroPlan()\n        macro_plan.add(AutoSupply(production_location))\n        macro_plan.add(BuildWorkers(to_count=48))\n        macro_plan.add(GasBuildingController(to_count=8))\n        macro_plan.add(SpawnController(self.viking_tank))\n        macro_plan.add(ProductionController(\n            self.viking_tank, production_location\n        ))\n\n        # only need to register once for whole plan\n        self.register_behavior(macro_plan)\n</code></pre>"},{"location":"tutorials/migrating.html","title":"Migrating from python-sc2","text":"<p>Migrating from an existing bot made with burny's python-sc2 should be simple in most cases.</p>"},{"location":"tutorials/migrating.html#installing-ares-sc2","title":"Installing <code>ares-sc2</code>","text":""},{"location":"tutorials/migrating.html#using-the-starter-bot-template","title":"Using the starter bot template","text":"<p>This will likely be simplest if you're willing to follow the starter bot structure and conventions. Not only that, if you make a new github repository based on this template, you'll benefit from automated ladder ready zip builds via github actions on each push to the <code>main</code> branch.</p> <ol> <li> <p>Follow the guide on the starter-bot-repo, and ensure that it is running before proceeding.</p> </li> <li> <p>Now let's assume your bot folder has some layout like:     <pre><code>MyBot\n\u2514\u2500\u2500\u2500my_bot\n\u2502   \u2514\u2500\u2500\u2500some_folder\n\u2502   \u2514\u2500\u2500\u2500another_folder\n\u2502   \u2514\u2500\u2500\u2500main.py \n\u2514\u2500\u2500\u2500sc2\n\u2514\u2500\u2500\u2500run.py\n\u2514\u2500\u2500\u2500ladder.py\n</code></pre></p> <p>After setting up the starter-bot repo, the new structure will look like: (ignored some files for clarity here) <pre><code>ares-sc2-bot-template\n\u2514\u2500\u2500\u2500ares-sc2\n\u2514\u2500\u2500\u2500bot\n\u2502   \u2514\u2500\u2500\u2500main.py \n\u2514\u2500\u2500\u2500scripts\n\u2514\u2500\u2500\u2500run.py\n\u2514\u2500\u2500\u2500ladder.py\n</code></pre></p> <p>You should then replace the contents of the <code>bot</code> directory in the starter-bot with the contents of  your <code>my_bot</code> directory. If your main entry point to your bot is not named <code>main.py</code> then ensure it is renamed and is placed directly in <code>bot</code> diretory, replacing the existing <code>main.py</code>.  There is no need to move over files or folders like <code>sc2</code>, <code>run.py</code> or <code>ladder.py</code> from your existing bot.</p> </li> <li> <p>Go to the <code>#Converting current</code>python-sc2<code>bot to an</code>ares<code>bot</code> section of this guide.</p> </li> </ol>"},{"location":"tutorials/migrating.html#installing-ares-sc2-directly","title":"Installing <code>ares-sc2</code> directly","text":"<p>If you want more control then installing from the main ares-sc2 repo might be desired. Cloning the repo and running <code>poetry install</code> should provide everything required to run <code>ares</code> with your bot. Please reach out on the SC2AI discord server via the #ares-sc2 channel if you need assistance.</p> <p>To prepare your bot for ladder release, it is worth familarizing yourself with the <code>create_ladder_zip.py</code> script on the starter bot repo. You may need to tweak this based on your own scenario. </p> <p>IMPORTANT: You should create your ladder zip on a debian based system running python 3.11. You can use WSL or docker if on Windows/MAC. We are planning to make this user friendly in the future.</p>"},{"location":"tutorials/migrating.html#converting-current-python-sc2-bot-to-an-ares-bot","title":"Converting current <code>python-sc2</code> bot to an <code>ares</code> bot","text":"<p>Code wise there isn't much to change, <code>main.py</code> will need a few changes:</p> <ul> <li> <p>The main bot object should inherit from <code>ares-sc2</code></p> <p><code>python-sc2</code>: <pre><code>from sc2.bot_ai import BotAI\n\nclass MyBot(BotAI):\n    pass\n</code></pre></p> <p><code>ares-sc2</code>: <pre><code>from ares import AresBot\n\nclass MyBot(AresBot):\n    pass\n</code></pre></p> </li> <li> <p>Any <code>on</code> <code>python-sc2</code> hook methods that you use should add a <code>super</code> call</p> <p>Only convert the hooks you actually use.</p> <p><code>python-sc2</code>:     <pre><code>class MyBot(AresBot):\n    async def on_step(self, iteration: int) -&gt; None:\n        pass\n\n    async def on_start(self, iteration: int) -&gt; None:\n        pass\n\n    async def on_end(self, game_result: Result) -&gt; None:\n        pass\n\n    async def on_building_construction_complete(self, unit: Unit) -&gt; None:\n        pass\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        pass\n\n    async def on_unit_destroyed(self, unit_tag: int) -&gt; None:\n        pass\n\n    async def on_unit_took_damage(self, unit: Unit, amount_damage_taken: float) -&gt; None:\n        pass\n</code></pre></p> <p>Replace all <code>MyBot</code> with your actual class name</p> <p><code>ares-sc2</code>:     <pre><code>class MyBot(AresBot):\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(MyBot, self).on_step(iteration)\n\n        # on_step logic here ...\n\n    async def on_start(self, iteration: int) -&gt; None:\n        await super(MyBot, self).on_start(iteration)\n\n        # on_start logic here ...\n\n    async def on_end(self, game_result: Result) -&gt; None:\n        await super(MyBot, self).on_end(iteration)\n\n        # custom on_end logic here ...\n\n    async def on_building_construction_complete(self, unit: Unit) -&gt; None:\n        await super(MyBot, self).on_building_construction_complete(iteration)\n\n        # custom on_building_construction_complete logic here ...\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        await super(MyBot, self).on_unit_created(unit)\n\n        # custom on_unit_created logic here ...\n\n    async def on_unit_destroyed(self, unit_tag: int) -&gt; None:\n        await super(MyBot, self).on_unit_destroyed(unit_tag)\n\n        # custom on_unit_destroyed logic here ...\n\n    async def on_unit_took_damage(self, unit: Unit, amount_damage_taken: float) -&gt; None:\n        await super(MyBot, self).on_unit_took_damage(unit, amount_damage_taken)\n\n        # custom on_unit_took_damage logic here ...\n</code></pre></p> </li> </ul>"},{"location":"tutorials/unit_squads_group_behaviors.html","title":"Unit Squads and Group Behaviors","text":"<p>Recommended Reading:   - Explore how to effectively curate  Combat Maneuvers with individual units,  providing insights into the workings of the combat maneuver and behavior system in <code>ares-sc2</code>.  - Previous knowledge of the unit role system  is beneficial</p>"},{"location":"tutorials/unit_squads_group_behaviors.html#why-opt-for-unit-squads-and-group-behaviors","title":"Why Opt for Unit Squads and Group Behaviors?","text":"<ul> <li>Enable a squadron of units to function cohesively as a group, rather than as  individual units lacking consideration for the collective strength in the face of nearby enemies.</li> <li>Gain visibility into the spatial distribution of our units; recognizing scenarios  where our main squad may have fewer units than smaller squads moving across the map.  This insight could prompt strategic decisions such as pulling back to allow units to converge.</li> <li>Embrace the concept of group thinking within a squad, unlocking the potential for  human-like control, where all units respond to a single, coordinated action.</li> </ul>"},{"location":"tutorials/unit_squads_group_behaviors.html#group-behavior-tutorial","title":"Group Behavior tutorial","text":"<p>To begin, here's a basic example of a Zerg bot utilizing the unit role system to assign all units to the  <code>ATTACKING</code> role. <pre><code>from ares import AresBot\nfrom ares.consts import ALL_STRUCTURES, WORKER_TYPES, UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nclass ZergBot(AresBot):\n    def __init__(self, game_step_override = None):\n        super().__init__(game_step_override)\n\n    async def on_step(self, iteration: int) -&gt; None:\n        # retreive all attacking units\n        attackers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        # When a unit is created, \n        # assign it to ATTACKING using ares unit role system\n        await super(ZergBot, self).on_unit_created(unit)\n        type_id: UnitTypeId = unit.type_id\n        # don't assign structures or workers\n        if type_id in ALL_STRUCTURES or type_id in WORKER_TYPES:\n            return\n\n        # assign all other units to ATTACKING role by default\n        self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n</code></pre></p> <p>Now imagine at some specific moment we would like to separate any roaches into their own separate hit squad. In an actual game you should choose to do this depending on the  game state, but for the purposes of clarity in this tutorial lets seperate the roaches at 6 minutes.</p> <pre><code>from ares import AresBot\nfrom ares.consts import ALL_STRUCTURES, WORKER_TYPES, UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nclass ZergBot(AresBot):\n    def __init__(self, game_step_override = None):\n        super().__init__(game_step_override)\n\n        self._assigned_roach_hit_squad: bool = False\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(ZergBot, self).on_step(iteration)\n        # retreive all attacking units\n        attackers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n\n        # retreive the roach hit squad, if one has been assigned\n        roach_hit_squad: Units = self.mediator.get_units_from_role(\n            role=UnitRole.CONTROL_GROUP_ONE, unit_type=UnitTypeId.ROACH\n        )\n\n        # At 6 minutes assign all roaches to CONTROL_GROUP_ONE\n        # This will remove them from ATTACKING automatically\n        if not self._assigned_roach_hit_squad and self.time &gt; 360.0:\n            self._assigned_roach_hit_squad = True\n            roaches: list[Unit] = [\n                u for u in attackers if u.type_id == UnitTypeId.ROACH\n            ]\n            for roach in roaches:\n                self.mediator.assign_role(\n                    tag=roach.tag, role=UnitRole.CONTROL_GROUP_ONE\n                )\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        # When a unit is created, \n        # assign it to ATTACKING using ares unit role system\n        await super(ZergBot, self).on_unit_created(unit)\n        type_id: UnitTypeId = unit.type_id\n        # don't assign structures or workers\n        if type_id in ALL_STRUCTURES or type_id in WORKER_TYPES:\n            return\n\n        # assign all other units to ATTACKING role by default\n        self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n</code></pre> <p>Notice we have now seperated all roaches from the main <code>UnitRole.ATTACKING</code> force and provided them with a new <code>UnitRole.CONTROL_GROUP_ONE</code> role. We can now control these forces separately. Now onto the fun part of curating group combat maneuvers!</p> <p>We will add a new method to control our hit squad, let's name it <code>control_roach_hit_squad()</code></p> <pre><code>from ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.group import AMoveGroup\nfrom ares.consts import ALL_STRUCTURES, WORKER_TYPES, UnitRole\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nclass ZergBot(AresBot):\n    def __init__(self, game_step_override = None):\n        super().__init__(game_step_override)\n\n        self._assigned_roach_hit_squad: bool = False\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(ZergBot, self).on_step(iteration)\n        # retreive all attacking units\n        attackers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n\n        # retreive the roach hit squad, if one has been assigned\n        roach_hit_squad: Units = self.mediator.get_units_from_role(\n            role=UnitRole.CONTROL_GROUP_ONE, unit_type=UnitTypeId.ROACH\n        )\n\n        self.control_roach_hit_squad(\n            roach_hit_squad=roach_hit_squad, \n            target=self.enemy_start_locations[0]\n        )\n\n        # At 6 minutes assign all roaches to CONTROL_GROUP_ONE\n        # This will remove them from ATTACKING automatically\n        if not self._assigned_roach_hit_squad and self.time &gt; 360.0:\n            self._assigned_roach_hit_squad = True\n            roaches: list[Unit] = [\n                u for u in attackers if u.type_id == UnitTypeId.ROACH\n            ]\n            for roach in roaches:\n                self.mediator.assign_role(\n                    tag=roach.tag, role=UnitRole.CONTROL_GROUP_ONE\n                )\n\n    def control_roach_hit_squad(\n        self, \n        roach_hit_squad: Units, \n        target: Point2\n    ) -&gt; None:\n        # declare a new group maneuver\n        roach_squad_maneuver: CombatManeuver = CombatManeuver()\n        # add group behaviors, these can be behaviors provided by ares\n        # or create your own custom group behaviors!\n        roach_squad_maneuver.add(\n          AMoveGroup(\n            group=roach_hit_squad, \n            group_tags={r.tag for r in roach_hit_squad}, \n            target=target\n          )\n        )\n\n        self.register_behavior(roach_squad_maneuver)\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        # When a unit is created, \n        # assign it to ATTACKING using ares unit role system\n        await super(ZergBot, self).on_unit_created(unit)\n        type_id: UnitTypeId = unit.type_id\n        # don't assign structures or workers\n        if type_id in ALL_STRUCTURES or type_id in WORKER_TYPES:\n            return\n\n        # assign all other units to ATTACKING role by default\n        self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n</code></pre> <p>This method creates a basic \"a-move\" group maneuver for our roaches. Given a target, the roaches will  advance towards it. Moreover, <code>ares-sc2</code> automatically checks for duplicated actions to prevent action spam,  enabling your bot to \"a-move\" akin to a human player.</p>"},{"location":"tutorials/unit_squads_group_behaviors.html#extending-the-group-maneuver","title":"Extending the group maneuver","text":"<p>Similar to individual combat maneuvers, Behaviors should be orchestrated in priority order.  <code>ares</code> executes behaviors according to the user-provided order, therefore if a behavior executes and action, any subsequent behaviors will be ignored. With this in mind, let's add a group behavior  for when enemies are close. We'd like our roaches to be aggressive, closing in on nearby enemies using the <code>StutterGroupForward</code> behavior.  Otherwise, if no enemies are present, the <code>AMoveGroup</code> behavior will execute:</p> <pre><code>from cython_extensions import cy_center\n\nfrom sc2.position import Point2\nfrom sc2.units import Units\n\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.group import AMoveGroup, StutterGroupForward\nfrom ares.consts import UnitTreeQueryType\n\n\ndef control_roach_hit_squad(\n        self, \n        roach_hit_squad: \n        Units, target: Point2\n    ) -&gt; None:\n    squad_position: Point2 = Point2(cy_center(roach_hit_squad))\n\n    # retreive close enemy to the roach squad\n    close_ground_enemy: Units = self.mediator.get_units_in_range(\n        start_points=[squad_position],\n        distances=15.5,\n        query_tree=UnitTreeQueryType.EnemyGround,\n    )[0]\n\n    # declare a new group maneuver\n    roach_squad_maneuver: CombatManeuver = CombatManeuver()\n\n    # stutter forward to any ground enemies\n    # as this behavior is added first to the maneuver it \n    # has the highest priority\n    roach_squad_maneuver.add(\n      StutterGroupForward(\n        group=roach_hit_squad,\n        group_tags={u.tag for u in roach_hit_squad},\n        group_position=squad_position,\n        target=target,\n        enemies=close_ground_enemy,\n      )\n    )\n\n    # if StutterGroupForward does not execute, our units will AMove\n    roach_squad_maneuver.add(\n      AMoveGroup(\n        group=roach_hit_squad, \n        group_tags={r.tag for r in roach_hit_squad}, \n        target=target\n      )\n    )\n\n    self.register_behavior(roach_squad_maneuver)\n</code></pre>"},{"location":"tutorials/unit_squads_group_behaviors.html#unit-squads-enhanced-group-tactics","title":"Unit Squads: Enhanced Group Tactics","text":"<p>Our roach_squad_maneuver works well, but controlling roaches as a group has a significant flaw.  Imagine our roach squad is scattered across the map; issuing StutterGroupForward to roaches  that don't have nearby enemies is ineffective. Moreover, calculating close enemies to our  group becomes inaccurate, leading to undesirable behavior.</p> <p>Thankfully, we can utilize the UnitSquad system in ares-sc2 to split our hit squad into logical groups!  Let's enhance the control_roach_hit_squad method to incorporate this:</p> <pre><code>from sc2.position import Point2\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.group import AMoveGroup, StutterGroupForward\nfrom ares.consts import UnitRole, UnitTreeQueryType\nfrom ares.managers.squad_manager import UnitSquad\n\n\ndef control_roach_hit_squad(\n        self, \n        roach_hit_squad: Units, \n        target: Point2\n    ) -&gt; None:\n\n    squads: list[UnitSquad] = self.mediator.get_squads(\n        role=UnitRole.CONTROL_GROUP_ONE, squad_radius=9.0\n    )\n    for squad in squads:\n        squad_position: Point2 = squad.squad_position\n        units: list[Unit] = squad.squad_units\n        squad_tags: set[int] = squad.tags\n\n        # retreive close enemy to the roach squad\n        close_ground_enemy: Units = self.mediator.get_units_in_range(\n            start_points=[squad_position],\n            distances=11.5,\n            query_tree=UnitTreeQueryType.EnemyGround,\n        )[0]\n\n        # declare a new group maneuver\n        roach_squad_maneuver: CombatManeuver = CombatManeuver()\n\n        # stutter forward to any ground enemies\n        # as this behavior is added first to the maneuver it \n        # has the highest priority\n        roach_squad_maneuver.add(\n          StutterGroupForward(\n            group=units,\n            group_tags=squad_tags,\n            group_position=squad_position,\n            target=target,\n            enemies=close_ground_enemy,\n          )\n        )\n\n        # if StutterGroupForward does not execute, our units will AMove\n        roach_squad_maneuver.add(\n          AMoveGroup(\n            group=units, \n            group_tags=squad_tags, \n            target=target\n          )\n        )\n\n        self.register_behavior(roach_squad_maneuver)\n</code></pre> <p>Now, UnitSquad provides attributes such as squad_position, squad_units, and tags, eliminating the  need for manual calculations. This allows for greater synergy with the group maneuver system, as we can pass this attributes directly as arguments into group behaviors:</p> <pre><code>squad: UnitSquad\nAMoveGroup(\n    group=squad.squad_units, \n    group_tags=squad.tags, \n    target=target\n)\n</code></pre> <p>Our final bot looks a bit like this:</p> <pre><code>from ares import AresBot\nfrom ares.behaviors.combat import CombatManeuver\nfrom ares.behaviors.combat.group import AMoveGroup, StutterGroupForward\nfrom ares.consts import ALL_STRUCTURES, WORKER_TYPES, UnitRole, UnitTreeQueryType\nfrom ares.managers.squad_manager import UnitSquad\n\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.unit import Unit\nfrom sc2.units import Units\n\nclass ZergBot(AresBot):\n    def __init__(self, game_step_override = None):\n        super().__init__(game_step_override)\n\n        self._assigned_roach_hit_squad: bool = False\n\n    async def on_step(self, iteration: int) -&gt; None:\n        await super(ZergBot, self).on_step(iteration)\n        # retreive all attacking units\n        attackers: Units = self.mediator.get_units_from_role(\n            role=UnitRole.ATTACKING\n        )\n\n        # retreive the roach hit squad, if one has been assigned\n        roach_hit_squad: Units = self.mediator.get_units_from_role(\n            role=UnitRole.CONTROL_GROUP_ONE, unit_type=UnitTypeId.ROACH\n        )\n\n        self.control_roach_hit_squad(\n            roach_hit_squad=roach_hit_squad, \n            target=self.enemy_start_locations[0]\n        )\n\n        # At 6 minutes assign all roaches to CONTROL_GROUP_ONE\n        # This will remove them from ATTACKING automatically\n        if not self._assigned_roach_hit_squad and self.time &gt; 360.0:\n            self._assigned_roach_hit_squad = True\n            roaches: list[Unit] = [\n                u for u in attackers if u.type_id == UnitTypeId.ROACH\n            ]\n            for roach in roaches:\n                self.mediator.assign_role(\n                    tag=roach.tag, role=UnitRole.CONTROL_GROUP_ONE\n                )\n\n    def control_roach_hit_squad(\n            self, \n            roach_hit_squad: Units, \n            target: Point2\n        ) -&gt; None:\n\n        squads: list[UnitSquad] = self.mediator.get_squads(\n            role=UnitRole.CONTROL_GROUP_ONE, squad_radius=9.0\n        )\n        for squad in squads:\n            squad_position: Point2 = squad.squad_position\n            units: list[Unit] = squad.squad_units\n            squad_tags: set[int] = squad.tags\n\n            # retreive close enemy to the roach squad\n            close_ground_enemy: Units = self.mediator.get_units_in_range(\n                start_points=[squad_position],\n                distances=11.5,\n                query_tree=UnitTreeQueryType.EnemyGround,\n            )[0]\n\n            # declare a new group maneuver\n            roach_squad_maneuver: CombatManeuver = CombatManeuver()\n\n            # stutter forward to any ground enemies\n            # as this behavior is added first to the maneuver it \n            # has the highest priority\n            roach_squad_maneuver.add(\n              StutterGroupForward(\n                group=units,\n                group_tags=squad_tags,\n                group_position=squad_position,\n                target=target,\n                enemies=close_ground_enemy,\n              )\n            )\n\n            # if StutterGroupForward does not execute, our units will AMove\n            roach_squad_maneuver.add(\n              AMoveGroup(\n                group=units, \n                group_tags=squad_tags, \n                target=target\n              )\n            )\n\n            self.register_behavior(roach_squad_maneuver)\n\n    async def on_unit_created(self, unit: Unit) -&gt; None:\n        # When a unit is created, \n        # assign it to ATTACKING using ares unit role system\n        await super(ZergBot, self).on_unit_created(unit)\n        type_id: UnitTypeId = unit.type_id\n        # don't assign structures or workers\n        if type_id in ALL_STRUCTURES or type_id in WORKER_TYPES:\n            return\n\n        # assign all other units to ATTACKING role by default\n        self.mediator.assign_role(tag=unit.tag, role=UnitRole.ATTACKING)\n</code></pre>"}]}